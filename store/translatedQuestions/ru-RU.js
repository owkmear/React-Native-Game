import { Grades, Themes } from "../../model";

const questions = [
  {
    grade: Grades.Junior,
    theme: Themes.DATA_TYPES,
    question: "Что будет в консоли?",
    code: 'function sayHi() {\n  console.log(name);\n  console.log(age);\n  var name = "Lydia";\n  let age = 21;\n}\n\nsayHi();',
    correctAnswer: 4,
    variants: [
      "`Lydia` и `undefined`",
      "`Lydia` и `ReferenceError`",
      "`ReferenceError` и `21`",
      "`undefined` и `ReferenceError`",
    ],
    explanation:
      'Внутри функции мы сперва определяем переменную `name` с помощью ключевого слова `var`. Это означает, что переменная будет поднята (область памяти под переменную будет выделена во время фазы создания) со значением `undefined` по умолчанию, до тех пора пока исполнение кода не дойдет до строчки, где определяется переменная. Мы еще не определили значение `name` когда пытаемся вывести её в консоль, поэтому в консоли будет `undefined`.\n\nПеременные, определенные с помощью `let` (и `const`), также поднимаются, но в отличие от `var`, не _инициализируются_. Доступ к ним не возможен до тех пор, пока не выполнится строка их определения (инициализации). Это называется "временная мертвая зона". Когда мы пытаемся обратиться к переменным до того момента как они определены, JavaScript выбрасывает исключение `ReferenceError`.',
    id: 1,
  },
  {
    grade: Grades.Middle,
    theme: Themes.ASYNC,
    question: "Что будет в консоли?",
    code: "for (var i = 0; i < 3; i++) {\n  setTimeout(() => console.log(i), 1);\n}\n\nfor (let i = 0; i < 3; i++) {\n  setTimeout(() => console.log(i), 1);\n}",
    correctAnswer: 3,
    variants: ["`0 1 2` и `0 1 2`", "`0 1 2` и `3 3 3`", "`3 3 3` и `0 1 2`"],
    explanation:
      "Из-за очереди событий в JavaScript, функция `setTimeout` вызывается _после_ того как цикл будет завершен. Так как переменная `i` в первом цикле была определена с помощью `var`, она будет глобальной. В цикле мы каждый раз увеличиваем значение `i` на `1`, используя унарный оператор `++`. К моменту выполнения функции `setTimeout` значение `i` будет равно `3` в первом примере.\n\nВо втором цикле переменная `i` определена с помощью `let`. Такие переменные (а также `const`) имеют блочную область видимости (блок это что угодно между `{ }`). С каждой итерацией `i` будет иметь новое значение, и каждое значение будет замкнуто в своей области видимости внутри цикла.",
    id: 2,
  },
  {
    grade: Grades.Junior,
    theme: Themes.OBJECTS,
    question: "Что будет в консоли?",
    code: "const shape = {\n  radius: 10,\n  diameter() {\n    return this.radius * 2;\n  },\n  perimeter: () => 2 * Math.PI * this.radius\n};\n\nconsole.log(shape.diameter());\nconsole.log(shape.perimeter());",
    correctAnswer: 2,
    variants: [
      "`20` и `62.83185307179586`",
      "`20` и `NaN`",
      "`20` и `63`",
      "`NaN` и `63`",
    ],
    explanation:
      "Заметьте, что `diameter` это обычная функция, в то время как `perimeter` это стрелочная функция.\n\nУ стрелочных функций значение `this` указывает на окружающую область видимости, в отличие от обычных функций! Это значит, что при вызове `perimeter` значение `this` у этой функции указывает не на объект `shape`, а на внешнюю область видимости (например, window).\n\nУ этого объекта нет ключа `radius`, поэтому возвращается `undefined`.",
    id: 3,
  },
  {
    grade: Grades.Middle,
    theme: Themes.DATA_TYPES,
    question: "Что будет в консоли?",
    code: "+true;\n!'Lydia';",
    correctAnswer: 1,
    variants: ["`1` и `false`", "`false` и `NaN`", "`false` и `false`"],
    explanation:
      'Унарный плюс приводит операнд к числу. `true` это `1`, а `false` это `0`.\n\nСтрока `\'Lydia\'` это "истинное" значение. На самом деле мы спрашиваем "является ли это истинное значение ложным"? Ответ: `false`.',
    id: 4,
  },
  {
    grade: Grades.Junior,
    theme: Themes.OBJECTS,
    question: "Что НЕ является валидным?",
    code: "const bird = {\n  size: 'small'\n};\n\nconst mouse = {\n  name: 'Mickey',\n  small: true\n};",
    correctAnswer: 1,
    variants: [
      "`mouse.bird.size`",
      "`mouse[bird.size]`",
      '`mouse[bird["size"]]`',
      "Все варианты валидны",
    ],
    explanation:
      'В JavaScript все ключи объекта являются строками (кроме Symbol). И хотя мы не _набираем_ их как строки, они всегда преобразовываются к строкам под капотом.\n\nJavaScript интерпретирует (или распаковывает) операторы. При использовании квадратных скобок JS замечает `[` и продолжает пока не встретит `]`. Только после этого он вычислит то, что находится внутри скобок.\n\n`mouse[bird.size]`: Сперва определяется `bird.size`, которое равно `"small"`. `mouse["small"]` возвращает `true`.\n\nНо с записью через точку так не происходит. У `mouse` нет ключа `bird`. Таким образом, `mouse.bird` равно `undefined`. Затем мы запрашиваем ключ `size`, используя точечную нотацию: `mouse.bird.size`. Так как `mouse.bird` это `undefined`, мы запрашиваем `undefined.size`. Это не является валидным, и мы получаем ошибку типа `Cannot read property "size" of undefined`.',
    id: 5,
  },
  {
    grade: Grades.Junior,
    theme: Themes.OBJECTS,
    question: "Что будет в консоли?",
    code: "let c = { greeting: 'Hey!' };\nlet d;\n\nd = c;\nc.greeting = 'Hello';\nconsole.log(d.greeting);",
    correctAnswer: 1,
    variants: [
      "`Hello`",
      "`Hey!`",
      "`undefined`",
      "`ReferenceError`",
      "`TypeError`",
    ],
    explanation:
      "В JavaScript все объекты являются _ссылочными_ типами данных.\n\nСперва переменная `c` указывает на объект. Затем мы указываем переменной `d` ссылаться на тот же объект, что и `c`.\n\n![Image](https://i.imgur.com/ko5k0fs.png)\n\nКогда вы изменяете один объект, то изменяются значения всех ссылок, указывающих на этот объект.",
    id: 6,
  },
  {
    grade: Grades.Middle,
    theme: Themes.DATA_TYPES,
    question: "Что будет в консоли?",
    code: "let a = 3;\nlet b = new Number(3);\nlet c = 3;\n\nconsole.log(a == b);\nconsole.log(a === b);\nconsole.log(b === c);",
    correctAnswer: 3,
    variants: [
      "`true` `false` `true`",
      "`false` `false` `true`",
      "`true` `false` `false`",
      "`false` `true` `true`",
    ],
    explanation:
      "`new Number()` это встроенный конструктор функции. И хотя он выглядит как число, это не настоящее число: у него есть ряд дополнительных особеннстей, и это объект.\n\nОператор `==` разрешает приведение типов, он проверяет равенство _значений_. Оба значения равны `3`, поэтому возвращается `true`.\n\nПри использовании оператора `===` значение _и_ тип должны быть одинаковыми. Но в нашем случае это не так: `new Number()` это не число, это **объект**. Оба возвращают `false`.",
    id: 7,
  },
  {
    grade: Grades.Middle,
    theme: Themes.CLASSES,
    question: "Каким будет результат?",
    code: "class Chameleon {\n  static colorChange(newColor) {\n    this.newColor = newColor;\n    return this.newColor;\n  }\n\n  constructor({ newColor = 'green' } = {}) {\n    this.newColor = newColor;\n  }\n}\n\nconst freddie = new Chameleon({ newColor: 'purple' });\nfreddie.colorChange('orange');",
    correctAnswer: 4,
    variants: ["`orange`", "`purple`", "`green`", "`TypeError`"],
    explanation:
      "Функция `colorChange` является статической. Статические методы предназначены для работы только в конструкторе, в котором они созданы, и не могут передаваться каким-либо дочерним элементам или вызываться в экземплярах класса. Так как `freddie` является экземпляром класса `Chameleon`, функция не может быть вызвана для него. Будет выдана ошибка `TypeError`.",
    id: 8,
  },
  {
    grade: Grades.Junior,
    theme: Themes.OBJECTS,
    question: "Что будет в консоли?",
    code: "let greeting;\ngreetign = {}; // Опечатка!\nconsole.log(greetign);",
    correctAnswer: 1,
    variants: [
      "`{}`",
      "`ReferenceError: greetign is not defined`",
      "`undefined`",
    ],
    explanation:
      'В консоли выведется объект, потому что мы только что создали пустой объект в глобальном объекте! Когда мы вместо `greeting` написали `greetign`, интерпретатор JS на самом деле увидел:\n\n1. `global.greetign = {}` в Node.js\n2. `window.greetign = {}`, `frames.geetign = {}` и `self.greetign` в браузерах.\n3. `self.greetign` в веб-воркерах.\n4. `globalThis.greetign` во всех окружениях.\n\nНужно использовать `"use strict"`, чтобы избежать такого поведения. Эта запись поможет быть уверенным в том, что переменная была определена перед тем как ей присвоили значение.',
    id: 9,
  },
  {
    grade: Grades.Junior,
    theme: Themes.FUNCTIONS,
    question: "Что произойдет?",
    code: "function bark() {\n  console.log('Woof!');\n}\n\nbark.animal = 'dog';",
    correctAnswer: 1,
    variants: [
      "Ничего, всё в порядке!",
      "`SyntaxError`. Нельзя добавлять свойства функциям таким способом.",
      "`undefined`",
      "`ReferenceError`",
    ],
    explanation:
      "В JavaScript это возможно, т.к. функции это объекты! (Всё есть объект кроме примитивов).\n\nФункция — это специальный тип объекта, который можно вызвать. Кроме того, функция — это объект со свойствами. Свойство такого объекта нельзя вызвать, так как оно не является функцией.",
    id: 10,
  },
  {
    grade: Grades.Junior,
    theme: Themes.CLASSES,
    question: "Что будет в консоли?",
    code: "function Person(firstName, lastName) {\n  this.firstName = firstName;\n  this.lastName = lastName;\n}\n\nconst member = new Person('Lydia', 'Hallie');\nPerson.getFullName = function () {\n  return `${this.firstName} ${this.lastName}`;\n}\n\nconsole.log(member.getFullName());",
    correctAnswer: 1,
    variants: [
      "`TypeError`",
      "`SyntaxError`",
      "`Lydia Hallie`",
      "`undefined` `undefined`",
    ],
    explanation:
      "В JavaScript функции являются объектами, поэтому метод `getFullName` добавляется к самому объекту функции-конструктора. По этой причине мы можем вызвать `Person.getFullName()`, но `member.getFullName` выдает `TypeError`.\n\nЕсли вы хотите, чтобы метод был доступен для всех экземпляров объекта, вы должны добавить его в свойство прототипа:\n\n```js\nPerson.prototype.getFullName = function () {\n  return `${this.firstName} ${this.lastName}`;\n}\n```",
    id: 11,
  },
  {
    grade: Grades.Junior,
    theme: Themes.CLASSES,
    question: "Что будет в консоли?",
    code: "function Person(firstName, lastName) {\n  this.firstName = firstName;\n  this.lastName = lastName;\n}\n\nconst lydia = new Person('Lydia', 'Hallie');\nconst sarah = Person('Sarah', 'Smith');\n\nconsole.log(lydia);\nconsole.log(sarah);",
    correctAnswer: 1,
    variants: [
      '`Person {firstName: "Lydia", lastName: "Hallie"}` и `undefined`',
      '`Person {firstName: "Lydia", lastName: "Hallie"}` и `Person {firstName: "Sarah", lastName: "Smith"}`',
      '`Person {firstName: "Lydia", lastName: "Hallie"}` и `{}`',
    ],
    explanation:
      "Для `sarah` мы не использовали ключевое слово `new`. Использование `new` приводит к созданию нового объекта. Но без `new` он указывает на **глобальный объект**!\n\nМы указали, что `this.firstName` равно `\"Sarah\"` и `this.lastName` равно `\"Smith\"`. На самом деле мы определили `global.firstName = 'Sarah'` и `global.lastName = 'Smith'`. `sarah` осталась `undefined`, поскольку мы не возвращаем значение из функции `Person`.",
    id: 12,
  },
  {
    grade: Grades.Junior,
    theme: Themes.EVENTS,
    question: "Назовите три фазы распространения событий",
    code: null,
    correctAnswer: 4,
    variants: [
      "Цель > Захват > Всплытие",
      "Всплытие > Цель > Захват",
      "Цель > Всплытие > Захват",
      "Захват > Цель > Всплытие",
    ],
    explanation:
      "Во время фазы **захвата** событие распространяется с элементов родителей до элемента цели. После достижения **цели** начинается фаза **всплытия**.\n\n![Image](https://i.imgur.com/N18oRgd.png)",
    id: 13,
  },
  {
    grade: Grades.Junior,
    theme: Themes.CLASSES,
    question: "Все объекты имеют прототипы",
    code: null,
    correctAnswer: 2,
    variants: ["Да", "Нет"],
    explanation:
      "Все объекты имеют прототипы, кроме **базового объекта**. Базовый объект — это объект, созданный пользователем, или объект, созданный с использованием ключевого слова `new`. Базовый объект имеет доступ к некоторым методам и свойствам, таким как `.toString`. Вот почему вы можете использовать встроенные методы JavaScript! Все такие способы доступны в прототипе. Хотя JavaScript не может найти метод непосредственно в вашем объекте, он идет вниз по цепочке прототипов и находит его там, что делает его доступным.",
    id: 14,
  },
  {
    grade: Grades.Junior,
    theme: Themes.DATA_TYPES,
    question: "Каким будет результат?",
    code: "function sum(a, b) {\n  return a + b;\n}\n\nsum(1, '2');",
    correctAnswer: 3,
    variants: ["`NaN`", "`TypeError`", '`"12"`', "`3`"],
    explanation:
      'JavaScript это **динамически типизированный язык**: мы не определяем тип переменных. Переменные могут автоматически быть преобразованы из одного типа в другой без нашего участия, что называется _неявным приведением типов_. **Приведение** это преобразование из одного типа в другой.\n\nВ этом примере JavaScript сконвертировал число `1` в строку, чтобы операция внутри функции имела смысл и вернула значение. Во время сложения числа (`1`) и строки (`\'2\'`) число преобразовывается к строке. Мы можем конкатенировать строки вот так: `"Hello" + "World"`. Таким образом, `"1" + "2"` возвращает `"12"`.',
    id: 15,
  },
  {
    grade: Grades.Junior,
    theme: Themes.BASICS,
    question: "Что будет в консоли?",
    code: "let number = 0;\nconsole.log(number++);\nconsole.log(++number);\nconsole.log(number);",
    correctAnswer: 3,
    variants: ["`1` `1` `2`", "`1` `2` `2`", "`0` `2` `2`", "`0` `1` `2`"],
    explanation:
      "**Постфиксный** унарный оператор `++`:\n\n1. Возвращает значение (`0`)\n2. Инкрементирует значение (теперь число равно `1`)\n\n**Префиксный** унарный оператор `++`:\n\n1. Инкрементирует значение (число теперь равно `2`)\n2. Возвращает значение (`2`)\n\nРезультат: `0 2 2`.",
    id: 16,
  },
  {
    grade: Grades.Junior,
    theme: Themes.FUNCTIONS,
    question: "Что будет в консоли?",
    code: "function getPersonInfo(one, two, three) {\n  console.log(one);\n  console.log(two);\n  console.log(three);\n}\n\nconst person = 'Lydia';\nconst age = 21;\n\ngetPersonInfo`${person} is ${age} years old`;",
    correctAnswer: 2,
    variants: [
      '`"Lydia"` `21` `["", " is ", " years old"]`',
      '`["", " is ", " years old"]` `"Lydia"` `21`',
      '`"Lydia"` `["", " is ", " years old"]` `21`',
    ],
    explanation:
      "При использовании [шаблонных строк](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Template_literals) первым аргументом всегда будет массив строковых значений. Оставшимися аргументами будут значения переданных выражений!",
    id: 17,
  },
  {
    grade: Grades.Junior,
    theme: Themes.OBJECTS,
    question: "Что будет в консоли?",
    code: "function checkAge(data) {\n  if (data === { age: 18 }) {\n    console.log('Ты взрослый!');\n  } else if (data == { age: 18 }) {\n    console.log('Ты все еще взрослый.');\n  } else {\n    console.log(`Хмм.. Кажется, у тебя нет возраста.`);\n  }\n}\n\ncheckAge({ age: 18 });",
    correctAnswer: 3,
    variants: [
      "`Ты взрослый!`",
      "`Ты все еще взрослый.`",
      "`Хмм.. Кажется, у тебя нет возраста.`",
    ],
    explanation:
      "В операциях сравнения примитивы сравниваются по их _значениям_, а объекты по _ссылкам_. JavaScript проверяет, чтобы объекты указывали на одну и ту же область памяти.\n\nСравниваемые объекты в нашем примере не такие: объект, переданный в качестве параметра, указывает на другую область памяти, чем объекты, используемые в сравнениях.\n\nПоэтому `{ age: 18 } === { age: 18 }` и `{ age: 18 } == { age: 18 }` возвращают `false`.",
    id: 18,
  },
  {
    grade: Grades.Junior,
    theme: Themes.FUNCTIONS,
    question: "Что будет в консоли?",
    code: "function getAge(...args) {\n  console.log(typeof args);\n}\n\ngetAge(21);",
    correctAnswer: 3,
    variants: ['`"number"`', '`"array"`', '`"object"`', '`"NaN"`'],
    explanation:
      'Оператор распространения (`...args`) возвращает массив с аргументами. Массив это объект, поэтому `typeof args` возвращает `"object"`.',
    id: 19,
  },
  {
    grade: Grades.Junior,
    theme: Themes.BASICS,
    question: "Что будет в консоли?",
    code: "function getAge() {\n  'use strict';\n  age = 21;\n  console.log(age);\n}\n\ngetAge();",
    correctAnswer: 3,
    variants: ["`21`", "`undefined`", "`ReferenceError`", "`TypeError`"],
    explanation:
      'Используя `"use strict"`, можно быть уверенным, что мы по ошибке не побъявим глобальные переменные. Мы ранее нигде не объявляли переменную `age`, поэтому с использованием `"use strict"` возникнет `ReferenceError`. Без использования `"use strict"` ошибки не возникнет, а переменная `age` добавится в глобальный объект.',
    id: 20,
  },
  {
    grade: Grades.Junior,
    theme: Themes.BASICS,
    question: "Чему будет равно `sum`?",
    code: "const sum = eval('10*10+5');",
    correctAnswer: 1,
    variants: ["`105`", '`"105"`', "`TypeError`", '`"10*10+5"`'],
    explanation:
      "`eval` выполняет код, переданный в виде строки. Если это выражение (как в данном случае), то вычисляется выражение. Выражение `10 * 10 + 5` вернет число `105`.",
    id: 21,
  },
  {
    grade: Grades.Junior,
    theme: Themes.STORAGE,
    question: "Как долго будет доступен cool_secret?",
    code: "sessionStorage.setItem('cool_secret', 123);",
    correctAnswer: 2,
    variants: [
      "Всегда, данные не потеряются.",
      "Пока пользователь не закроет вкладку.",
      "Пока пользователь не закроет браузер, а не только вкладку.",
      "Пока пользователь не выключит компьютер.",
    ],
    explanation:
      "Данные, сохраненные в `sessionStorage` очищаются после закрытия _вкладки_.\n\nПри использовании `localStorage` данные сохраняются навсегда. Очистить их можно, например, используя `localStorage.clear()`.",
    id: 22,
  },
  {
    grade: Grades.Junior,
    theme: Themes.BASICS,
    question: "Что будет в консоли?",
    code: "var num = 8;\nvar num = 10;\n\nconsole.log(num);",
    correctAnswer: 2,
    variants: ["`8`", "`10`", "`SyntaxError`", "`ReferenceError`"],
    explanation:
      "С помощью ключевого слова `var` можно определять сколько угодно переменных с одним и тем же именем. Переменная будет хранить последнее присвоенное значение.\n\nНо такой трюк нельзя проделать с `let` и `const`, т.к. у них блочная область видимости.",
    id: 23,
  },
  {
    grade: Grades.Junior,
    theme: Themes.DATA_TYPES,
    question: "Каким будет результат?",
    code: "const obj = { 1: 'a', 2: 'b', 3: 'c' };\nconst set = new Set([1, 2, 3, 4, 5]);\n\nobj.hasOwnProperty('1');\nobj.hasOwnProperty(1);\nset.has('1');\nset.has(1);",
    correctAnswer: 3,
    variants: [
      "`false` `true` `false` `true`",
      "`false` `true` `true` `true`",
      "`true` `true` `false` `true`",
      "`true` `true` `true` `true`",
    ],
    explanation:
      "Все ключи объектов (кроме Symbols) являются строками, даже если заданы не в виде строк. Поэтому `obj.hasOwnProperty('1')` так же возвращает true.\n\nНо это не работает для `set`. Значения `'1'` нет в `set`: `set.has('1')` возвращает `false`. Но `set.has(1)` вернет `true`.",
    id: 24,
  },
  {
    grade: Grades.Junior,
    theme: Themes.OBJECTS,
    question: "Что будет в консоли?",
    code: "const obj = { a: 'one', b: 'two', a: 'three' };\nconsole.log(obj);",
    correctAnswer: 3,
    variants: [
      '`{ a: "one", b: "two" }`',
      '`{ b: "two", a: "three" }`',
      '`{ a: "three", b: "two" }`',
      "`SyntaxError`",
    ],
    explanation:
      "Если есть два ключа с одинаковым именем, то ключ будет перезаписан. Его позиция сохранится, но значением будет последнее указанное.",
    id: 25,
  },
  {
    grade: Grades.Junior,
    theme: Themes.OBJECTS,
    question:
      "Глобальный контекст исполнения создает две вещи: глобальный объект и `this`",
    code: null,
    correctAnswer: 1,
    variants: ["Да", "Нет", "Это зависит от ..."],
    explanation:
      "Базовый контекст исполнения это глобальный контекст исполнения: это то, что доступно где угодно в твоем коде.",
    id: 26,
  },
  {
    grade: Grades.Junior,
    theme: Themes.BASICS,
    question: "Что будет в консоли?",
    code: "for (let i = 1; i < 5; i++) {\n  if (i === 3) continue;\n  console.log(i);\n}",
    correctAnswer: 3,
    variants: ["`1` `2`", "`1` `2` `3`", "`1` `2` `4`", "`1` `3` `4`"],
    explanation:
      "Оператор `continue` пропускает итерацию, если условие возвращает `true`.",
    id: 27,
  },
  {
    grade: Grades.Junior,
    theme: Themes.CLASSES,
    question: "Каким будет результат?",
    code: "String.prototype.giveLydiaPizza = () => {\n  return 'Just give Lydia pizza already!';\n};\n\nconst name = 'Lydia';\n\nconsole.log(name.giveLydiaPizza())",
    correctAnswer: 1,
    variants: [
      '`"Just give Lydia pizza already!"`',
      "`TypeError: not a function`",
      "`SyntaxError`",
      "`undefined`",
    ],
    explanation:
      "`String` это встроенный конструктор, к которому можно добавлять свойства. Я добавила метод к его прототипу. Строки-примитивы автоматически конвертируются к строкам-объектам. Поэтому все строки (строковые объекты) имеют доступ к этому методу!",
    id: 28,
  },
  {
    grade: Grades.Middle,
    theme: Themes.DATA_TYPES,
    question: "Что будет в консоли?",
    code: "const a = {};\nconst b = { key: 'b' };\nconst c = { key: 'c' };\n\na[b] = 123;\na[c] = 456;\n\nconsole.log(a[b]);",
    correctAnswer: 2,
    variants: ["`123`", "`456`", "`undefined`", "`ReferenceError`"],
    explanation:
      'Ключи объекта автоматически конвертируются в строки. Мы собираемся добавить объект в качестве ключа к объекту `a` со значением `123`.\n\nТем не менее, когда мы приводим объект к строке, он становится `"[object Object]"`. Таким образом, мы говорим, что `a["object Object"] = 123`. Потом мы делаем то же самое. `c` это другой объект, который мы неявно приводим к строке. Поэтому `a["object Object"] = 456`.\n\nЗатем, когда мы выводим `a[b]`, мы имеем в виду `a["object Object"]`. Мы только что установили туда значение `456`, поэтому в результате получаем `456`.',
    id: 29,
  },
  {
    grade: Grades.Junior,
    theme: Themes.ASYNC,
    question: "Каким будет результат?",
    code: "const foo = () => console.log('First');\nconst bar = () => setTimeout(() => console.log('Second'));\nconst baz = () => console.log('Third');\n\nbar();\nfoo();\nbaz();",
    correctAnswer: 2,
    variants: [
      "`First` `Second` `Third`",
      "`First` `Third` `Second`",
      "`Second` `First` `Third`",
      "`Second` `Third` `First`",
    ],
    explanation:
      'Мы вызываем функцию `setTimeout` первой. Тем не менее, она выводится в консоль последней\n\nЭто происходит из-за того, что в браузерах у нас есть не только рантайм движок, но и `WebAPI`. `WebAPI` предоставляет нам функцию `setTimeout` и много других возможностей. Например, DOM.\n\nПосле того как _коллбек_ отправлен в `WebAPI`, функция `setTimeout` (но не коллбек!) вынимается из стека.\n\n![Image](https://i.imgur.com/X5wsHOg.png)\n\nТеперь вызывается `foo`, и `"First"` выводится в консоль.\n\n![Image](https://i.imgur.com/Pvc0dGq.png)\n\n`foo` достается из стека, и вызывается `baz`. `"Third"` выводится в консоль.\n\n![Image](https://i.imgur.com/WhA2bCP.png)\n\nWebAPI не может добавлять содержимое в стек когда захочет. Вместо этого он отправляет коллбек-функцию в так называемую _очередь_.\n\n![Image](https://i.imgur.com/NSnDZmU.png)\n\nЗдесь на сцену выходит цикл событий (event loop). **Event loop** проверяет стек и очередь задач. Если стек пустой, то он берет первый элемент из очереди и отправляет его в стек.\n\n![Image](https://i.imgur.com/uyiScAI.png)\n\nВызывается `bar`, в консоль выводится `"Second"` и эта функция достается из стека.',
    id: 30,
  },
  {
    grade: Grades.Junior,
    theme: Themes.EVENTS,
    question: "Что будет в event.target после клика на кнопку?",
    code: null,
    correctAnswer: 3,
    variants: [
      "Внешний `div`",
      "Внутренний `div`",
      "`button`",
      "Массив со всеми вложенными элементами",
    ],
    explanation:
      "Целью события является самый глубокий вложенный элемент. Остановить распространение событий можно с помощью `event.stopPropagation`",
    id: 31,
  },
  {
    grade: Grades.Junior,
    theme: Themes.EVENTS,
    question: "Что будет в консоли после клика по параграфу?",
    code: null,
    correctAnswer: 1,
    variants: ["`p` `div`", "`div` `p`", "`p`", "`div`"],
    explanation:
      "После клика по `p` будет выведено `p` и `div`. В цикле жизни события есть три фазы: захват, цель и всплытие. По умолчанию обработчики событий выполняются на фазе всплытия (если не установлен параметр `useCapture` в `true`). Всплытие идет с самого глубокого элемента вверх.",
    id: 32,
  },
  {
    grade: Grades.Junior,
    theme: Themes.FUNCTIONS,
    question: "Что будет в консоли?",
    code: "const person = { name: 'Lydia' };\n\nfunction sayHi(age) {\n  console.log(`${this.name} is ${age}`);\n}\n\nsayHi.call(person, 21);\nsayHi.bind(person, 21);",
    correctAnswer: 4,
    variants: [
      "`undefined is 21` `Lydia is 21`",
      "`function` `function`",
      "`Lydia is 21` `Lydia is 21`",
      "`Lydia is 21` `function`",
    ],
    explanation:
      "В обоих случаях мы передаем объект, на который будет указывать `this`. Но `.call` _выполняется сразу же_!\n\n`.bind` возвращает _копию_ функции, но с привязанным контекстом. Она не выполняется незамедлительно.",
    id: 33,
  },
  {
    grade: Grades.Junior,
    theme: Themes.FUNCTIONS,
    question: "Каким будет результат?",
    code: "function sayHi() {\n  return (() => 0)();\n}\n\nconsole.log(typeof sayHi());",
    correctAnswer: 2,
    variants: ['`"object"`', '`"number"`', '`"function"`', '`"undefined"`'],
    explanation:
      'Функция `sayHi` возвращает значение, возвращаемое из немедленно вызываемого функционального выражения (IIFE). Результатом является `0` типа `"number"`.\n\nДля информации: в JS 8 встроенных типов: `null`, `undefined`, `boolean`, `number`, `string`, `object`, `symbol` и `bigint`. `"function"` не является отдельным типом, т.к. функции являются объектами типа `"object"`.',
    id: 34,
  },
  {
    grade: Grades.Middle,
    theme: Themes.BASICS,
    question: 'Какие из этих значений являются "ложными"?',
    code: '0;\nnew Number(0);\n("");\n(" ");\nnew Boolean(false);\nundefined;',
    correctAnswer: 1,
    variants: [
      "`0`, `''`, `undefined`",
      "`0`, `new Number(0)`, `''`, `new Boolean(false)`, `undefined`",
      "`0`, `''`, `new Boolean(false)`, `undefined`",
      'Все являются "ложными"',
    ],
    explanation:
      'Есть только восемь (8) "ложных" значений:\n\n- `undefined`\n- `null`\n- `NaN`\n- `false`\n- `\'\'` (пустая строка)\n- `0`\n- `-0`\n- `0n` (BigInt(0))\n\nКонструкторы функций, такие как `new Number` и `new Boolean` являются "истинными".',
    id: 35,
  },
  {
    grade: Grades.Junior,
    theme: Themes.DATA_TYPES,
    question: "Что будет в консоли",
    code: "console.log(typeof typeof 1);",
    correctAnswer: 2,
    variants: ['`"number"`', '`"string"`', '`"object"`', '`"undefined"`'],
    explanation:
      '`typeof 1` возвращает `"number"`.\n`typeof "number"` возвращает `"string"`',
    id: 36,
  },
  {
    grade: Grades.Junior,
    theme: Themes.BASICS,
    question: "Что будет в консоли?",
    code: "const numbers = [1, 2, 3];\nnumbers[10] = 11;\nconsole.log(numbers);",
    correctAnswer: 3,
    variants: [
      "`[1, 2, 3, 7 x null, 11]`",
      "`[1, 2, 3, 11]`",
      "`[1, 2, 3, 7 x empty, 11]`",
      "`SyntaxError`",
    ],
    explanation:
      'Когда в массив добавляется значение, которое выходит за пределы длины массива, JavaScript создает так называемые "пустые ячейки". На самом деле они имеют значения `undefined`, но в консоли выводятся так:\n\n`[1, 2, 3, 7 x empty, 11]`\n\nв зависимости от окружения (может отличаться для браузеров, Node, и т.д.).',
    id: 37,
  },
  {
    grade: Grades.Middle,
    theme: Themes.FUNCTIONS,
    question: "Что будет в консоли?",
    code: "(() => {\n  let x, y;\n  try {\n    throw new Error();\n  } catch (x) {\n    (x = 1), (y = 2);\n    console.log(x);\n  }\n  console.log(x);\n  console.log(y);\n})();",
    correctAnswer: 1,
    variants: [
      "`1` `undefined` `2`",
      "`undefined` `undefined` `undefined`",
      "`1` `1` `2`",
      "`1` `undefined` `undefined`",
    ],
    explanation:
      "Блок `catch` получает аргумент `x`. Это не тот же `x`, который определен в качестве переменной перед строкой `try {`\n\nЗатем мы присваиваем этому аргументу значение `1` и устанавливаем значение для переменной `y`. Потом выводим в консоль значение аргумента `x`, которое равно `1`.\n\nЗа пределами блока `catch` переменная `x` все еще `undefined`, а `y` равно `2`. Когда мы вызываем `console.log(x)` за пределами блока `catch`, этот вызов возвращает `undefined`, а `y` возвращает `2`.",
    id: 38,
  },
  {
    grade: Grades.Junior,
    theme: Themes.DATA_TYPES,
    question: "Всё в JavaScript это...",
    code: null,
    correctAnswer: 1,
    variants: [
      "примитив или объект",
      "функция или объект",
      "вопрос с подвохом! только объекты",
      "число или объект",
    ],
    explanation:
      "В JavaScript есть только примитивы и объекты.\n\nТипы примитивов: `boolean`, `null`, `undefined`, `bigint`, `number`, `string`, и `symbol`.\n\nОтличием примитива от объекта является то, что примитивы не имеют свойств или методов. Тем не менее, `'foo'.toUpperCase()` преобразуется в `'FOO'` и не вызывает `TypeError`. Это происходит потому, что при попытке получения свойства или метода у примитива (например, строки), JavaScript неявно обернет примитив объектом, используя один из классов-оберток (например, `String`), а затем сразу же уничтожит обертку после вычисления выражения. Все примитивы кроме `null` и `undefined` ведут себя таким образом.",
    id: 39,
  },
  {
    grade: Grades.Junior,
    theme: Themes.BASICS,
    question: "Каким будет результат?",
    code: "[[0, 1], [2, 3]].reduce(\n  (acc, cur) => {\n    return acc.concat(cur);\n  },\n  [1, 2]\n);",
    correctAnswer: 3,
    variants: [
      "`[0, 1, 2, 3, 1, 2]`",
      "`[6, 1, 2]`",
      "`[1, 2, 0, 1, 2, 3]`",
      "`[1, 2, 6]`",
    ],
    explanation:
      "`[1, 2]` - начальное значение, с которым инициализируется переменная `acc`. После первого прохода `acc` будет равно `[1,2]`, а `cur` будет `[0,1]`. После конкатенации результат будет `[1, 2, 0, 1]`.\n\nЗатем `acc` равно `[1, 2, 0, 1]`, а `cur` равно `[2, 3]`. После слияния получим `[1, 2, 0, 1, 2, 3]`.",
    id: 40,
  },
  {
    grade: Grades.Junior,
    theme: Themes.BASICS,
    question: "Каким будет результат?",
    code: "!!null;\n!!'';\n!!1;",
    correctAnswer: 2,
    variants: [
      "`false` `true` `false`",
      "`false` `false` `true`",
      "`false` `true` `true`",
      "`true` `true` `false`",
    ],
    explanation:
      '`null` - "ложный". `!null` возвращает `true`. `!true` возвращает `false`.\n\n`""` - "ложный". `!""` возвращает `true`. `!true` возвращает `false`.\n\n`1` - "истинный". `!1` возвращает `false`. `!false` возвращает `true`.',
    id: 41,
  },
  {
    grade: Grades.Junior,
    theme: Themes.FUNCTIONS,
    question: "Что возвращает метод `setInterval` в браузере?",
    code: "setInterval(() => console.log('Hi'), 1000);",
    correctAnswer: 1,
    variants: [
      "уникальный id",
      "указанное количество миллисекунд",
      "переданную функцию",
      "`undefined`",
    ],
    explanation:
      "Это метод возвращает уникальный id. Этот id может быть использован для очищения интервала с помощью функции `clearInterval()`.",
    id: 42,
  },
  {
    grade: Grades.Junior,
    theme: Themes.DATA_TYPES,
    question: "Каким будет результат?",
    code: "[...'Lydia'];",
    correctAnswer: 1,
    variants: [
      '`["L", "y", "d", "i", "a"]`',
      '`["Lydia"]`',
      '`[[], "Lydia"]`',
      '`[["L", "y", "d", "i", "a"]]`',
    ],
    explanation:
      "Строка является итерируемой сущностью. Оператор распространения преобразовывает каждый символ в отдельный элемент.",
    id: 43,
  },
  {
    grade: Grades.Junior,
    theme: Themes.ASYNC,
    question: "Каким будет результат?",
    code: "function* generator(i) {\n  yield i;\n  yield i * 2;\n}\n\nconst gen = generator(10);\n\nconsole.log(gen.next().value);\nconsole.log(gen.next().value);",
    correctAnswer: 3,
    variants: [
      "`[0, 10], [10, 20]`",
      "`20, 20`",
      "`10, 20`",
      "`0, 10 and 10, 20`",
    ],
    explanation:
      'Обычные функции не могут быть остановлены на полпути после вызова. Однако функцию генератор можно "остановить" на полпути, а затем продолжить с того места, где она остановилась. Каждый раз, когда в функции-генераторе встречает ключевое слово `yield`, функция возвращает значение, указанное после него. Обратите внимание, что функция генератора в этом случае не _return_ значение, оно _yields_ значение.\n\nСначала мы инициализируем функцию генератор с `i`, равным `10`. Мы вызываем функцию генератор, используя метод `next ()`. Когда мы в первый раз вызываем функцию генератора, `i` равно `10`. Он встречает первое ключевое слово `yield`, получая значение `i`. Генератор теперь "приостановлен", и `10` выводится в консоль.\n\nЗатем мы снова вызываем функцию с помощью метода `next ()`. Она запускается с того места, где остановилась ранее, все еще с `i`, равным `10`. Теперь он встречает следующее ключевое слово `yield` и возвращает `i * 2`. `i` равно `10`, поэтому он возвращает `10 * 2`, то есть `20`. Это приводит к 10, 20.',
    id: 44,
  },
  {
    grade: Grades.Junior,
    theme: Themes.FUNCTIONS,
    question: "Каким будет результат?",
    code: "const firstPromise = new Promise((res, rej) => {\n  setTimeout(res, 500, 'один');\n});\n\nconst secondPromise = new Promise((res, rej) => {\n  setTimeout(res, 100, 'два');\n});\n\nPromise.race([firstPromise, secondPromise]).then(res => console.log(res));",
    correctAnswer: 2,
    variants: ['`"один"`', '`"два"`', '`"два" "один"`', '`"один" "два"`'],
    explanation:
      "Когда мы передаем несколько промисов методу `Promise.race`, он разрешает/отклоняет _первый_ промис, который разрешается/отклоняется. В метод `setTimeout` мы передаем таймер: 500 мс для первого промиса (`firstPromise`) и 100 мс для второго промиса (`secondPromise`). Это означает, что `secondPromise` разрешается первым со значением `'два'`. `res` теперь содержит значение `'два'`, которое выводиться в консоль.",
    id: 45,
  },
  {
    grade: Grades.Junior,
    theme: Themes.OBJECTS,
    question: "Каким будет результат?",
    code: "let person = { name: 'Lydia' };\nconst members = [person];\nperson = null;\n\nconsole.log(members);",
    correctAnswer: 4,
    variants: ["`null`", "`[null]`", "`[{}]`", '`[{ name: "Lydia" }]`'],
    explanation:
      "Сначала мы объявляем переменную `person` со значением объекта, у которого есть свойство` name`.\n\n![Image](https://i.imgur.com/TML1MbS.png)\n\nЗатем мы объявляем переменную с именем `members`. Мы устанавливаем первый элемент этого массива равным значению переменной `person`. Объекты взаимодействуют посредством _ссылок_ при установке их равными друг другу. Когда вы назначаете ссылку из одной переменной в другую, вы создаете _копию_ этой ссылки. (обратите внимание, что у них _не одинаковые_ ссылки!)\n\n![Image](https://i.imgur.com/FSG5K3F.png)\n\nЗатем мы присваиваем переменной `person` значение `null`.\n\n![Image](https://i.imgur.com/sYjcsMT.png)\n\nМы изменили только значение переменной `person`, а не первый элемент в массиве, поскольку этот элемент имеет другую (скопированную) ссылку на объект. Первый элемент в `members` по-прежнему содержит ссылку на исходный объект. Когда мы выводим в консоль массив `members`, первый элемент по-прежнему содержит значение объекта, который выводится в консоль.",
    id: 46,
  },
  {
    grade: Grades.Junior,
    theme: Themes.DATA_TYPES,
    question: "Каким будет результат?",
    code: "const person = {\n  name: 'Lydia',\n  age: 21\n};\n\nfor (const item in person) {\n  console.log(item);\n}",
    correctAnswer: 2,
    variants: [
      '`{ name: "Lydia" }, { age: 21 }`',
      '`"name", "age"`',
      '`"Lydia", 21`',
      '`["name", "Lydia"], ["age", 21]`',
    ],
    explanation:
      "С помощью цикла `for-in` мы можем перебирать ключи объекта, в данном случае `name` и `age`. Под капотом ключи объекта являются строками (если они не являются Symbol). В каждом цикле мы устанавливаем значение `item` равным текущему ключу, по которому он перебирается. Сначала, `item` равен `name`, и выводится в консоль. Затем `item` равен `age`, который выводится в консоль.",
    id: 47,
  },
  {
    grade: Grades.Junior,
    theme: Themes.BASICS,
    question: "Каким будет результат?",
    code: "console.log(3 + 4 + '5');",
    correctAnswer: 2,
    variants: ['`"345"`', '`"75"`', "`12`", '`"12"`'],
    explanation:
      'Ассоциативность операторов - это порядок, в котором компилятор оценивает выражения, слева направо или справа налево. Это происходит только в том случае, если все операторы имеют _одинаковый_ приоритет. У нас есть только один тип оператора: `+`. Кроме того, ассоциативность слева направо.\n\n`3 + 4` оценивается первым. Это приводит к числу `7`.\n\n`7 + \'5\'` приводит к `"75"` из-за принуждения. JavaScript преобразует число `7` в строку, см. вопрос 15. Мы можем объединить две строки, используя оператор `+`. `"7" + "5"` приводит к `"75"`.',
    id: 48,
  },
  {
    grade: Grades.Junior,
    theme: Themes.DATA_TYPES,
    question: "Какое значение `num`?",
    code: 'const num = parseInt("7*6", 10);',
    correctAnswer: 3,
    variants: ["`42`", '`"42"`', "`7`", "`NaN`"],
    explanation:
      'Только первые числа в строке возвращаются. На основе _системы счисления_ (второй аргумент, чтобы указать, к какому типу чисел мы хотим его анализировать: основание 10, шестнадцатеричное, восьмеричное, двоичное и т.д.), `ParseInt` проверяет, являются ли символы в строке допустимыми. Как только он встречает символ, который не является допустимым числом в основании, он прекращает синтаксический анализ и игнорирует следующие символы.\n\n`*` не является допустимым числом. Он только разбирает `"7"` в десятичную `7`. `num` теперь содержит значение` 7`.',
    id: 49,
  },
  {
    grade: Grades.Junior,
    theme: Themes.DATA_TYPES,
    question: "Каким будет результат?",
    code: "[1, 2, 3].map(num => {\n  if (typeof num === 'number') return;\n  return num * 2;\n});",
    correctAnswer: 3,
    variants: [
      "`[]`",
      "`[null, null, null]`",
      "`[undefined, undefined, undefined]`",
      "`[ 3 x empty ]`",
    ],
    explanation:
      'При использовании метода map, значение `num` равно элементу, над которым он в данный момент зацикливается. В этом случае элементы являются числами, поэтому условие оператора if `typeof num === "number"` возвращает `true`. Функция map создает новый массив и вставляет значения, возвращаемые функцией.\n\nОднако мы не возвращаем значение. Когда мы не возвращаем значение из функции, функция возвращает значение `undefined`. Для каждого элемента в массиве вызывается функциональный блок, поэтому для каждого элемента мы возвращаем `undefined`.',
    id: 50,
  },
  {
    grade: Grades.Junior,
    theme: Themes.OBJECTS,
    question: "Каким будет результат?",
    code: "function getInfo(member, year) {\n  member.name = 'Lydia';\n  year = 1998;\n}\n\nconst person = { name: 'Sarah' };\nconst birthYear = '1997';\n\ngetInfo(person, birthYear);\n\nconsole.log(person, birthYear);",
    correctAnswer: 1,
    variants: [
      '`{ name: "Lydia" }, "1997"`',
      '`{ name: "Sarah" }, "1998"`',
      '`{ name: "Lydia" }, "1998"`',
      '`{ name: "Sarah" }, "1997"`',
    ],
    explanation:
      'Аргументы передаются _значением_, если их значение не является объектом, то они передаются _ссылкой_. `birthYear` передается по значению, поскольку это строка, а не объект. Когда мы передаем аргументы по значению, создается _копия_ этого значения (см. вопрос 46).\n\nПеременная `birthYear` имеет ссылку на значение `"1997"`. Аргумент `year` также имеет ссылку на значение` "1997" `, но это не то же самое значение, на которое имеется ссылка для `birthYear`. Когда мы обновляем значение `year`, устанавливая `year` равным `"1998"`, мы обновляем только значение `year`. `birthYear` по-прежнему равно `"1997"`.\n\nЗначение `person` является объектом. Аргумент `member` имеет (скопированную) ссылку на _тот же_ объект. Когда мы изменяем свойство объекта, на который `member` ссылается, значение `person` также будет изменено, поскольку они оба имеют ссылку на один и тот же объект. Свойство `name` объекта `person` теперь равно значению `"Lydia"`.',
    id: 51,
  },
  {
    grade: Grades.Junior,
    theme: Themes.ERRORS,
    question: "Каким будет результат?",
    code: "function greeting() {\n  throw 'Hello world!';\n}\n\nfunction sayHi() {\n  try {\n    const data = greeting();\n    console.log('It worked!', data);\n  } catch (e) {\n    console.log('Oh no an error:', e);\n  }\n}\n\nsayHi();",
    correctAnswer: 4,
    variants: [
      "`It worked! Hello world!`",
      "`Oh no an error: undefined`",
      "`SyntaxError: can only throw Error objects`",
      "`Oh no an error: Hello world!`",
    ],
    explanation:
      "С помощью оператора `throw` мы можем создавать собственные ошибки. С этим оператором вы можете генерировать исключения. Исключением может быть <b>строка</b>, <b>число</b>, <b>логическое значение</b> или <b>объект</b>. В этом случае нашим исключением является строка `'Hello world'`.\n\nС помощью оператора `catch` мы можем указать, что делать, если в блоке` try` выдается исключение. Исключение: строка `'Hello world'`. `e` теперь равно той строке, которую мы записываем. Это приводит к `'Oh no an error: Hello world'`.",
    id: 52,
  },
  {
    grade: Grades.Junior,
    theme: Themes.FUNCTIONS,
    question: "Каким будет результат?",
    code: "function Car() {\n  this.make = 'Lamborghini';\n  return { make: 'Maserati' };\n}\n\nconst myCar = new Car();\nconsole.log(myCar.make);",
    correctAnswer: 2,
    variants: [
      '`"Lamborghini"`',
      '`"Maserati"`',
      "`ReferenceError`",
      "`TypeError`",
    ],
    explanation:
      'Когда вы возвращаете свойство, значение свойства равно _возвращаемому_ значению, а не значению, установленному в функции конструктора. Мы возвращаем строку `"Maserati"`, поэтому `myCar.make` равно `"Maserati"`.',
    id: 53,
  },
  {
    grade: Grades.Senior,
    theme: Themes.OBJECTS,
    question: "Каким будет результат?",
    code: "(() => {\n  let x = (y = 10);\n})();\n\nconsole.log(typeof x);\nconsole.log(typeof y);",
    correctAnswer: 1,
    variants: [
      '`"undefined", "number"`',
      '`"number", "number"`',
      '`"object", "number"`',
      '`"number", "undefined"`',
    ],
    explanation:
      '`let x = y = 10;` на самом деле является сокращением для:\n\n``` js\ny = 10;\nlet x = y;\n```\n\nКогда мы устанавливаем `y` равным` 10`, мы фактически добавляем свойство `y` к глобальному объекту (`window` в браузере, `global` в Node). В браузере `window.y` теперь равен` 10`.\n\nЗатем мы объявляем переменную `x` со значением `y`, которое равно `10`. Переменные, объявленные с ключевым словом `let`, имеют _блочную видимость_, они определены только в блоке, в котором они объявлены; немедленно вызванная функция (IIFE) в этом случае. Когда мы используем оператор `typeof`, операнд `x` не определен: мы пытаемся получить доступ к `x` вне блока, в котором он объявлен. Это означает, что `x` не определен. Значения, которым не присвоено или не объявлено значение, имеют тип `"undefined"`. `console.log(typeof x)` возвращает `"undefined"`.\n\nОднако мы создали глобальную переменную `y`, установив `y` равным `10`. Это значение доступно в любом месте нашего кода. `y` определен и содержит значение типа `"number"`. `console.log(typeof y)` возвращает `"number"`.',
    id: 54,
  },
  {
    grade: Grades.Middle,
    theme: Themes.CLASSES,
    question: "Какой будет вывод?",
    code: "class Dog {\n  constructor(name) {\n    this.name = name;\n  }\n}\n\nDog.prototype.bark = function() {\n  console.log(`Woof I am ${this.name}`);\n};\n\nconst pet = new Dog('Mara');\n\npet.bark();\n\ndelete Dog.prototype.bark;\n\npet.bark();",
    correctAnswer: 1,
    variants: [
      '`"Woof I am Mara"`, `TypeError`',
      '`"Woof I am Mara"`, `"Woof I am Mara"`',
      '`"Woof I am Mara"`, `undefined`',
      "`TypeError`, `TypeError`",
    ],
    explanation:
      "Мы можем удалить свойства из объектов, используя ключевое слово `delete`, также в прототипе. Удаляя свойство в прототипе, оно больше не доступно в цепочке прототипов. В этом случае функция `bark` больше не доступна в прототипе после`delete Dog.prototype.bark`, но мы все еще пытаемся получить к ней доступ.\n\nКогда мы пытаемся вызвать что-то, что не является функцией, выдается `TypeError`. В этом случае `TypeError: pet.bark не является функцией`, поскольку` pet.bark` является `undefined`.",
    id: 55,
  },
  {
    grade: Grades.Junior,
    theme: Themes.DATA_TYPES,
    question: "Какой будет вывод?",
    code: "const set = new Set([1, 1, 2, 3, 4]);\n\nconsole.log(set);",
    correctAnswer: 4,
    variants: [
      "`[1, 1, 2, 3, 4]`",
      "`[1, 2, 3, 4]`",
      "`{1, 1, 2, 3, 4}`",
      "`{1, 2, 3, 4}`",
    ],
    explanation:
      "Объект `Set` является коллекцией _unique_ значений: значение может появляться только один раз в наборе.\n\nМы передали последовательность `[1, 1, 2, 3, 4]` с повторяющимся значением `1`. Поскольку в наборе не может быть двух одинаковых значений, одно из них удаляется. Это приводит к `{1, 2, 3, 4}`.",
    id: 56,
  },
  {
    grade: Grades.Middle,
    theme: Themes.MODULES,
    question: "Какой будет вывод?",
    code: "// counter.js\nlet counter = 10;\nexport default counter;",
    correctAnswer: 3,
    variants: ["`10`", "`11`", "`Error`", "`NaN`"],
    explanation:
      "Импортированный модуль является _read-only_: вы не можете изменить импортированный модуль. Только модуль, который их экспортирует, может изменить его значение.\n\nКогда мы пытаемся увеличить значение `myCounter`, выдается ошибка: `myCounter` доступен только для чтения и не может быть изменен.",
    id: 57,
  },
  {
    grade: Grades.Junior,
    theme: Themes.OBJECTS,
    question: "Какой будет вывод?",
    code: "const name = 'Lydia';\nage = 21;\n\nconsole.log(delete name);\nconsole.log(delete age);",
    correctAnswer: 1,
    variants: [
      "`false`, `true`",
      '`"Lydia"`, `21`',
      "`true`, `true`",
      "`undefined`, `undefined`",
    ],
    explanation:
      "Оператор `delete` возвращает логическое значение: `true` при успешном удалении, иначе он вернет `false`. Однако переменные, объявленные с ключевым словом `var`,` const` или `let`, не могут быть удалены с помощью оператора` delete`.\n\nПеременная `name` была объявлена ​​с ключевым словом `const`, поэтому ее удаление не было успешным: возвращается `false`. Когда мы устанавливаем `age` равным `21`, мы фактически добавляем свойство с именем `age` к глобальному объекту. Вы можете успешно удалить свойства из объектов, в том числе из глобального объекта, поэтому `delete age` возвращает `true`.",
    id: 58,
  },
  {
    grade: Grades.Junior,
    theme: Themes.BASICS,
    question: "Какой будет вывод?",
    code: "const numbers = [1, 2, 3, 4, 5];\nconst [y] = numbers;\n\nconsole.log(y);",
    correctAnswer: 3,
    variants: ["`[[1, 2, 3, 4, 5]]`", "`[1, 2, 3, 4, 5]`", "`1`", "`[1]`"],
    explanation:
      "Мы можем распаковать значения из массивов или свойств из объектов путем деструктуризации. Например:\n\n``` js\n[a, b] = [1, 2];\n```\n\n![Image](https://i.imgur.com/ADFpVop.png)\n\nЗначение `a` теперь равно `1`, а значение `b` теперь равно `2`. Что мы на самом деле сделали в этом вопросе, так это:\n\n``` js\n[y] = [1, 2, 3, 4, 5];\n```\n\n![Image](https://i.imgur.com/NzGkMNk.png)\n\nЭто означает, что значение `y` равно первому значению в массиве, которое является числом` 1`. Когда мы регистрируем `y`, возвращается `1`.",
    id: 59,
  },
  {
    grade: Grades.Junior,
    theme: Themes.DATA_TYPES,
    question: "Какой будет вывод?",
    code: "const user = { name: 'Lydia', age: 21 };\nconst admin = { admin: true, ...user };\n\nconsole.log(admin);",
    correctAnswer: 2,
    variants: [
      '`{ admin: true, user: { name: "Lydia", age: 21 } }`',
      '`{ admin: true, name: "Lydia", age: 21 }`',
      '`{ admin: true, user: ["Lydia", 21] }`',
      "`{ admin: true }`",
    ],
    explanation:
      'Можно комбинировать объекты с помощью оператора распространения `...`. Это позволяет создавать копии пар ключ/значение одного объекта и добавлять их в другой объект. В этом случае мы создаем копии объекта `user` и добавляем их в объект `admin`. Объект `admin` теперь содержит скопированные пары ключ/значение, что приводит к `{admin: true, name: "Lydia", age: 21}`.',
    id: 60,
  },
  {
    grade: Grades.Junior,
    theme: Themes.OBJECTS,
    question: "Какой будет вывод?",
    code: "const person = { name: 'Lydia' };\n\nObject.defineProperty(person, 'age', { value: 21 });\n\nconsole.log(person);\nconsole.log(Object.keys(person));",
    correctAnswer: 2,
    variants: [
      '`{ name: "Lydia", age: 21 }`, `["name", "age"]`',
      '`{ name: "Lydia", age: 21 }`, `["name"]`',
      '`{ name: "Lydia"}`, `["name", "age"]`',
      '`{ name: "Lydia"}`, `["age"]`',
    ],
    explanation:
      'С помощью метода `defineProperty` мы можем добавлять новые свойства к объекту или изменять существующие. Когда мы добавляем свойство к объекту с помощью метода `defineProperty`, они по умолчанию _не перечисляемые_. Метод `Object.keys` возвращает все имена _enumerable_ свойств объекта, в данном случае только `"name"`.\n\nСвойства, добавленные с помощью метода `defineProperty`, по умолчанию неизменны. Вы можете переопределить это поведение, используя свойства `writable`, `configurable` и `enumerable`. Таким образом, метод `defineProperty` дает вам гораздо больший контроль над свойствами, которые вы добавляете к объекту.',
    id: 61,
  },
  {
    grade: Grades.Junior,
    theme: Themes.DATA_TYPES,
    question: "Какой будет вывод?",
    code: "const settings = {\n  username: 'lydiahallie',\n  level: 19,\n  health: 90\n};\n\nconst data = JSON.stringify(settings, ['level', 'health']);\nconsole.log(data);",
    correctAnswer: 1,
    variants: [
      '`"{"level":19, "health":90}"`',
      '`"{"username": "lydiahallie"}"`',
      '`"["level", "health"]"`',
      '`"{"username": "lydiahallie", "level":19, "health":90}"`',
    ],
    explanation:
      'Второй аргумент `JSON.stringify` - это _replacer_. Заменитель может быть либо функцией, либо массивом, и позволяет вам контролировать, что и как должны быть преобразованы в значения.\n\nЕсли заменитель является _массивом_, только свойства, имена которых включены в массив, будут добавлены в строку JSON. В этом случае включаются только свойства с именами `"level"` и `"health"`, `"username"` исключается. `data` теперь равен `"{"level":19, "health":90}"`.\n\nЕсли заменитель является _function_, эта функция вызывается для каждого свойства объекта, который вы преобразуете. Значение, возвращаемое из этой функции, будет значением свойства при добавлении в строку JSON. Если значение равно undefined, это свойство исключается из строки JSON.',
    id: 62,
  },
  {
    grade: Grades.Middle,
    theme: Themes.FUNCTIONS,
    question: "Какой будет вывод?",
    code: "let num = 10;\n\nconst increaseNumber = () => num++;\nconst increasePassedNumber = number => number++;\n\nconst num1 = increaseNumber();\nconst num2 = increasePassedNumber(num1);\n\nconsole.log(num1);\nconsole.log(num2);",
    correctAnswer: 1,
    variants: ["`10`, `10`", "`10`, `11`", "`11`, `11`", "`11`, `12`"],
    explanation:
      "Унарный оператор `++` _сначала возвращает_ значение операнда, _затем приращивает_ значение операнда. Значение `num1` равно `10`, так как функция увеличений вначале возвращает значение `num`, которое равно `10`, и только затем увеличивает значение `num`.\n\n`num2` - это `10`, так как мы передали `num1` в `incpasePassedNumber`. `number` равно `10` (значение `num1`. Опять же, унарный оператор `++` _сначала возвращает_ значение операнда, _затем увеличивает_ значение операнда. Значение `number` равно `10`, поэтому `num2` равно `10`.",
    id: 63,
  },
  {
    grade: Grades.Junior,
    theme: Themes.DATA_TYPES,
    question: "Какой будет вывод?",
    code: "const value = { number: 10 };\n\nconst multiply = (x = { ...value }) => {\n  console.log((x.number *= 2));\n};\n\nmultiply();\nmultiply();\nmultiply(value);\nmultiply(value);",
    correctAnswer: 3,
    variants: [
      "`20`, `40`, `80`, `160`",
      "`20`, `40`, `20`, `40`",
      "`20`, `20`, `20`, `40`",
      "`NaN`, `NaN`, `20`, `40`",
    ],
    explanation:
      'В ES6 мы можем инициализировать параметры значением по умолчанию. Значением параметра будет значение по умолчанию, если никакое другое значение не было передано функции, или если значение параметра равно `"undefined"`. В этом случае мы распространяем свойства объекта `value` на новый объект, поэтому значение `x` по умолчанию равно `{number: 10}`.\n\nАргумент по умолчанию реализуется в момент _call time_! Каждый раз, когда мы вызываем функцию, создается _new_ объект. Мы вызываем функцию `multiply` первые два раза, не передавая значение: `x` имеет значение по умолчанию `{number: 10}`. Затем мы записываем умноженное значение этого числа, которое равно `20`.\n\nВ третий раз, когда мы вызываем multiply, мы передаем аргумент: объект с именем `value`. Оператор `*=` на самом деле является сокращением для `x.number = x.number * 2`: мы изменяем значение `x.number` и записываем умноженное значение `20`.\n\nВ четвертый раз мы снова передаем объект `value`. `x.number` ранее был изменен на `20`, поэтому `x.number * = 2` записывает `40`.',
    id: 64,
  },
  {
    grade: Grades.Middle,
    theme: Themes.DATA_TYPES,
    question: "Какой будет вывод?",
    code: "[1, 2, 3, 4].reduce((x, y) => console.log(x, y));",
    correctAnswer: 4,
    variants: [
      "`1` `2`, `3` `3` и `6` `4`",
      "`1` `2`, `2` `3` и `3` `4`",
      "`1` `undefined`, `2` `undefined`, `3` `undefined` и `4` `undefined`",
      "`1` `2`, `undefined` `3` и `undefined` `4`",
    ],
    explanation:
      "Первым аргументом, который получает метод `reduce`, является _аккумулятором_, в данном случае `x`. Второй аргумент - это _текущее значение_, `y`. С помощью метода `reduce` мы выполняем функцию обратного вызова для каждого элемента в массиве, что в конечном итоге может привести к единственному значению.\n\nВ этом примере мы не возвращаем никаких значений, мы просто регистрируем значения аккумулятора и текущее значение.\n\nЗначение аккумулятора равно ранее возвращенному значению функции обратного вызова. Если вы не передадите необязательный аргумент `initialValue` методу `reduce`, аккумулятор будет равен первому элементу при первом вызове.\n\nПри первом вызове аккумулятор (`x`) равен `1`, а текущее значение (`y`) равно `2`. Мы не возвращаемся из функции обратного вызова, мы регистрируем аккумулятор и текущее значение: `1` и `2` регистрируются.\n\nЕсли вы не возвращаете значение из функции, она возвращает значение `undefined`. При следующем вызове аккумулятор равен `undefined`, а текущее значение равно 3. `undefined` и `3` будут зарегистрированы.\n\nПри четвертом вызове мы снова не возвращаемся из функции обратного вызова. Аккумулятор снова равен `undefined`, а текущее значение равно `4`. `undefined` и` 4` будут зарегистрированы.",
    id: 65,
  },
  {
    grade: Grades.Junior,
    theme: Themes.CLASSES,
    question:
      "С помощью какого конструктора мы можем успешно расширить класс `Dog`?",
    code: "class Dog {\n  constructor(name) {\n    this.name = name;\n  }\n};\n\nclass Labrador extends Dog {\n  // 1\n  constructor(name, size) {\n    this.size = size;\n  }\n  // 2\n  constructor(name, size) {\n    super(name);\n    this.size = size;\n  }\n  // 3\n  constructor(size) {\n    super(name);\n    this.size = size;\n  }\n  // 4\n  constructor(name, size) {\n    this.name = name;\n    this.size = size;\n  }\n\n};",
    correctAnswer: 2,
    variants: ["1", "2", "3", "4"],
    explanation:
      "В производном классе вы не можете получить доступ к ключевому слову `this` до вызова `super`. Если вы попытаетесь это сделать, он выдаст ReferenceError: 1 и 4 приведут к ошибке ссылки.\n\nС ключевым словом `super` мы вызываем конструктор родительского класса с заданными аргументами. Конструктор родителя получает аргумент `name`, поэтому нам нужно передать `name` в `super`.\n\nКласс `Labrador` получает два аргумента: `name`, поскольку он расширяет `Dog`, и `size` в качестве дополнительного свойства класса `Labrador`. Они оба должны быть переданы в функцию конструктора в `Labrador`, что делается правильно с помощью конструктора 2.",
    id: 66,
  },
  {
    grade: Grades.Middle,
    theme: Themes.MODULES,
    question: "Какой будет вывод?",
    code: "// index.js\nconsole.log('running index.js');\nimport { sum } from './sum.js';\nconsole.log(sum(1, 2));\n\n// sum.js\nconsole.log('running sum.js');\nexport const sum = (a, b) => a + b;",
    correctAnswer: 2,
    variants: [
      "`running index.js`, `running sum.js`, `3`",
      "`running sum.js`, `running index.js`, `3`",
      "`running sum.js`, `3`, `running index.js`",
      "`running index.js`, `undefined`, `running sum.js`",
    ],
    explanation:
      "С ключевым словом `import` все импортируемые модули являются _pre-parsed_. Это означает, что импортированные модули запускаются _первыми_, код в файле, который импортирует модуль, исполняется _после_.\n\nВ этом разница между `require()` в CommonJS и `import`! С помощью `require()` вы можете загружать зависимости по требованию во время выполнения кода. Если бы мы использовали `require` вместо `import`, в консоль были бы записаны `running index.js`, `running sum.js`, `3`.",
    id: 67,
  },
  {
    grade: Grades.Middle,
    theme: Themes.DATA_TYPES,
    question: "Какой будет вывод?",
    code: "console.log(Number(2) === Number(2))\nconsole.log(Boolean(false) === Boolean(false))\nconsole.log(Symbol('foo') === Symbol('foo'))",
    correctAnswer: 1,
    variants: [
      "`true`, `true`, `false`",
      "`false`, `true`, `false`",
      "`true`, `false`, `true`",
      "`true`, `true`, `true`",
    ],
    explanation:
      "Каждый `Symbol` совершенно уникален. Цель аргумента, переданного `Symbol`, состоит в том, чтобы дать `Symbol` описание. Значение `Symbol` не зависит от переданного аргумента. Когда мы проверяем равенство, мы создаем два совершенно новых `Symbol`: первый `Symbol('foo')` и второй `Symbol('foo')`. Эти два значения уникальны и не равны друг другу, `Symbol('foo') === Symbol('foo')` возвращает `false`.",
    id: 68,
  },
  {
    grade: Grades.Junior,
    theme: Themes.BASICS,
    question: "Какой будет вывод?",
    code: "const name = 'Lydia Hallie'\nconsole.log(name.padStart(13))\nconsole.log(name.padStart(2))",
    correctAnswer: 3,
    variants: [
      '`"Lydia Hallie"`, `"Lydia Hallie"`',
      '`"           Lydia Hallie"`, `"  Lydia Hallie"` (`"[13x whitespace]Lydia Hallie"`, `"[2x whitespace]Lydia Hallie"`)',
      '`" Lydia Hallie"`, `"Lydia Hallie"` (`"[1x whitespace]Lydia Hallie"`, `"Lydia Hallie"`)',
      '`"Lydia Hallie"`, `"Lyd"`,',
    ],
    explanation:
      'С помощью метода `padStart` мы можем добавить отступ в начало строки. Значение, передаваемое этому методу, представляет собой _общую_ длину строки вместе с отступом. Строка `"Lydia Hallie"` имеет длину `12`. `name.padStart(13)` вставляет 1 пробел в начале строки, потому что 12 + 1 равно 13.\n\nЕсли аргумент, переданный методу `padStart`, меньше длины строки, заполнение не будет добавлено.',
    id: 69,
  },
  {
    grade: Grades.Junior,
    theme: Themes.DATA_TYPES,
    question: "Какой будет вывод?",
    code: 'console.log("🥑" + "💻");',
    correctAnswer: 1,
    variants: [
      '`"🥑💻"`',
      "`257548`",
      "Строка, содержащая кодовые обозначения",
      "Error",
    ],
    explanation:
      'С помощью оператора `+` вы можете объединять строки. В этом случае мы объединяем строку `"🥑"` со строкой `"💻"`, что приводит к `"🥑💻"`.',
    id: 70,
  },
  {
    grade: Grades.Middle,
    theme: Themes.ASYNC,
    question:
      "Как мы можем вывести в лог значения, которые закомментированы после оператора console.log?",
    code: "function* startGame() {\n  const answer = yield 'Do you love JavaScript?';\n  if (answer !== 'Yes') {\n    return 'Oh wow... Guess we're gone here';\n  }\n  return 'JavaScript loves you back ❤️';\n}\n\nconst game = startGame();\nconsole.log(/* 1 */); // Do you love JavaScript?\nconsole.log(/* 2 */); // JavaScript loves you back ❤️",
    correctAnswer: 3,
    variants: [
      '`game.next("Yes").value` и `game.next().value`',
      '`game.next.value("Yes")` и `game.next.value()`',
      '`game.next().value` и `game.next("Yes").value`',
      '`game.next.value()` и `game.next.value("Yes")`',
    ],
    explanation:
      'Функция генератора "приостанавливает" выполнение, когда видит ключевое слово yield. Во-первых, мы должны позволить функции выдать строку "Do you love JavaScript?", что можно сделать, вызвав `game.next().value`.\n\nКаждая строка выполняется до тех пор, пока не найдет первое ключевое слово `yield`. В первой строке функции есть ключевое слово `yield` на первом месте: выполнение останавливается с первым выходом! _Это означает, что переменная `answer` еще не определена!_\n\nКогда мы вызываем `game.next("Yes").value`, предыдущий `yield` заменяется значением параметров, переданных функции `next()`, в данном случае `"Yes"`. Значение переменной `answer` теперь равно `"Yes"`. Условие if возвращает `false`, а `JavaScript loves you back ❤️`, регистрируется.',
    id: 71,
  },
  {
    grade: Grades.Middle,
    theme: Themes.BASICS,
    question: "Какой будет вывод?",
    code: "console.log(String.raw`Hello\\nworld`);",
    correctAnswer: 3,
    variants: [
      "`Hello world!`",
      "`Hello` <br />&nbsp; &nbsp; &nbsp;`world`",
      "`Hello\\nworld`",
      "`Hello\\n` <br /> &nbsp; &nbsp; &nbsp;`world`",
    ],
    explanation:
      '`String.raw` возвращает строку, в которой экранированные символы (`\\n`, `\\v`, `\\t` и т.д.) игнорируются! Обратная косая черта может быть проблемой, так как вы можете получить что-то вроде:\n\n`` const path = `C:\\Documents\\Projects\\table.html` ``\n\nЧто приведет к:\n\n`"C:DocumentsProjects able.html"`\n\nС `String.raw` он просто проигнорирует управляющий знак и напечатает:\n\n`C:\\Documents\\Projects\\table.html`\n\nВ этом случае строка `Hello\\nworld`, которая и выводится.',
    id: 72,
  },
  {
    grade: Grades.Junior,
    theme: Themes.ASYNC,
    question: "Какой будет вывод?",
    code: "async function getData() {\n  return await Promise.resolve('I made it!');\n}\n\nconst data = getData();\nconsole.log(data);",
    correctAnswer: 3,
    variants: [
      '`"I made it!"`',
      '`Promise {<resolved>: "I made it!"}`',
      "`Promise {<pending>}`",
      "`undefined`",
    ],
    explanation:
      'Асинхронная функция всегда возвращает обещание. `await` все еще должен ждать разрешения обещания: ожидаемое обещание возвращается, когда мы вызываем `getData()`, чтобы установить `data` равным ему.\n\nЕсли бы мы хотели получить доступ к разрешенному значению `"I made it"`, мы могли бы использовать метод `.then()` для `data`:\n\n`data.then(res => console.log(res))`\n\nТогда это бы вывело `"I made it!"`',
    id: 73,
  },
  {
    grade: Grades.Middle,
    theme: Themes.DATA_TYPES,
    question: "Какой будет вывод?",
    code: "function addToList(item, list) {\n  return list.push(item);\n}\n\nconst result = addToList('apple', ['banana']);\nconsole.log(result);",
    correctAnswer: 2,
    variants: ["`['apple', 'banana']`", "`2`", "`true`", "`undefined`"],
    explanation:
      'Метод `.push()` возвращает _длину_ нового массива! Ранее массив содержал один элемент (строка `"banana"`) и имел длину `1`. После добавления в массив строки `"apple"`, массив содержит два элемента и имеет длину `2`. Это возвращается из функции `addToList`.\n\nМетод `push` изменяет исходный массив. Если вы хотите вернуть _массив_ из функции, а не _длину массива_, вы должны были вернуть `list` после добавления в нее `item`.',
    id: 74,
  },
  {
    grade: Grades.Middle,
    theme: Themes.OBJECTS,
    question: "Какой будет вывод?",
    code: "const box = { x: 10, y: 20 };\n\nObject.freeze(box);\n\nconst shape = box;\nshape.x = 100;\n\nconsole.log(shape);",
    correctAnswer: 2,
    variants: [
      "`{ x: 100, y: 20 }`",
      "`{ x: 10, y: 20 }`",
      "`{ x: 100 }`",
      "`ReferenceError`",
    ],
    explanation:
      "`Object.freeze` делает невозможным добавление, удаление или изменение свойств объекта (если только значение свойства не является другим объектом).\n\nКогда мы создаем переменную `shape` и устанавливаем ее равной замороженному объекту `box`, `shape` также ссылается на замороженный объект. Вы можете проверить, заморожен ли объект, используя `Object.isFrozen`. В этом случае `Object.isFrozen(shape)` возвращает true, поскольку переменная `shape` имеет ссылку на замороженный объект.\n\nПоскольку `shape` заморожен, и поскольку значение `x` не является объектом, мы не можем изменить свойство `x`. `x` по-прежнему равно `10`, и `{x: 10, y: 20}` регистрируется.",
    id: 75,
  },
  {
    grade: Grades.Junior,
    theme: Themes.DATA_TYPES,
    question: "Какой будет вывод?",
    code: "const { firstName: myName } = { firstName: 'Lydia' };\n\nconsole.log(firstName);",
    correctAnswer: 4,
    variants: ['`"Lydia"`', '`"myName"`', "`undefined`", "`ReferenceError`"],
    explanation:
      "Используя [деструктурирующее присваивание](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment), мы можем распаковывать значения из массивов или свойства из объектов в отдельные переменные:\n\n``` js\nconst { firstName } = { firstName: 'Lydia' };\n// Версия ES5:\n// var firstName = { firstName: 'Lydia' }.firstName;\n\nconsole.log(firstName); // \"Lydia\"\n```\n\nТакже свойство можно распаковать из объекта и присвоить переменной с именем, отличным от имени свойства объекта:\n\n``` js\nconst { firstName: myName } = { firstName: 'Lydia' };\n// Версия ES5:\n// var myName = { firstName: 'Lydia' }.firstName;\n\nconsole.log(myName); // \"Lydia\"\nconsole.log(firstName); // Тут будет ошибка Uncaught ReferenceError: firstName is not defined\n```\n\nВ этом случае `firstName` не существует как переменная, поэтому попытка доступа к ее значению вызовет `ReferenceError`.\n\n**Примечание.** Помните о свойствах глобальной области видимости:\n\n``` js\nconst { name: myName } = { name: 'Lydia' };\n\nconsole.log(myName); // \"lydia\"\nconsole.log(name); // \"\" ----- Браузер, например, Chrome\nconsole.log(name); // ReferenceError: name is not defined  ----- NodeJS\n\n```\n\nВсякий раз, когда Javascript не может найти переменную в _текущей области видимости_, то поднимается вверх по [цепочке областей видимости](https://developer.mozilla.org/ru/docs/Web/JavaScript/Closures#лексическая_область_видимости) и ищет ее на каждом уровне, и если достигает области верхнего уровня, также известной как **Глобальная область**, и все еще не находит нужной ссылки, то выдает `ReferenceError`.\n\n- В **браузерах**, таких как _Chrome_, `name` является _устаревшим свойством глобальной области_. В этом примере код выполняется внутри _глобальной области_ и нет определяемой пользователем локальной переменной `name`, поэтому интерпретатор ищет предопределенные _переменные/свойства_ в глобальной области видимости, что в случае браузеров происходит через объект `window` и возвращается значение [window.name](https://developer.mozilla.org/en-US/docs/Web/API/Window/name), которое равно **пустой строке**.\n\n- В **NodeJS** такого свойства в \"глобальном\" объекте нет, поэтому попытка доступа к несуществующей переменной вызовет [ReferenceError](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Errors/Not_defined).",
    id: 76,
  },
  {
    grade: Grades.Middle,
    theme: Themes.BASICS,
    question: "Это чистая функция?",
    code: "function sum(a, b) {\n  return a + b;\n}",
    correctAnswer: 1,
    variants: ["Да", "Нет"],
    explanation:
      "Чистая функция - это функция, которая всегда возвращает тот же результат, если переданы одинаковые аргументы.\n\nФункция `sum` всегда возвращает один и тот же результат. Если мы передадим `1` и `2`, он всегда вернет `3` без побочных эффектов. Если мы передадим `5` и `10`, он всегда вернет `15` и так далее. Это определение чистой функции.",
    id: 77,
  },
  {
    grade: Grades.Middle,
    theme: Themes.FUNCTIONS,
    question: "Какой будет вывод?",
    code: "const add = () => {\n  const cache = {};\n  return num => {\n    if (num in cache) {\n      return `From cache! ${cache[num]}`;\n    } else {\n      const result = num + 10;\n      cache[num] = result;\n      return `Calculated! ${result}`;\n    }\n  };\n};\n\nconst addFunction = add();\nconsole.log(addFunction(10));\nconsole.log(addFunction(10));\nconsole.log(addFunction(5 * 2));",
    correctAnswer: 3,
    variants: [
      "`Calculated! 20` `Calculated! 20` `Calculated! 20`",
      "`Calculated! 20` `From cache! 20` `Calculated! 20`",
      "`Calculated! 20` `From cache! 20` `From cache! 20`",
      "`Calculated! 20` `From cache! 20` `Error`",
    ],
    explanation:
      "Функция `add` является функцией _запоминателем_. С помощью запоминания мы можем кэшировать результаты функции, чтобы ускорить ее выполнение. В этом случае мы создаем объект `cache`, в котором хранятся ранее возвращенные значения.\n\nЕсли мы снова вызываем функцию `addFunction` с тем же аргументом, она сначала проверяет, получило ли оно уже это значение в своем кеше. В этом случае будет возвращено значение кэша, что экономит время выполнения. Иначе, если он не кэшируется, он вычислит значение и сохранит его после.\n\nМы вызываем функцию `addFunction` три раза с одним и тем же значением: при первом вызове значение функции, когда `num` равно `10`, еще не кэшировано. Условие оператора if `num in cache` возвращает `false`, и выполняется блок else: `Calculated! 20` регистрируется, и значение результата добавляется в объект кеша. `cache` теперь выглядит как `{10: 20}`.\n\nВо второй раз объект `cache` содержит значение, возвращаемое для `10`. Условие оператора if `num in cache` возвращает `true`, а `'From cache! 20'` выводится в лог.\n\nВ третий раз мы передаем `5 * 2` в функцию, которая оценивается как `10`. Объект `cache` содержит значение, возвращаемое для `10`. Условие оператора if `num in cache` возвращает `true`, а `'From cache! 20'` регистрируется.",
    id: 78,
  },
  {
    grade: Grades.Junior,
    theme: Themes.DATA_TYPES,
    question: "Какой будет вывод?",
    code: "const myLifeSummedUp = ['☕', '💻', '🍷', '🍫']\n\nfor (let item in myLifeSummedUp) {\n  console.log(item)\n}\n\nfor (let item of myLifeSummedUp) {\n  console.log(item)\n}",
    correctAnswer: 1,
    variants: [
      '`0` `1` `2` `3` и `"☕"` ` "💻"` `"🍷"` `"🍫"`',
      '`"☕"` ` "💻"` `"🍷"` `"🍫"` и `"☕"` ` "💻"` `"🍷"` `"🍫"`',
      '`"☕"` ` "💻"` `"🍷"` `"🍫"` и `0` `1` `2` `3`',
      ' `0` `1` `2` `3` и `{0: "☕", 1: "💻", 2: "🍷", 3: "🍫"}`',
    ],
    explanation:
      'С помощью цикла _for-in_ мы можем перебирать **перечисляемые** свойства. В массиве перечисляемые свойства являются "ключами" элементов массива, которые фактически являются их индексами. Вы можете увидеть массив как:\n\n`{0: "☕", 1: "💻", 2: "🍷", 3: "🍫"}`\n\nГде ключи - перечисляемые свойства. `0` `1` `2` `3` войти в систему.\n\nС помощью цикла _for-of_ мы можем выполнять итерацию **итераций**. Массив является итеративным. Когда мы выполняем итерацию по массиву, переменная "item" равна элементу, по которому она итерируется в данный момент, `"☕"` `"💻"` `"🍷"` `"🍫"` выводится в лог.',
    id: 79,
  },
  {
    grade: Grades.Junior,
    theme: Themes.DATA_TYPES,
    question: "Какой будет вывод?",
    code: "const list = [1 + 2, 1 * 2, 1 / 2]\nconsole.log(list)",
    correctAnswer: 3,
    variants: [
      '`["1 + 2", "1 * 2", "1 / 2"]`',
      '`["12", 2, 0.5]`',
      "`[3, 2, 0.5]`",
      " `[1, 1, 1]`",
    ],
    explanation:
      "Элементы массива могут содержать любые значения. Числа, строки, объекты, другие массивы, ноль, логические значения, неопределенные и другие выражения, такие как даты, функции и вычисления.\n\nЭлемент будет равен возвращаемому значению. `1 + 2` вернет `3`, `1 * 2` вернет `2`, а `1 / 2` вернет `0.5`.",
    id: 80,
  },
  {
    grade: Grades.Junior,
    theme: Themes.FUNCTIONS,
    question: "Какой будет вывод?",
    code: "function sayHi(name) {\n  return `Hi there, ${name}`\n}\n\nconsole.log(sayHi())",
    correctAnswer: 2,
    variants: [
      "`Hi there, `",
      "`Hi there, undefined`",
      "`Hi there, null`",
      " `ReferenceError`",
    ],
    explanation:
      'По умолчанию аргументы имеют значение `undefined`, если только значение не было передано функции. В этом случае мы не передали значение для аргумента `name`. `name` равно логгируемому `undefined`.\n\nВ ES6 мы можем перезаписать значение по умолчанию `undefined` параметрами по умолчанию. Например:\n\n`function sayHi(name = "Lydia") { ... }`\n\nВ этом случае, если мы не передали значение или если мы передали `undefined`, `name` всегда будет равно строке `Lydia`',
    id: 81,
  },
  {
    grade: Grades.Middle,
    theme: Themes.FUNCTIONS,
    question: "Какой будет вывод?",
    code: "var status = '😎'\n\nsetTimeout(() => {\n  const status = '😍'\n\n  const data = {\n    status: '🥑',\n    getStatus() {\n      return this.status\n    }\n  }\n\n  console.log(data.getStatus())\n  console.log(data.getStatus.call(this))\n}, 0)",
    correctAnswer: 2,
    variants: [
      '`"🥑"` и `"😍"`',
      '`"🥑"` и `"😎"`',
      '`"😍"` и `"😎"`',
      '`"😎"` и `"😎"`',
    ],
    explanation:
      'Значение ключевого слова `this` зависит от того, где вы его используете. В **методе**, как и в методе `getStatus`, ключевое слово `this` ссылается на объект, которому принадлежит метод. Метод принадлежит объекту `data`, поэтому `this` относится к объекту `data`. Когда мы регистрируем `this.status`, регистрируется свойство `status` объекта `data`, которое является `"🥑"`.\n\nС помощью метода `call` мы можем изменить объект, на который ссылается ключевое слово `this`. В **функциях** ключевое слово `this` относится к _объекту, которому принадлежит функция_. Мы объявили функцию `setTimeout` для объекта _global_, поэтому в функции `setTimeout` ключевое слово `this` ссылается на объект _global_. В глобальном объекте есть переменная с именем _status_ со значением `"😎"`. При регистрации `this.status` выводится `"😎"`.',
    id: 82,
  },
  {
    grade: Grades.Middle,
    theme: Themes.OBJECTS,
    question: "Какой будет вывод?",
    code: "const person = {\n  name: 'Lydia',\n  age: 21\n}\n\nlet city = person.city\ncity = 'Amsterdam'\n\nconsole.log(person)",
    correctAnswer: 1,
    variants: [
      '`{ name: "Lydia", age: 21 }`',
      '`{ name: "Lydia", age: 21, city: "Amsterdam" }`',
      '`{ name: "Lydia", age: 21, city: undefined }`',
      '`"Amsterdam"`',
    ],
    explanation:
      'Мы устанавливаем переменную `city` равной значению свойства с именем `city` для объекта `person`. У этого объекта нет свойства с именем `city`, поэтому переменная `city` имеет значение `undefined`.\n\nОбратите внимание, что мы _не_ ссылаемся на сам объект person! Мы просто устанавливаем переменную `city` равной текущему значению свойства `city` объекта `person`.\n\nЗатем мы устанавливаем `city` равным строке `"Amsterdam"`. Это не меняет объект person - нет ссылки на этот объект.\n\nПри регистрации объекта `person` возвращается неизмененный объект.',
    id: 83,
  },
  {
    grade: Grades.Middle,
    theme: Themes.FUNCTIONS,
    question: "Какой будет вывод?",
    code: 'function checkAge(age) {\n  if (age < 18) {\n    const message = "Sorry, you\'re too young."\n  } else {\n    const message = "Yay! You\'re old enough!"\n  }\n\n  return message\n}\n\nconsole.log(checkAge(21))',
    correctAnswer: 3,
    variants: [
      '`"Sorry, you\'re too young."`',
      '`"Yay! You\'re old enough!"`',
      "`ReferenceError`",
      "`undefined`",
    ],
    explanation:
      "Переменные с ключевыми словами `const` и `let` имеют _блочную видимость_. Блок - это что-то между фигурными скобками (`{}`). В этом случае в фигурных скобках операторов if/else. Вы не можете ссылаться на переменную за пределами блока, в котором она объявлена, вызывается ReferenceError.",
    id: 84,
  },
  {
    grade: Grades.Junior,
    theme: Themes.ASYNC,
    question: "Какая информация будетвыведена в лог?",
    code: "fetch('https://www.website.com/api/user/1')\n  .then(res => res.json())\n  .then(res => console.log(res))",
    correctAnswer: 3,
    variants: [
      "Результат метода `fetch`.",
      "Результат второго вызова метода `fetch`.",
      "Результат коллбэка в предыдущем `.then()`.",
      "Всегда будет `undefined`.",
    ],
    explanation:
      "Значение `res` во втором `.then` равно возвращенному значению предыдущего `.then`. Вы можете продолжать цепочку `.then` таким образом; значение передается следующему обработчику.",
    id: 85,
  },
  {
    grade: Grades.Junior,
    theme: Themes.BASICS,
    question:
      "Какая опция позволяет установить hasName равным `true`, если вы не можете передать`true` в качестве аргумента?",
    code: "function getName(name) {\n  const hasName = //\n}",
    correctAnswer: 1,
    variants: ["`!!name`", "`name`", "`new Boolean(name)`", "`name.length`"],
    explanation:
      "С помощью `!!name` мы определяем, является ли значение `name` истинным или ложным. Если имя истинное, которое мы хотим проверить, то `!name` возвращает `false`. А `!false` (это то, чем на самом деле является `!! name`) возвращает `true`.\n\nУстанавливая `hasName` равным `name`, вы устанавливаете `hasName` равным любому значению, которое вы передали функции `getName`, а не логическому значению `true`.\n\n`new Boolean (true)` возвращает объектную оболочку, а не само логическое значение.\n\n`name.length` возвращает длину переданного аргумента, независимо от того, является ли он `true`.",
    id: 86,
  },
  {
    grade: Grades.Junior,
    theme: Themes.DATA_TYPES,
    question: "Какой будет вывод?",
    code: "console.log('I want pizza'[0])",
    correctAnswer: 2,
    variants: ['`"""`', '`"I"`', "`SyntaxError`", "`undefined`"],
    explanation:
      "Чтобы получить символ по определенному индексу в строке, вы можете использовать скобочную нотацию. Первый символ в строке имеет индекс 0 и т.д. В этом случае мы хотим получить элемент с индексом 0, символ `'I'`, который выводится в лог.\n\nОбратите внимание, что этот метод не поддерживается в IE7 и ниже. В этом случае используйте `.charAt()`",
    id: 87,
  },
  {
    grade: Grades.Junior,
    theme: Themes.FUNCTIONS,
    question: "Какой будет вывод?",
    code: "function sum(num1, num2 = num1) {\n  console.log(num1 + num2)\n}\n\nsum(10)",
    correctAnswer: 2,
    variants: ["`NaN`", "`20`", "`ReferenceError`", "`undefined`"],
    explanation:
      "Вы можете установить значение параметра по умолчанию равным другому параметру функции, если они были определены _до_ параметров по умолчанию. Мы передаем значение `10` в функцию `sum`. Если функция `sum` принимает только один аргумент, это означает, что значение для `num2` не передано, и в этом случае значение `num1` равно переданному значению `10`. Значением по умолчанию `num2` является значение `num1`, которое равно `10`. `num1 + num2` возвращает `20`.\n\nЕсли вы пытаетесь установить значение параметра по умолчанию равным параметру, который определен _после_ (справа), то значение параметра еще не было инициализировано; это приведет к ошибке.",
    id: 88,
  },
  {
    grade: Grades.Middle,
    theme: Themes.MODULES,
    question: "Какой будет вывод?",
    code: "// module.js\nexport default () => 'Hello world'\nexport const name = 'Lydia'\n\n// index.js\nimport * as data from './module'\n\nconsole.log(data)",
    correctAnswer: 1,
    variants: [
      '`{ default: function default(), name: "Lydia" }`',
      "`{ default: function default() }`",
      '`{ default: "Hello world", name: "Lydia" }`',
      "Global object of `module.js`",
    ],
    explanation:
      'С синтаксисом `import * as name` мы импортируем _все exports_ из файла `module.js` в файл `index.js`, тогда и создается новый объект с именем `data`. В файле `module.js` есть два экспорта: экспорт по умолчанию и именованный экспорт. Экспорт по умолчанию - это функция, которая возвращает строку `"Hello World"`, а именованный экспорт - это переменная с именем `name`, которая имеет значение строки `"Lydia"`.\n\nОбъект `data` имеет свойство `default` для экспорта по умолчанию, другие свойства имеют имена именованных экспортов и их соответствующие значения.',
    id: 89,
  },
  {
    grade: Grades.Junior,
    theme: Themes.CLASSES,
    question: "Какой будет вывод?",
    code: "class Person {\n  constructor(name) {\n    this.name = name\n  }\n}\n\nconst member = new Person('John')\nconsole.log(typeof member)",
    correctAnswer: 3,
    variants: ['`"class"`', '`"function"`', '`"object"`', '`"string"`'],
    explanation:
      'Классы являются синтаксическим сахаром для конструкторов функций. Эквивалентом класса `Person` в качестве конструктора функции будет:\n\n``` js\nfunction Person() {\n  this.name = name\n}\n```\n\nВызов конструктора функции с `new` приводит к созданию экземпляра `Person`, ключевое слово `typeof` возвращает `"object"` для экземпляра. `typeof member` возвращает `"object"`.',
    id: 90,
  },
  {
    grade: Grades.Middle,
    theme: Themes.DATA_TYPES,
    question: "Какой будет вывод?",
    code: "let newList = [1, 2, 3].push(4)\n\nconsole.log(newList.push(5))",
    correctAnswer: 4,
    variants: [
      "`[1, 2, 3, 4, 5]`",
      "`[1, 2, 3, 5]`",
      "`[1, 2, 3, 4]`",
      "`Error`",
    ],
    explanation:
      "Метод `.push` возвращает _новую длину_ массива, а не сам массив! Устанавливая `newList` равным `[1, 2, 3].push(4)`, мы устанавливаем `newList` равным новой длине массива: `4`.\n\nЗатем мы пытаемся использовать метод `.push` для `newList`. Поскольку `newList` является числовым значением `4`, мы не можем использовать метод `.push`: выдается ошибка TypeError.",
    id: 91,
  },
  {
    grade: Grades.Middle,
    theme: Themes.FUNCTIONS,
    question: "Какой будет вывод?",
    code: "function giveLydiaPizza() {\n  return 'Here is pizza!'\n}\n\nconst giveLydiaChocolate = () =>\n  \"Here's chocolate... now go hit the gym already.\"\n\nconsole.log(giveLydiaPizza.prototype)\nconsole.log(giveLydiaChocolate.prototype)",
    correctAnswer: 4,
    variants: [
      "`{ constructor: ...}` `{ constructor: ...}`",
      "`{}` `{ constructor: ...}`",
      "`{ constructor: ...}` `{}`",
      "`{ constructor: ...}` `undefined`",
    ],
    explanation:
      "Обычные функции, такие как функция `giveLydiaPizza`, имеют свойство `prototype`, которое является объектом (прототипом объекта) со свойством `constructor`. Однако функции со стрелками, такие как функция `giveLydiaChocolate`, не имеют этого свойства `prototype`. `undefined` возвращается при попытке доступа к свойству `prototype` с использованием `giveLydiaChocolate.prototype`.",
    id: 92,
  },
  {
    grade: Grades.Junior,
    theme: Themes.DATA_TYPES,
    question: "Какой будет вывод?",
    code: "const person = {\n  name: 'Lydia',\n  age: 21\n}\n\nfor (const [x, y] of Object.entries(person)) {\n  console.log(x, y)\n}",
    correctAnswer: 1,
    variants: [
      "`name` `Lydia` and `age` `21`",
      '`["name", "Lydia"]` and `["age", 21]`',
      '`["name", "age"]` and `undefined`',
      "`Error`",
    ],
    explanation:
      '`Object.entries (person)` возвращает массив вложенных массивов, содержащий ключи и объекты:\n\n`[ [ \'name\', \'Lydia\' ], [ \'age\', 21 ] ]`\n\nИспользуя цикл `for-of`, мы можем перебирать каждый элемент массива, в данном случае подмассивы. Мы можем мгновенно деструктурировать подмассивы в цикле for, используя `const [x, y]`. `x` равен первому элементу в подмассиве, `y` равен второму элементу в подмассиве.\n\nПервым подмассивом является `[ "name", "Lydia" ]`, где `x` равно `"name"`, и `y` равно `"Lydia"`, которые выводятся в лог.\nВторым подмассивом является `[ "age", 21 ]`, где `x` равно `"age"`, и `y` равно `21`, которые выводятся в лог.',
    id: 93,
  },
  {
    grade: Grades.Middle,
    theme: Themes.DATA_TYPES,
    question: "Какой будет вывод?",
    code: 'function getItems(fruitList, ...args, favoriteFruit) {\n  return [...fruitList, ...args, favoriteFruit]\n}\n\ngetItems(["banana", "apple"], "pear", "orange")',
    correctAnswer: 4,
    variants: [
      '`["banana", "apple", "pear", "orange"]`',
      '`[["banana", "apple"], "pear", "orange"]`',
      '`["banana", "apple", ["pear"], "orange"]`',
      "`SyntaxError`",
    ],
    explanation:
      "`... args` - прочие параметры. Значение прочих параметров - это массив, содержащий все оставшиеся аргументы **и может быть передан только последним**! В этом примере прочие параметры были вторым аргументом. Это невозможно, и это приведет к синтаксической ошибке.\n\n``` js\nfunction getItems(fruitList, favoriteFruit, ...args) {\n  return [...fruitList, ...args, favoriteFruit]\n}\n\ngetItems([\"banana\", \"apple\"], \"pear\", \"orange\")\n```\n\nПриведенный выше пример работает. Это возвращает массив `[ 'banana', 'apple', 'orange', 'pear' ]`",
    id: 94,
  },
  {
    grade: Grades.Middle,
    theme: Themes.TRICKS,
    question: "Какой будет вывод?",
    code: "function nums(a, b) {\n  if (a > b) console.log('a is bigger')\n  else console.log('b is bigger')\n  return\n    a + b;\n}\n\nconsole.log(nums(4, 2))\nconsole.log(nums(1, 2))",
    correctAnswer: 2,
    variants: [
      "`a is bigger`, `6` and `b is bigger`, `3`",
      "`a is bigger`, `undefined` and `b is bigger`, `undefined`",
      "`undefined` and `undefined`",
      "`SyntaxError`",
    ],
    explanation:
      "В JavaScript мы _не должны_ явно указывать точку с запятой (`;`), однако движок JavaScript все равно добавляет их после операторов. Это называется **автоматической вставкой точек с запятой**. Например, оператором могут быть переменные или ключевые слова, такие как `throw`, `return`, `break` и т.д.\n\nЗдесь мы написали инструкцию `return` и другое значение `a + b` в новой строке. Однако, поскольку это новая линия, движок не знает, что это на самом деле значение, которое мы хотели бы вернуть. Вместо этого он автоматически добавляет точку с запятой после `return`. Вы можете увидеть это как:\n\n``` js\n  return;\n  a + b\n```\n\nЭто означает, что `a + b` никогда не достигается, так как функция перестает выполняться после ключевого слова `return`. Если значение не возвращается, как здесь, функция возвращает значение `undefined`. Обратите внимание, что после операторов `if / else` автоматической вставки нет!",
    id: 95,
  },
  {
    grade: Grades.Middle,
    theme: Themes.CLASSES,
    question: "Какой будет вывод?",
    code: "class Person {\n  constructor() {\n    this.name = 'Lydia'\n  }\n}\n\nPerson = class AnotherPerson {\n  constructor() {\n    this.name = 'Sarah'\n  }\n}\n\nconst member = new Person()\nconsole.log(member.name)",
    correctAnswer: 2,
    variants: [
      '`"Lydia"`',
      '`"Sarah"`',
      "`Error: cannot redeclare Person`",
      "`SyntaxError`",
    ],
    explanation:
      "Мы можем установить классы равными другим классам/конструкторам функций. В этом случае мы устанавливаем `Person` равным `AnotherPerson`. Свойство `name` этого конструктора - `Sarah`, поэтому свойство `name` для нового экземпляра класса `Person` `member` - это `Sarah`.",
    id: 96,
  },
  {
    grade: Grades.Middle,
    theme: Themes.OBJECTS,
    question: "Какой будет вывод?",
    code: "const info = {\n  [Symbol('a')]: 'b'\n}\n\nconsole.log(info)\nconsole.log(Object.keys(info))",
    correctAnswer: 4,
    variants: [
      "`{Symbol('a'): 'b'}` and `[\"{Symbol('a')\"]`",
      "`{}` and `[]`",
      '`{ a: "b" }` and `["a"]`',
      "`{Symbol('a'): 'b'}` and `[]`",
    ],
    explanation:
      '`Symbol` не является _перечисляемый_. Метод `Object.keys` возвращает все _перечисляемые_ свойства ключа для объекта. `Symbol` не просматривается таким образом, и возвращается пустой массив. При регистрации всего объекта будут видны все свойства, даже не перечисляемые.\n\nЭто одно из многих качеств символа: помимо представления совершенно уникального значения (которое предотвращает случайное столкновение имен в объектах, например, при работе с 2 библиотеками, которые хотят добавить свойства к одному и тому же объекту), вы также можете "скрыть" свойства объектов таким образом (хотя и не полностью. Вы можете получить доступ к символам, используя метод `Object.getOwnPropertySymbols()`).',
    id: 97,
  },
  {
    grade: Grades.Middle,
    theme: Themes.DATA_TYPES,
    question: "Какой будет вывод?",
    code: 'const getList = ([x, ...y]) => [x, y]\nconst getUser = user => { name: user.name, age: user.age }\n\nconst list = [1, 2, 3, 4]\nconst user = { name: "Lydia", age: 21 }\n\nconsole.log(getList(list))\nconsole.log(getUser(user))',
    correctAnswer: 1,
    variants: [
      "`[1, [2, 3, 4]]` and `undefined`",
      '`[1, [2, 3, 4]]` and `{ name: "Lydia", age: 21 }`',
      '`[1, 2, 3, 4]` and `{ name: "Lydia", age: 21 }`',
      '`Error` and `{ name: "Lydia", age: 21 }`',
    ],
    explanation:
      'Функция `getList` получает массив в качестве аргумента. Между скобками функции `getList` мы сразу же деструктурируем этот массив. Вы можете увидеть это как:\n\n`[x, ...y] = [1, 2, 3, 4]`\n\nС помощью оставшихся параметров `... y` мы помещаем все "оставшиеся" аргументы в массив. Остальные аргументы - это `2`, `3` и `4` в этом случае. Значение `y` является массивом, содержащим все остальные параметры. В этом случае значение `x` равно `1`, поэтому, мы видим в логе `[x, y]`, `[1, [2, 3, 4]]`.\n\nФункция `getUser` получает объект. В стрелочных функциях нам _не нужно_ писать фигурные скобки, если мы просто возвращаем одно значение. Однако, если вы хотите мгновенно вернуть _object_ из стрелочной функции, вы должны написать его между круглыми скобками, иначе все, что находится между двумя фигурными скобками, будет интерпретироваться как оператор блока. В этом случае код между фигурными скобками не является допустимым кодом JavaScript, поэтому выдается `SyntaxError`.\n\nСледующая функция вернула бы объект:\n\n```const getUser = user => ({ name: user.name, age: user.age })```',
    id: 98,
  },
  {
    grade: Grades.Middle,
    theme: Themes.FUNCTIONS,
    question: "Какой будет вывод?",
    code: "const name = 'Lydia'\n\nconsole.log(name())",
    correctAnswer: 3,
    variants: [
      "`SyntaxError`",
      "`ReferenceError`",
      "`TypeError`",
      "`undefined`",
    ],
    explanation:
      "Переменная `name` содержит значение строки, которая не является функцией, поэтому не может вызываться.\n\nОшибки типа выдаются, когда значение не соответствует ожидаемому типу. JavaScript ожидал, что `name` будет функцией, так как мы пытаемся вызвать ее. Однако это была строка, поэтому выдается ошибка TypeError: name не является функцией!\n\nСинтаксические ошибки генерируются, когда вы написали что-то, что не является допустимым JavaScript, например, когда вы написали слово `return` как `retrun`.\nReferenceErrors генерируется, когда JavaScript не может найти ссылку на значение, к которому вы пытаетесь получить доступ.",
    id: 99,
  },
  {
    grade: Grades.Middle,
    theme: Themes.DATA_TYPES,
    question: "Какое значение будет на выходе?",
    code: "// 🎉✨ This is my 100th question! ✨🎉\n\nconst output = `${[] && 'Im'}possible!\nYou should${'' && `n't`} see a therapist after so much JavaScript lol`",
    correctAnswer: 2,
    variants: [
      "`possible! You should see a therapist after so much JavaScript lol`",
      "`Impossible! You should see a therapist after so much JavaScript lol`",
      "`possible! You shouldn't see a therapist after so much JavaScript lol`",
      "`Impossible! You shouldn't see a therapist after so much JavaScript lol`",
    ],
    explanation:
      "`[]` - истинное значение. С оператором `&&` будет возвращено правое значение, если левое значение является истинным значением. В этом случае левое значение `[]` является истинным значением, поэтому возвращается `'Im'`.\n\n`\"\"` - ложное значение. Если левое значение ложно, ничего не возвращается. `n't` не возвращается.",
    id: 100,
  },
  {
    grade: Grades.Middle,
    theme: Themes.BASICS,
    question: "Какое значение будет на выходе?",
    code: "const one = (false || {} || null)\nconst two = (null || false || '')\nconst three = ([] || 0 || true)\n\nconsole.log(one, two, three)",
    correctAnswer: 3,
    variants: [
      "`false` `null` `[]`",
      '`null` `""` `true`',
      '`{}` `""` `[]`',
      "`null` `null` `true`",
    ],
    explanation:
      'С помощью оператора `||` мы можем вернуть первый истинный операнд. Если все значения ложны, последний операнд возвращается.\n\n`(false || {} || null)`: пустой объект `{}` является истинным значением. Это первое (и единственное) истинное значение, которое возвращается. `one` содержит `{}`.\n\n`(null || false || "")`: все операнды являются ложными значениями. Это означает, что прошедший операнд `""` возвращается. `two` содержит `""`.\n\n`([] || 0 || "")`: пустой массив `[]` является истинным значением. Это первое истинное значение, которое возвращается. `three` присвоено `[]`.',
    id: 101,
  },
  {
    grade: Grades.Middle,
    theme: Themes.ASYNC,
    question: "Какое значение будет на выходе?",
    code: "const myPromise = () => Promise.resolve('I have resolved!')\n\nfunction firstFunction() {\n  myPromise().then(res => console.log(res))\n  console.log('second')\n}\n\nasync function secondFunction() {\n  console.log(await myPromise())\n  console.log('second')\n}\n\nfirstFunction()\nsecondFunction()",
    correctAnswer: 4,
    variants: [
      "`I have resolved!`, `second` and `I have resolved!`, `second`",
      "`second`, `I have resolved!` and `second`, `I have resolved!`",
      "`I have resolved!`, `second` and `second`, `I have resolved!`",
      "`second`, `I have resolved!` and `I have resolved!`, `second`",
    ],
    explanation:
      "С обещанием мы в основном говорим: _\"Я хочу выполнить эту функцию и откладываю ее, пока она выполняется, поскольку это может занять некоторое время. Только когда определенное значение разрешено (или отклонено), и когда стек вызовов пуст, я хочу использовать это значение_\".\n\nМы можем получить это значение с помощью ключевого слова `.then` и `await` в функции `async`. Хотя мы можем получить значение обещания с помощью `.then` и `await`, они работают немного по-разному.\n\nВ `firstFunction` мы (вроде) отложили функцию `myPromise` во время ее работы, но продолжили выполнение другого кода, в данном случае `console.log ('second')`. Затем функция разрешается строкой `I have resolved`, которая затем логируется после того, как она увидела, что стек вызовов пуст.\n\nИспользуя ключевое слово `await` в `secondFunction`, мы буквально приостанавливаем выполнение асинхронной функции до тех пор, пока значение не будет разрешено до перехода на следующую строку.\n\nЭто означает, что мы ожидали разрешения `myPromise` со значением `I have resolved`, и только когда это произошло, мы перешли к следующей строке: `second` была выведена в консоль последней.",
    id: 102,
  },
  {
    grade: Grades.Junior,
    theme: Themes.DATA_TYPES,
    question: "Какое значение будет на выходе?",
    code: "const set = new Set()\n\nset.add(1)\nset.add('Lydia')\nset.add({ name: 'Lydia' })\n\nfor (let item of set) {\n  console.log(item + 2)\n}",
    correctAnswer: 3,
    variants: [
      "`3`, `NaN`, `NaN`",
      "`3`, `7`, `NaN`",
      "`3`, `Lydia2`, `[object Object]2`",
      '`"12"`, `Lydia2`, `[object Object]2`',
    ],
    explanation:
      'Оператор `+` используется не только для добавления числовых значений, но мы также можем использовать его для объединения строк. Всякий раз, когда движок JavaScript видит, что одно или несколько значений не являются числом, он приводит число к строке.\n\nПервым является `1`, который является числовым значением. `1 + 2` возвращает число `3`.\n\nТем не менее, вторая строка `"Lydia"`. `"Lydia"` является строкой, а `2` является числом: `2` приводится к строке. `"Lydia"` и `"2"` объединяются, что приводит к результирующей строке `"Lydia2"`.\n\n`{name: "Lydia"}` является объектом. Ни число, ни объект не являются строкой, поэтому они приводятся к строке. Всякий раз, когда мы приводим обычный объект, он становится `"[object Object]"`. `"[object Object]"`, объединенный с `"2"`, становится `"[object Object]2"`.',
    id: 103,
  },
  {
    grade: Grades.Junior,
    theme: Themes.ASYNC,
    question: "Чему равно значение?",
    code: "Promise.resolve(5)",
    correctAnswer: 3,
    variants: [
      "`5`",
      "`Promise {<pending>: 5}`",
      "`Promise {<fulfilled>: 5}`",
      "`Error`",
    ],
    explanation:
      "Мы можем передать любой тип значения, которое мы хотим, в `Promise.resolve`, либо обещание, либо не обещание. Сам метод возвращает обещание с разрешенным значением (`<fulfilled>`). Если вы передадите обычную функцию, это будет разрешенное обещание с обычным значением. Если вы передадите обещание, это будет разрешенное обещание с разрешенным значением этого пройденного обещания.\n\nВ этом случае мы просто передали числовое значение `5`. Возвращается разрешенное обещание со значением `5`.",
    id: 104,
  },
  {
    grade: Grades.Middle,
    theme: Themes.OBJECTS,
    question: "Чему равно значение?",
    code: "function compareMembers(person1, person2 = person) {\n  if (person1 !== person2) {\n    console.log('Not the same!')\n  } else {\n    console.log('They are the same!')\n  }\n}\n\nconst person = { name: 'Lydia' }\n\ncompareMembers(person)",
    correctAnswer: 2,
    variants: [
      "`Not the same!`",
      "`They are the same!`",
      "`ReferenceError`",
      "`SyntaxError`",
    ],
    explanation:
      "Объекты передаются по ссылке. Когда мы проверяем объекты на строгое равенство (`===`), мы сравниваем их ссылки.\n\nМы устанавливаем значение по умолчанию для `person2`, равное объекту `person`, и передаем объект `person` в качестве значения для `person1`.\n\nЭто означает, что оба значения имеют ссылку на одно и то же место в памяти, поэтому они равны.\n\nБлок кода в операторе `else` запускается, и в лог выводится `They are the same!`.",
    id: 105,
  },
  {
    grade: Grades.Junior,
    theme: Themes.OBJECTS,
    question: "Чему равно значение?",
    code: "const colorConfig = {\n  red: true,\n  blue: false,\n  green: true,\n  black: true,\n  yellow: false,\n}\n\nconst colors = ['pink', 'red', 'blue']\n\nconsole.log(colorConfig.colors[1])",
    correctAnswer: 4,
    variants: ["`true`", "`false`", "`undefined`", "`TypeError`"],
    explanation:
      "В JavaScript у нас есть два способа доступа к свойствам объекта: нотация в скобках или нотация в точках. В этом примере мы используем точечную нотацию (`colorConfig.colors`) вместо скобочной нотации (`colorConfig[\"colors\"]`).\n\nВ точечной нотации JavaScript пытается найти свойство объекта с таким точным именем. В этом примере JavaScript пытается найти свойство с именем `colors` в объекте `colorConfig`. Не существует свойства с именем `colors`, поэтому возвращается `undefined`. Затем мы пытаемся получить доступ к значению первого элемента, используя `[1]`. Мы не можем сделать это для значения, которое `undefined`, поэтому оно выдает `TypeError`: `Cannot read свойство '1' of undefined`.\n\nJavaScript интерпретирует (или распаковывает) операторы. Когда мы используем скобочные обозначения, он видит первую открывающую скобку `[` и продолжает работать, пока не найдет закрывающую скобку `]`. Только тогда он оценит утверждение. Если бы мы использовали `colorConfig[colors [1]]`, он бы возвратил значение свойства `red` объекта `colorConfig`.",
    id: 106,
  },
  {
    grade: Grades.Junior,
    theme: Themes.DATA_TYPES,
    question: "Чему равно значение?",
    code: "console.log('❤️' === '❤️')",
    correctAnswer: 1,
    variants: ["`true`", "`false`"],
    explanation:
      'Под капотом смайлики - это юникоды. Юникод для сердца смайликов `"U+2764 U+FE0F"`. Они всегда одинаковы для одного и того же смайлика, поэтому мы сравниваем две одинаковые строки друг с другом, что возвращает `true`.',
    id: 107,
  },
  {
    grade: Grades.Junior,
    theme: Themes.DATA_TYPES,
    question: "Какой из этих методов модифицирует исходный массив?",
    code: "const emojis = ['✨', '🥑', '😍']\n\nemojis.map(x => x + '✨')\nemojis.filter(x => x !== '🥑')\nemojis.find(x => x !== '🥑')\nemojis.reduce((acc, cur) => acc + '✨')\nemojis.slice(1, 2, '✨') \nemojis.splice(1, 2, '✨')",
    correctAnswer: 4,
    variants: [
      "`All of them`",
      "`map` `reduce` `slice` `splice`",
      "`map` `slice` `splice` ",
      "`splice`",
    ],
    explanation:
      "Используя метод `splice`, мы модифицируем исходный массив, удаляя, заменяя или добавляя элементы. В этом случае мы удалили 2 элемента из индекса 1 (мы удалили `'🥑'` и `'😍'`) и добавили `✨` emoji.\n\n`map`, `filter` и `slice` возвращают новый массив, `find` возвращает элемент, а `reduce` возвращает аккумулированное значение.",
    id: 108,
  },
  {
    grade: Grades.Junior,
    theme: Themes.OBJECTS,
    question: "Какое значение будет на выходе?",
    code: "const food = ['🍕', '🍫', '🥑', '🍔']\nconst info = { favoriteFood: food[0] }\n\ninfo.favoriteFood = '🍝'\n\nconsole.log(food)",
    correctAnswer: 1,
    variants: [
      "`['🍕', '🍫', '🥑', '🍔']`",
      "`['🍝', '🍫', '🥑', '🍔']`",
      "`['🍝', '🍕', '🍫', '🥑', '🍔']` ",
      "`ReferenceError`",
    ],
    explanation:
      "Мы устанавливаем значение свойства `favourFood` для объекта `info` равным строке со смайликами для пиццы, `'🍕'`. Строка является примитивным типом данных. В JavaScript примитивные типы данных передаются по ссылке ...\n\nВ JavaScript примитивные типы данных (все, что не является объектом) передаются как _значение_. В этом случае мы устанавливаем значение свойства `favourFood` объекта `info` равным значению первого элемента в массиве `food`, в данном случае это строка с emoji пиццы (`'🍕'`). Строка является примитивным типом данных и взаимодействует по значению (см. мой [пост в блоге](https://www.theavocoder.com/complete-javascript/2018/12/21/by-value-vs-by-reference), если вы заинтересованы в получении дополнительной информации).\n\nЗатем мы меняем значение свойства `favourFood` объекта `info`. Массив `food` не изменился, поскольку значение `favourFood` было просто _скопировано_ из значения первого элемента в массиве и не имеет ссылки на то же место в памяти, что и элемент на `food[0]`. Когда мы выводим в лог `food`, это все равно исходный массив, `['🍕', '🍫', '🥑', '🍔']`.",
    id: 109,
  },
  {
    grade: Grades.Junior,
    theme: Themes.DATA_TYPES,
    question: "Что делает этот метод?",
    code: "JSON.parse()",
    correctAnswer: 1,
    variants: [
      "Разбирает JSON в значение JavaScript",
      "Разбирает объект JavaScript в JSON",
      "Разбирает любое значение JavaScript в JSON",
      "Разбирает JSON непосредственно в объект JavaScript",
    ],
    explanation:
      "С помощью метода `JSON.parse ()` мы можем разобрать строку JSON в значение JavaScript.\n\n``` js\n// Преобразование числа в допустимый JSON, затем преобразование строки JSON в значение JavaScript:\nconst jsonNumber = JSON.stringify(4) // '4'\nJSON.parse(jsonNumber) // 4\n\n// Преобразование значения массива в допустимый JSON, затем разбор строки JSON в значение JavaScript:\nconst jsonArray = JSON.stringify([1, 2, 3]) // '[1, 2, 3]'\nJSON.parse(jsonArray) // [1, 2, 3]\n\n// Преобразование объекта в допустимый JSON, затем преобразование строки JSON в значение JavaScript:\nconst jsonArray = JSON.stringify({ name: 'Lydia' }) // '{\"name\":\"Lydia\"}'\nJSON.parse(jsonArray) // { name: 'Lydia' }\n```",
    id: 110,
  },
  {
    grade: Grades.Junior,
    theme: Themes.BASICS,
    question: "Какое значение будет на выходе?",
    code: "let name = 'Lydia'\n\nfunction getName() {\n  console.log(name)\n  let name = 'Sarah'\n}\n\ngetName()",
    correctAnswer: 4,
    variants: ["Lydia", "Sarah", "`undefined`", "`ReferenceError`"],
    explanation:
      "Каждая функция имеет свой собственный _контекст исполнения_ (или _область видимости_). Функция `getName` сначала ищет в своем собственном контексте (области видимости), чтобы увидеть, содержит ли она переменную `name`, к которой мы пытаемся получить доступ. В этом случае функция `getName` содержит собственную переменную `name`: мы объявляем переменную `name` с ключевым словом `let` и значением `'Sarah'`.\n\nПеременные с ключевым словом `let` (и `const`) поднимаются в начало функции, в отличие от `var`, которые _не инициализируется_. Они недоступны до того, как мы объявим (инициализируем) их строку. Это называется \"временной мертвой зоной\". Когда мы пытаемся получить доступ к переменным до их объявления, JavaScript выдает `ReferenceError`.\n\nЕсли бы мы не объявили переменную `name` в функции `getName`, движок javascript посмотрел бы вниз по _цепочки области действия_. Внешняя область имеет переменную с именем `name` со значением `Lydia`. В этом случае он бы записал `Lydia`.\n\n``` js\nlet name = 'Lydia'\n\nfunction getName() {\n  console.log(name)\n}\n\ngetName() // Lydia\n```",
    id: 111,
  },
  {
    grade: Grades.Middle,
    theme: Themes.ASYNC,
    question: "Какое значение будет на выходе?",
    code: "function* generatorOne() {\n  yield ['a', 'b', 'c'];\n}\n\nfunction* generatorTwo() {\n  yield* ['a', 'b', 'c'];\n}\n\nconst one = generatorOne()\nconst two = generatorTwo()\n\nconsole.log(one.next().value)\nconsole.log(two.next().value)",
    correctAnswer: 3,
    variants: [
      "`a` and `a`",
      "`a` and `undefined`",
      "`['a', 'b', 'c']` and `a`",
      "`a` and `['a', 'b', 'c']`",
    ],
    explanation:
      "Используя ключевое слово `yield`, мы получаем значения в функции генератора. С помощью ключевого слова `yield*` мы можем получить значения из другой функции-генератора или итерируемого объекта (например, массива).\n\nВ `generatorOne` мы получаем весь массив `['a', 'b', 'c']`, используя ключевое слово `yield`. Значение свойства `value` для объекта, возвращаемого методом `next` для `one` (`one.next().value`), равно всему массиву `['a', 'b', 'c']`.\n\n``` js\nconsole.log(one.next().value) // ['a', 'b', 'c']\nconsole.log(one.next().value) // undefined\n```\n\nВ файле `generatorTwo` мы используем ключевое слово `yield*`. Это означает, что первое полученное значение `two` равно первому полученному значению в итераторе. Итератор - это массив `['a', 'b', 'c']`. Первым полученным значением является `a`, поэтому в первый раз, когда мы вызываем `two.next().value`, возвращается `a`.\n\n``` js\nconsole.log(two.next().value) // 'a'\nconsole.log(two.next().value) // 'b'\nconsole.log(two.next().value) // 'c'\nconsole.log(two.next().value) // undefined\n```",
    id: 112,
  },
  {
    grade: Grades.Junior,
    theme: Themes.BASICS,
    question: "Какое значение будет на выходе?",
    code: "console.log(`${(x => x)('I love')} to program`)",
    correctAnswer: 1,
    variants: [
      "`I love to program`",
      "`undefined to program`",
      "`${(x => x)('I love') to program`",
      "`TypeError`",
    ],
    explanation:
      "Выражения внутри литералов шаблона расчитываются первыми. Это означает, что строка будет содержать возвращаемое значение выражения, в данном случае немедленно исполняемую функцию `(x => x)('I love')`. Мы передаем значение `'I love'` в качестве аргумента стрелочной функции `x => x`. `x` равно `'I love'`, которое и возвращается. Это приводит к `I love to program`.",
    id: 113,
  },
  {
    grade: Grades.Middle,
    theme: Themes.FUNCTIONS,
    question: "Что произойдет?",
    code: "let config = {\n  alert: setInterval(() => {\n    console.log('Alert!')\n  }, 1000)\n}\n\nconfig = null",
    correctAnswer: 3,
    variants: [
      "обратный вызов `setInterval` не будет вызван",
      "обратный вызов `setInterval` будет вызван один раз",
      "обратный вызов `setInterval` будет вызываться каждую секунду",
      "мы никогда не вызовем `config.alert()`, т.к. `config` равно `null`",
    ],
    explanation:
      "Обычно, когда мы устанавливаем объекты равными `null`, эти объекты получают статус _собрано в мусор_, так как больше нет ссылок на этот объект. Однако, поскольку функция обратного вызова внутри `setInterval` является стрелочной функцией (таким образом, привязанной к объекту `config`), функция обратного вызова по-прежнему содержит ссылку на объект `config`.\nПока есть ссылка, объект не будет собирать мусор.\nТак как это интервал, установка `config` в `null` или `delete`-ing `config.alert` не приведет к сбору мусора для интервала, поэтому интервал все равно будет вызываться.\nЕго следует очистить с помощью `clearInterval(config.alert)`, чтобы удалить его из памяти.\nПоскольку он не был очищен, функция обратного вызова `setInterval` будет по-прежнему вызываться каждые 1000мс (1с).",
    id: 114,
  },
  {
    grade: Grades.Junior,
    theme: Themes.DATA_TYPES,
    question: "Какие методы вернут значение `'Hello world!'`?",
    code: "const myMap = new Map()\nconst myFunc = () => 'greeting'\n\nmyMap.set(myFunc, 'Hello world!')\n\n//1\nmyMap.get('greeting')\n//2\nmyMap.get(myFunc)\n//3\nmyMap.get(() => 'greeting')",
    correctAnswer: 2,
    variants: ["1", "2", "2 и 3", "Каждый из них"],
    explanation:
      "При добавлении пары ключ/значение с использованием метода `set` имя ключа будет равно значению первого аргумента, переданного в функцию `set`, а значением будет второй аргумент, переданный в функцию `set`. В данном случае ключом является _функция_ `() => 'greeting'` и значение `'Hello world'`. `myMap` теперь это `{ () => 'greeting' => 'Hello world!' }`.\n\n1 неверно, поскольку ключ не `'greeting'`, а `() => 'greeting'`.\n3 неверно, так как мы создаем новую функцию, передавая ее в качестве параметра методу `get`. Объект взаимодействует со _ссылкой_. Функции - это объекты, поэтому две функции никогда не бывают строго равными, даже если они идентичны: они имеют ссылки на разные места в памяти.",
    id: 115,
  },
  {
    grade: Grades.Middle,
    theme: Themes.FUNCTIONS,
    question: "Какое значение будет на выходе?",
    code: "const person = {\n  name: 'Lydia',\n  age: 21\n}\n\nconst changeAge = (x = { ...person }) => x.age += 1\nconst changeAgeAndName = (x = { ...person }) => {\n  x.age += 1\n  x.name = 'Sarah'\n}\n\nchangeAge(person)\nchangeAgeAndName()\n\nconsole.log(person)",
    correctAnswer: 3,
    variants: [
      '`{name: "Sarah", age: 22}`',
      '`{name: "Sarah", age: 23}`',
      '`{name: "Lydia", age: 22}`',
      '`{name: "Lydia", age: 23}`',
    ],
    explanation:
      'Функции `changeAge` и `changeAgeAndName` имеют параметр по умолчанию, а именно _вновь_ созданный объект `{ ...person }`. Этот объект имеет копии всех ключей/значений объекта `person`.\n\nСначала мы вызываем функцию `changeAge` и передаем объект `person` в качестве аргумента. Эта функция увеличивает значение свойства `age` на 1. `person` теперь `{name: "Lydia", age: 22}`.\n\nЗатем мы вызываем функцию `changeAgeAndName`, однако мы не передаем параметр. Вместо этого значение `x` равно новому объекту: `{ ... person }`. Поскольку это новый объект, он не влияет на значения свойств объекта `person`. `person` по-прежнему равен `{name: "Lydia", age: 22}`.',
    id: 116,
  },
  {
    grade: Grades.Junior,
    theme: Themes.FUNCTIONS,
    question: "Какой из следующих наборов параметров вернет `6`?",
    code: "function sumValues(x, y, z) {\n\treturn x + y + z;\n}",
    correctAnswer: 3,
    variants: [
      "`sumValues([...1, 2, 3])`",
      "`sumValues([...[1, 2, 3]])`",
      "`sumValues(...[1, 2, 3])`",
      "`sumValues([1, 2, 3])`",
    ],
    explanation:
      "С помощью оператора распространения (spread) `...` мы можем _распределить_ итерации в отдельньные элементы. `sumValues` принимает три аргумента:`x`, `y` и `z`. `...[1, 2, 3]` приведет к перечню `1, 2, 3`, который мы передаем функции `sumValues`.",
    id: 117,
  },
  {
    grade: Grades.Junior,
    theme: Themes.BASICS,
    question: "Что будет на выходе?",
    code: 'let num = 1;\nconst list = ["🥳", "🤠", "🥰", "🤪"];\n\nconsole.log(list[(num += 1)]);',
    correctAnswer: 2,
    variants: ["`🤠`", "`🥰`", "`SyntaxError`", "`ReferenceError`"],
    explanation:
      "С операндом `+=` мы увеличиваем значение `num` на `1`. `num` имеет начальное значение `1`, поэтому `1 + 1` равно `2`. Элементом второго индекса в массиве `list` и является вывод `console.log (list [2])`🥰.",
    id: 118,
  },
  {
    grade: Grades.Junior,
    theme: Themes.ECMASCRIPT,
    question: "Что будет на выходе?",
    code: "const person = {\n\tfirstName: 'Lydia',\n\tlastName: 'Hallie',\n\tpet: {\n\t\tname: 'Mara',\n\t\tbreed: 'Dutch Tulip Hound'\n\t},\n\tgetFullName() {\n\t\treturn `${this.firstName} ${this.lastName}`;\n\t}\n};\n\nconsole.log(person.pet?.name);\nconsole.log(person.pet?.family?.name);\nconsole.log(person.getFullName?.());\nconsole.log(member.getLastName?.());",
    correctAnswer: 2,
    variants: [
      "`undefined` `undefined` `undefined` `undefined`",
      "`Mara` `undefined` `Lydia Hallie` `undefined`",
      "`Mara` `null` `Lydia Hallie` `null`",
      "`null` `ReferenceError` `null` `ReferenceError`",
    ],
    explanation:
      "С необязательным оператором связывания `?.` нам больше не нужно явно проверять, действительны ли более глубокие вложенные значения или нет. Если мы пытаемся получить доступ к свойству со (_нулевым_) значением `undefined` или `null`, выражение замыкается и возвращает `undefined`.\n\n`person.pet?.name`: `person` имеет свойство с именем `pet`: `person.pet` не нулевое. Оно имеет свойство с именем `name`, и возвращает `Mara`.\n`person.pet?.family?.name`: `person` имеет свойство с именем `pet`: `person.pet` не нулевое. `pet` _не_ имеет свойство с именем `family`, `person.pet.family` нулевое. Выражение возвращает `undefined`.\n`person.getFullName?.()`: `person` имеет свойство с именем `getFullName`: `person.getFullName()` не нулевое, и может быть вызвано, возвращает `Lydia Hallie`.\n`member.getLastName?.()`: `member` не определено: `member.getLastName()` нулевое. Выражение возвращает `undefined`.",
    id: 119,
  },
  {
    grade: Grades.Junior,
    theme: Themes.BASICS,
    question: "Что будет на выходе?",
    code: "const groceries = ['banana', 'apple', 'peanuts'];\n\nif (groceries.indexOf('banana')) {\n\tconsole.log('We have to buy bananas!');\n} else {\n\tconsole.log(`We don't have to buy bananas!`);\n}",
    correctAnswer: 2,
    variants: [
      "We have to buy bananas!",
      "We don't have to buy bananas",
      "`undefined`",
      "`1`",
    ],
    explanation:
      'Мы передали условие `groceries.indexOf("banana")` в оператор `if`. `groceries.indexOf("banana")` возвращает `0`, что является ложным значением. Поскольку условие в операторе `if` ложно, выполняется код в блоке `else`, и в лог выводится ``We don\'t have to buy bananas!``.',
    id: 120,
  },
  {
    grade: Grades.Junior,
    theme: Themes.OBJECTS,
    question: "Что будет на выходе?",
    code: "const config = {\n\tlanguages: [],\n\tset language(lang) {\n\t\treturn this.languages.push(lang);\n\t}\n};\n\nconsole.log(config.language);",
    correctAnswer: 4,
    variants: [
      "`function language(lang) { this.languages.push(lang }`",
      "`0`",
      "`[]`",
      "`undefined`",
    ],
    explanation:
      "Метод `language` является `сеттером`. Сеттеры не содержат действительного значения, их целью является изменение свойств. При вызове метода `setter` возвращается `undefined`.",
    id: 121,
  },
  {
    grade: Grades.Middle,
    theme: Themes.DATA_TYPES,
    question: "Что будет на выходе?",
    code: "const name = 'Lydia Hallie';\n\nconsole.log(!typeof name === 'object');\nconsole.log(!typeof name === 'string');",
    correctAnswer: 3,
    variants: [
      "`false` `true`",
      "`true` `false`",
      "`false` `false`",
      "`true` `true`",
    ],
    explanation:
      '`typeof name` возвращает `"строку"`. Строка `"string"` является истинным значением, поэтому `!typeof name` возвращает логическое значение `false`. `false === "object"` и `false === "string"` оба возвращают `false`.\n\n(Если бы мы хотели проверить, был ли тип (не)равен определенному типу, мы должны были написать `!==` вместо `!typeof`)',
    id: 122,
  },
  {
    grade: Grades.Middle,
    theme: Themes.FUNCTIONS,
    question: "Что будет на выходе?",
    code: "const add = x => y => z => {\n\tconsole.log(x, y, z);\n\treturn x + y + z;\n};\n\nadd(4)(5)(6);",
    correctAnswer: 1,
    variants: [
      "`4` `5` `6`",
      "`6` `5` `4`",
      "`4` `function` `function`",
      "`undefined` `undefined` `6`",
    ],
    explanation:
      "Функция `add` возвращает стрелочную функцию, которая возвращает стрелочную функцию, которая возвращает стрелочную функцию (все еще тут?). Первая функция получает аргумент `x` со значением `4`. Мы вызываем вторую функцию, которая получает аргумент `y` со значением `5`. Затем мы вызываем третью функцию, которая получает аргумент `z` со значением `6`. Когда мы пытаемся получить доступ к значениям `x`, `y` и `z` в функции последней стрелки, движок JS поднимается вверх по цепочке областей видимости, чтобы найти значения для `x` и `y` соответственно. Это возвращает `4` `5` `6`.",
    id: 123,
  },
  {
    grade: Grades.Middle,
    theme: Themes.ASYNC,
    question: "Что будет на выходе?",
    code: "async function* range(start, end) {\n\tfor (let i = start; i <= end; i++) {\n\t\tyield Promise.resolve(i);\n\t}\n}\n\n(async () => {\n\tconst gen = range(1, 3);\n\tfor await (const item of gen) {\n\t\tconsole.log(item);\n\t}\n})();",
    correctAnswer: 3,
    variants: [
      "`Promise {1}` `Promise {2}` `Promise {3}`",
      "`Promise {<pending>}` `Promise {<pending>}` `Promise {<pending>}`",
      "`1` `2` `3`",
      "`undefined` `undefined` `undefined`",
    ],
    explanation:
      "Функция генератора `range` возвращает асинхронный объект с обещаниями для каждого элемента в диапазоне, который мы передаем: `Promise {1}`, `Promise {2}`, `Promise {3}`. Мы устанавливаем переменную `gen` равной асинхронному объекту, после чего зацикливаем ее, используя цикл `for await ... of`. Мы устанавливаем переменную `item` равной возвращаемым значениям `Promise`: сначала `Promise {1}`, затем `Promise {2}`, затем `Promise {3}`. Так как мы _ожидаем_ значение `item`, разрешается обещание, возвращаются разрешенные _значения_ обещания: `1`, `2`, затем `3`.",
    id: 124,
  },
  {
    grade: Grades.Junior,
    theme: Themes.DATA_TYPES,
    question: "Что будет на выходе?",
    code: "const myFunc = ({ x, y, z }) => {\n\tconsole.log(x, y, z);\n};\n\nmyFunc(1, 2, 3);",
    correctAnswer: 4,
    variants: [
      "`1` `2` `3`",
      "`{1: 1}` `{2: 2}` `{3: 3}`",
      "`{ 1: undefined }` `undefined` `undefined`",
      "`undefined` `undefined` `undefined`",
    ],
    explanation:
      "`myFunc` ожидает объект со свойствами `x`, `y` и `z` в качестве аргумента. Поскольку мы передаем только три отдельных числовых значения (1, 2, 3) вместо одного объекта со свойствами `x`, `y` и `z` ({x: 1, y: 2, z: 3}), то `x`, `y` и `z` имеют значение по умолчанию` undefined`.",
    id: 125,
  },
  {
    grade: Grades.Junior,
    theme: Themes.MISC,
    question: "Что будет на выходе?",
    code: "function getFine(speed, amount) {\n  const formattedSpeed = new Intl.NumberFormat({\n    'en-US',\n    { style: 'unit', unit: 'mile-per-hour' }\n  }).format(speed)\n\n  const formattedAmount = new Intl.NumberFormat({\n    'en-US',\n    { style: 'currency', currency: 'USD' }\n  }).format(amount)\n\n  return `The driver drove ${formattedSpeed} and has to pay ${formattedAmount}`\n}\n\nconsole.log(getFine(130, 300))",
    correctAnswer: 2,
    variants: [
      "The driver drove 130 and has to pay 300",
      "The driver drove 130 mph and has to pay \\$300.00",
      "The driver drove undefined and has to pay undefined",
      "The driver drove 130.00 and has to pay 300.00",
    ],
    explanation:
      "С помощью метода `Intl.NumberFormat` мы можем форматировать числовые значения в любой локали. Мы форматируем числовое значение `130` для локали `en-US` как `unit` в `mile-per-hour`, что приводит к `130 mph`. Числовое значение `300` для локали `en-US` в качестве `currentcy` в `USD` приводит к `$300.00`.",
    id: 126,
  },
  {
    grade: Grades.Junior,
    theme: Themes.DATA_TYPES,
    question: "Что будет на выходе?",
    code: 'const spookyItems = ["👻", "🎃", "🕸"];\n({ item: spookyItems[3] } = { item: "💀" });\n\nconsole.log(spookyItems);',
    correctAnswer: 2,
    variants: [
      '`["👻", "🎃", "🕸"]`',
      '`["👻", "🎃", "🕸", "💀"]`',
      '`["👻", "🎃", "🕸", { item: "💀" }]`',
      '`["👻", "🎃", "🕸", "[object Object]"]`',
    ],
    explanation:
      'Деструктурируя объекты, мы можем распаковать значения из правого объекта и присвоить распакованному значению значение того же по имени свойства в левом объекте. В этом случае мы присваиваем значение "💀" `spookyItems[3]`. Это означает, что мы модифицируем массив `spookyItems`, добавляем к нему «💀». При логировании `spookyItems` выводится ` ["👻", "🎃", "🕸", "💀"]`.',
    id: 127,
  },
  {
    grade: Grades.Junior,
    theme: Themes.DATA_TYPES,
    question: "Что будет на выходе?",
    code: 'const name = "Lydia Hallie";\nconst age = 21;\n\nconsole.log(Number.isNaN(name));\nconsole.log(Number.isNaN(age));\n\nconsole.log(isNaN(name));\nconsole.log(isNaN(age));',
    correctAnswer: 3,
    variants: [
      "`true` `false` `true` `false`",
      "`true` `false` `false` `false`",
      "`false` `false` `true` `false`",
      "`false` `true` `false` `true`",
    ],
    explanation:
      "С помощью метода `Number.isNaN` вы можете проверить, является ли передаваемое вами значение _числовым значением_ и равно ли оно `NaN`. `name` не является числовым значением, поэтому `Number.isNaN(name)` возвращает `false`. `age` является числовым значением, но не равно `NaN`, поэтому `Number.isNaN(age)` возвращает `false`.\n\nС помощью метода `isNaN` вы можете проверить, не является ли передаваемое вами значение числом. `name` не является числом, поэтому `isNaN(name)` возвращает true. `age` - это число, поэтому `isNaN(age)` возвращает `false`.",
    id: 128,
  },
  {
    grade: Grades.Junior,
    theme: Themes.BASICS,
    question: "Что будет на выходе?",
    code: "const randomValue = 21;\n\nfunction getInfo() {\n\tconsole.log(typeof randomValue);\n\tconst randomValue = 'Lydia Hallie';\n}\n\ngetInfo();",
    correctAnswer: 4,
    variants: ['`"number"`', '`"string"`', "`undefined`", "`ReferenceError`"],
    explanation:
      "Переменные, объявленные с ключевым словом `const`, не имеют ссылки до их инициализации: это называется _временная мертвая зона_. В функции `getInfo` переменная `randomValue` находится в области видимости `getInfo`. В строке, где мы хотим записать значение `typeof randomValue`, переменная `randomValue` еще не инициализирована: выдается `ReferenceError`! Движок не пошел по цепочке областей видимости, так как мы объявили переменную `randomValue` в функции `getInfo`.",
    id: 129,
  },
  {
    grade: Grades.Middle,
    theme: Themes.ERRORS,
    question: "Что будет на выходе?",
    code: "const myPromise = Promise.resolve('Woah some cool data');\n\n(async () => {\n\ttry {\n\t\tconsole.log(await myPromise);\n\t} catch {\n\t\tthrow new Error(`Oops didn't work`);\n\t} finally {\n\t\tconsole.log('Oh finally!');\n\t}\n})();",
    correctAnswer: 3,
    variants: [
      "`Woah some cool data`",
      "`Oh finally!`",
      "`Woah some cool data` `Oh finally!`",
      "`Oops didn't work` `Oh finally!`",
    ],
    explanation:
      'В блоке `try` мы выводим в лог ожидаемое значение переменной `myPromise`: `"Woah some cool data"`. Поскольку в блоке `try` не было выдано никаких ошибок, код в блоке `catch` не запускается. Код в блоке `finally` _всегда_ выполняется, `"Oh finally!"` также выводится в лог.',
    id: 130,
  },
  {
    grade: Grades.Junior,
    theme: Themes.ECMASCRIPT,
    question: "Что будет на выходе?",
    code: "const emojis = ['🥑', ['✨', '✨', ['🍕', '🍕']]];\n\nconsole.log(emojis.flat(1));",
    correctAnswer: 2,
    variants: [
      "`['🥑', ['✨', '✨', ['🍕', '🍕']]]`",
      "`['🥑', '✨', '✨', ['🍕', '🍕']]`",
      "`['🥑', ['✨', '✨', '🍕', '🍕']]`",
      "`['🥑', '✨', '✨', '🍕', '🍕']`",
    ],
    explanation:
      "С помощью метода `flat` мы можем создать новый плоский массив. Глубина уплощенного массива зависит от значения, которое мы передаем. В этом случае мы передали значение `1` (которое нам не нужно, это значение по умолчанию), что означает, что будут объединены только массивы на первой глубине. `['🥑']` и `['✨', '✨', ['🍕', '🍕']]` в этом случае. Конкатенация этих двух массивов приводит к `['🥑', '✨', '✨', ['🍕', '🍕']]`.",
    id: 131,
  },
  {
    grade: Grades.Middle,
    theme: Themes.CLASSES,
    question: "Что будет на выходе?",
    code: "class Counter {\n  constructor() {\n    this.count = 0;\n  }\n\n  increment() {\n    this.count++;\n  }\n}\n\nconst counterOne = new Counter();\ncounterOne.increment();\ncounterOne.increment();\n\nconst counterTwo = counterOne;\ncounterTwo.increment();\n\nconsole.log(counterOne.count);",
    correctAnswer: 4,
    variants: ["`0`", "`1`", "`2`", "`3`"],
    explanation:
      "`counterOne` экземпляр класса `Counter`. Counter класс содержит метод `increment` и свойство `count` в конструкторе. Сперва, при помощи `counterOne.increment()`, мы дважды вызываем метод `increment`. `counterOne.count` становится `2`.\n\n![Image](https://i.imgur.com/KxLlTm9.png)\n\nЗатем, мы создаем новую переменную `counterTwo`, и присваиваем ей `counterOne`. Поскольку объекты передаются по ссылке, мы просто создаем новую ссылку на то же место в памяти, на которое указывает `counterOne`. Поскольку переменные ссылаются на то же место в памяти, любые изменения, внесенные в объект, на который ссылается `counterTwo`, также применяются к` counterOne`. Теперь `counterTwo.count` равно `2`.\n\nМы вызываем `counterTwo.increment()`, что устанавливает значение `count` равное `3`. Затем мы выводим в консоль значение переменной `counterOne`, которое равно `3`.\n\n![Image](https://i.imgur.com/BNBHXmc.png)",
    id: 132,
  },
  {
    grade: Grades.Middle,
    theme: Themes.ASYNC,
    question: "Что будет на выходе?",
    code: "const myPromise = Promise.resolve(Promise.resolve('Promise!'));\n\nfunction funcOne() {\n  myPromise.then(res => res).then(res => console.log(res));\n  setTimeout(() => console.log('Timeout!', 0));\n  console.log('Last line!');\n}\n\nasync function funcTwo() {\n  const res = await myPromise;\n  console.log(await res);\n  setTimeout(() => console.log('Timeout!', 0));\n  console.log('Last line!');\n}\n\nfuncOne();\nfuncTwo();",
    correctAnswer: 4,
    variants: [
      "`Promise! Last line! Promise! Last line! Last line! Promise!`",
      "`Last line! Timeout! Promise! Last line! Timeout! Promise!`",
      "`Promise! Last line! Last line! Promise! Timeout! Timeout!`",
      "`Last line! Promise! Promise! Last line! Timeout! Timeout!`",
    ],
    explanation:
      'Сначала мы вызываем `funcOne`. В первой строке `funcOne` мы вызываем _асинхронную_ функцию `setTimeout`, из которой обратный вызов отправляется в веб-API. (см. мою статью о цикле событий <a href="https://dev.to/lydiahallie/javascript-visualized-event-loop-3dif">здесь</a>.)\n\nЗатем мы вызываем обещание `myPromise`, которое является _асинхронной_ операцией.\n\nИ обещание, и тайм-аут являются асинхронными операциями, функция продолжает работать, пока она занята выполнением обещания и обработкой обратного вызова `setTimeout`. Это означает, что `Last line 1!` регистрируется первой, так как это не асинхронная операция.\n\nПоскольку стек вызовов еще не пуст, функция `setTimeout` и обещание в `funcOne` еще не могут быть добавлены в стек вызовов.\n\nВ `funcTwo` переменная `res` получает `Promise`, потому что `Promise.resolve(Promise.resolve(\'Promise\'))` эквивалентно `Promise.resolve(\'Promise\')`, так как разрешение обещания просто разрешает его стоимость. `await` в этой строке останавливает выполнение функции до тех пор, пока она не получит разрешение промиса, а затем продолжает работать синхронно до завершения, поэтому `Promise 2!`, а затем `Last line 2!` регистрируются, а `setTimeout` отправляется в Web API.\n\nТогда стек вызовов пуст. Промисы — это _микрозадачи_, поэтому они решаются первыми, когда стек вызовов пуст, поэтому `Promise 1!` регистрируется.\n\nТеперь, поскольку `funcTwo` выталкивается из стека вызовов, стек вызовов пуст. Обратные вызовы, ожидающие в очереди (`() => console.log("Timeout 1!")` из `funcOne`, и `() => console.log("Timeout 2!")` из `funcTwo`) добавляются в стек вызовов один за другим. Первый обратный вызов регистрирует `Timeout 1!` и удаляется из стека. Затем второй обратный вызов регистрирует `Timeout 2!` и удаляется из стека.',
    id: 133,
  },
  {
    grade: Grades.Middle,
    theme: Themes.MODULES,
    question: "Как мы можем вызвать функцию `sum` в `sum.js` из `index.js?`",
    code: "// sum.js\nexport default function sum(x) {\n  return x + x;\n}\n\n// index.js\nimport * as sum from './sum';",
    correctAnswer: 3,
    variants: [
      "`sum(4)`",
      "`sum.sum(4)`",
      "`sum.default(4)`",
      "Нельзя импортировать значения по умолчанию используя `*`, только именованные экспорты",
    ],
    explanation:
      "Используя звездочку `*`, мы импортируем все экспортируемые значения из файла, включая именнованные экспорты и экспорты по умолчанию. Если бы у нас был следующий файл:\n\n``` js\n// info.js\nexport const name = 'Lydia';\nexport const age = 21;\nexport default 'I love JavaScript';\n\n// index.js\nimport * as info from './info';\nconsole.log(info);\n```\n\nВ лог попадёт следующее:\n\n``` js\n{\n  default: 'I love JavaScript',\n  name: 'Lydia',\n  age: 21\n}\n```\n\nДля примера `sum` это означает, что импортированное значение `sum` будет таким:\n\n``` js\n{ default: function sum(x) { return x + x } }\n```\n\nСледовательно, мы можем вызвать эту функцию используя `sum.default`",
    id: 134,
  },
  {
    grade: Grades.Junior,
    theme: Themes.MISC,
    question: "Что будет на выходе?",
    code: "const handler = {\n  set: () => console.log('Added a new property!'),\n  get: () => console.log('Accessed a property!'),\n};\n\nconst person = new Proxy({}, handler);\n\nperson.name = 'Lydia';\nperson.name;",
    correctAnswer: 3,
    variants: [
      "`Added a new property!`",
      "`Accessed a property!`",
      "`Added a new property!` `Accessed a property!`",
      "В лог ничего не попадёт",
    ],
    explanation:
      'C помощью Proxy мы можем добавить собственное поведению объекту, которое мы передаем вторым аргументом. В нашем случае мы передаем объект `handler` который содержит свойства: `set` и `get`. `set` вызывается каждый раз когда мы _устанавливаем_ значения свойств, `get` же вызывается всякий раз когда мы _получаем_ значения свойств.\n\nПервый аргумент — пустой объект `{}`, который является значением `person`. Для него будет добавлено собственное поведение, описанное в объекте `handler`. При добавлении значения для объекта `person` будет вызвано свойство `set`. При запросе к значению `person` вызовется свойство `get`.\n\nСначала мы устанавливаем новое свойство `name` для объекта Proxy (`person.name = "Lydia"`). Вызывается `set` и в лог попадает `"Added a new property!"`.\n\nЗатем мы обращаемся к значению Proxy-объекта. Вызывается свойство `get` объекта `handler`. `"Accessed a property!"` попадает в лог.',
    id: 135,
  },
  {
    grade: Grades.Junior,
    theme: Themes.OBJECTS,
    question:
      "Какое из перечисленных действий может модифицировать объект `person`?",
    code: "const person = { name: 'Lydia Hallie' };\n\nObject.seal(person);",
    correctAnswer: 1,
    variants: [
      '`person.name = "Evan Bacon"`',
      "`person.age = 21`",
      "`delete person.name`",
      "`Object.assign(person, { age: 21 })`",
    ],
    explanation:
      "С помощью `Object.seal` мы можем предотвращать как _добавление_ новых свойств, так и _удаление_ существующих.\n\nОднако, изменение существующих свойств остаётся доступным.",
    id: 136,
  },
  {
    grade: Grades.Junior,
    theme: Themes.OBJECTS,
    question:
      "Какое из перечисленных действий может модифицировать объект `person`?",
    code: "const person = {\n  name: 'Lydia Hallie',\n  address: {\n    street: '100 Main St',\n  },\n};\n\nObject.freeze(person);",
    correctAnswer: 3,
    variants: [
      '`person.name = "Evan Bacon"`',
      "`delete person.address`",
      '`person.address.street = "101 Main St"`',
      '`person.pet = { name: "Mara" }`',
    ],
    explanation:
      "С помощью метода `Object.freeze` мы можем _заморозить_ объект. Свойства не могут быть добавлены, изменены или удалены.\n\nОднако, это _неглубоко_ замораживает объект. Замораживаются только _непосредственные_ свойства объекта. Если свойством является другой объект(в нашем примере `address`), свойства этого объекта не замораживаются и могут быть изменены.",
    id: 137,
  },
  {
    grade: Grades.Middle,
    theme: Themes.FUNCTIONS,
    question: "Что будет на выходе?",
    code: "const add = x => x + x;\n\nfunction myFunc(num = 2, value = add(num)) {\n  console.log(num, value);\n}\n\nmyFunc();\nmyFunc(3);",
    correctAnswer: 1,
    variants: [
      "`2` `4` and `3` `6`",
      "`2` `NaN` and `3` `NaN`",
      "`2` `Error` and `3` `6`",
      "`2` `4` and `3` `Error`",
    ],
    explanation:
      "Во-первых, мы вызваем `myFunc()` без передачи каких-либо аргументов. Поскольку мы не передаем аргументы, `num` и `value` получают свои значения по умолчанию: `num` равно `2`, а `value` возвращаемое значение функции `add`. В функцию `add` мы передаем в качестве аргумента `num` со значением `2`. `add` возвращает `4`, что является значением `value`.\n\nЗатем мы вызваем `myFunc(3)` и передаем значение `3` в качестве значения аргумента `num`. Мы не передаем аргумент для `value`. Поскольку мы не передаем значение для аргумента `value`, он получаеи значение по умолчанию: возвращаемое значение функции `add`. В `add` мы передаем `num`, значение которого равно `3`. `add` возвращает `6`, что является значением `value`.",
    id: 138,
  },
  {
    grade: Grades.Junior,
    theme: Themes.ECMASCRIPT,
    question: "Что будет на выходе?",
    code: "class Counter {\n  #number = 10\n\n  increment() {\n    this.#number++\n  }\n\n  getNum() {\n    return this.#number\n  }\n}\n\nconst counter = new Counter()\ncounter.increment()\n\nconsole.log(counter.#number)",
    correctAnswer: 4,
    variants: ["`10`", "`11`", "`undefined`", "`SyntaxError`"],
    explanation:
      "В ES2020 мы можем добавлять приватные переменные в классы с помощью символа `#`. Мы не можем получить доступ к этим переменным вне класса. Когда мы пытаемся записать `counter.#number`, выдается `SyntaxError`: мы не можем получить доступ вне класса `Counter`!",
    id: 139,
  },
  {
    grade: Grades.Junior,
    theme: Themes.ASYNC,
    question: "В каком случае не будет ошибки?",
    code: "const teams = [\n  { name: 'Team 1', members: ['Paul', 'Lisa'] },\n  { name: 'Team 2', members: ['Laura', 'Tim'] },\n];\n\nfunction* getMembers(members) {\n  for (let i = 0; i < members.length; i++) {\n    yield members[i];\n  }\n}\n\nfunction* getTeams(teams) {\n  for (let i = 0; i < teams.length; i++) {\n    // ✨ SOMETHING IS MISSING HERE ✨\n  }\n}\n\nconst obj = getTeams(teams);\nobj.next(); // { value: \"Paul\", done: false }\nobj.next(); // { value: \"Lisa\", done: false }",
    correctAnswer: 2,
    variants: [
      "`yield getMembers(teams[i].members)`",
      "`yield* getMembers(teams[i].members)`",
      "`return getMembers(teams[i].members)`",
      "`return yield getMembers(teams[i].members)`",
    ],
    explanation:
      "Чтобы выполнить итерацию по `members` в каждом элементе массива `teams`, нам нужно передать `teams[i].members` в функцию генератора `getMembers`. Функция генератора возвращает объект генератора. Чтобы перебрать каждый элемент в этом объекте-генераторе, нам нужно использовать `yield*`.\n\nЕсли бы мы написали `yield`, `return yield` или `return`, вся функция генератора была бы возвращена при первом вызове метода `next`.",
    id: 140,
  },
  {
    grade: Grades.Junior,
    theme: Themes.DATA_TYPES,
    question: "Что будет на выходе?",
    code: "const person = {\n  name: 'Lydia Hallie',\n  hobbies: ['coding'],\n};\n\nfunction addHobby(hobby, hobbies = person.hobbies) {\n  hobbies.push(hobby);\n  return hobbies;\n}\n\naddHobby('running', []);\naddHobby('dancing');\naddHobby('baking', person.hobbies);\n\nconsole.log(person.hobbies);",
    correctAnswer: 3,
    variants: [
      '`["coding"]`',
      '`["coding", "dancing"]`',
      '`["coding", "dancing", "baking"]`',
      '`["coding", "running", "dancing", "baking"]`',
    ],
    explanation:
      'Функция `addHobby` получает два аргумента, `hobby` и `hobbies`, со значением по умолчанию массива `hobbies` в объекте `person`.\n\nВо-первых, мы вызываем функцию `addHobby` и передаем `"running"` в качестве значения для `hobby`, а пустой массив в качестве значения для `hobbies`. Так как мы передаем пустой массив в качестве значения для `hobbies`, `"running"` добавляется к этому пустому массиву.\n\nЗатем мы вызываем функцию `addHobby` и передаем `dancing` в качестве значения для `hobby`. Мы не передавали значение для `hobbies`, поэтому оно получает значение по умолчанию, свойство `hobbies` объекта `person`. Мы помещаем хобби `dancing` в массив `person.hobbies`.\n\nНаконец, мы вызываем функцию `addHobby` и передаем `"baking"` в качестве значения для `hobby`, а массив `person.hobbies` в качестве значения для `hobbies`. Мы помещаем хобби `baking` в массив `person.hobbies`.\n\nПосле нажатия `танцы` и `выпечка`, значение `person.hobbies` равно `["coding", "dancing", "baking"]`',
    id: 141,
  },
  {
    grade: Grades.Junior,
    theme: Themes.CLASSES,
    question: "Что будет на выходе?",
    code: 'class Bird {\n  constructor() {\n    console.log("I\'m a bird. 🦢");\n  }\n}\n\nclass Flamingo extends Bird {\n  constructor() {\n    console.log("I\'m pink. 🌸");\n    super();\n  }\n}\n\nconst pet = new Flamingo();',
    correctAnswer: 2,
    variants: [
      "`I'm pink. 🌸`",
      "`I'm pink. 🌸` `I'm a bird. 🦢`",
      "`I'm a bird. 🦢` `I'm pink. 🌸`",
      "Nothing, we didn't call any method",
    ],
    explanation:
      'Мы создаем переменную `pet`, которая является экземпляром класса `Flamingo`. Когда мы создаем этот экземпляр, вызывается `constructor` для `Flamingo`. Сначала регистрируется `"I\'m pink. 🌸"`, после чего мы вызываем `super()`. `super()` вызывает конструктор родительского класса `Bird`. Конструктор в `Bird` вызывается и регистрирует `"I\'m a bird. 🦢"`.',
    id: 142,
  },
  {
    grade: Grades.Junior,
    theme: Themes.DATA_TYPES,
    question: "Какой/какие из вариантов приведет к ошибке?",
    code: "const emojis = ['🎄', '🎅🏼', '🎁', '⭐'];\n\n/* 1 */ emojis.push('🦌');\n/* 2 */ emojis.splice(0, 2);\n/* 3 */ emojis = [...emojis, '🥂'];\n/* 4 */ emojis.length = 0;",
    correctAnswer: 4,
    variants: ["1", "1 и 2", "3 и 4", "3"],
    explanation:
      "Ключевое слово `const` просто означает, что мы не можем _повторно объявить_ значение этой переменной, оно доступно только для чтения. Однако само значение не является неизменным. Свойства массива `emojis` можно изменить, например, добавив новые значения, объединив их или установив длину массива на 0.",
    id: 143,
  },
  {
    grade: Grades.Middle,
    theme: Themes.DATA_TYPES,
    question:
      'Что нам нужно добавить к объекту `person`, чтобы получить `["Lydia Hallie", 21]` в качестве вывода `[...person]`?',
    code: 'const person = {\n  name: "Lydia Hallie",\n  age: 21\n}\n\n[...person] // ["Lydia Hallie", 21]',
    correctAnswer: 3,
    variants: [
      "Ничего, объекты итерируется по умолчанию",
      "`*[Symbol.iterator]() { for (let x in this) yield* this[x] }`",
      "`*[Symbol.iterator]() { yield* Object.values(this) }`",
      "`*[Symbol.iterator]() { for (let x in this) yield this }`",
    ],
    explanation:
      'По умолчанию объекты не являются итерируемыми. Итерируемым объект становится, если присутствует протокол итератора. Мы можем добавить это вручную, добавив символ итератора `[Symbol.iterator]`, который должен возвращать объект-генератор, например, сделав его функцией-генератором `*[Symbol.iterator]() {}`. Эта функция-генератор должна возвращать `Object.values` объекта `person`, если мы хотим, чтобы он возвращал массив `["Lydia Hallie", 21]`: `yield* Object.values(this)`.',
    id: 144,
  },
  {
    grade: Grades.Junior,
    theme: Themes.BASICS,
    question: "Что будет на выходе?",
    code: "let count = 0;\nconst nums = [0, 1, 2, 3];\n\nnums.forEach(num => {\n\tif (num) count += 1\n})\n\nconsole.log(count)",
    correctAnswer: 3,
    variants: ["1", "2", "3", "4"],
    explanation:
      "Условие `if` внутри цикла `forEach` проверяет, является ли значение `num` истинным или ложным. Поскольку первое число в массиве `nums` равно `0`, то есть ложное значение, блок оператора `if` не будет выполнен. `count` увеличивается только для остальных 3 чисел в массиве `nums`: `1`, `2` и `3`. Поскольку `count` увеличивается на 1 3 раза, значение `count` равно `3`.",
    id: 145,
  },
  {
    grade: Grades.Middle,
    theme: Themes.ECMASCRIPT,
    question: "Что будет на выходе?",
    code: "function getFruit(fruits) {\n\tconsole.log(fruits?.[1]?.[1])\n}\n\ngetFruit([['🍊', '🍌'], ['🍍']])\ngetFruit()\ngetFruit([['🍍'], ['🍊', '🍌']])",
    correctAnswer: 4,
    variants: [
      "`null`, `undefined`, 🍌",
      "`[]`, `null`, 🍌",
      "`[]`, `[]`, 🍌",
      "`undefined`, `undefined`, 🍌",
    ],
    explanation:
      "`?` позволяет нам дополнительно получить доступ к более глубоким вложенным свойствам внутри объектов. Мы пытаемся зарегистрировать элемент с индексом `1` в подмассиве с индексом `1` массива `fruits`. Если подмассив с индексом `1` в массиве `fruits` не существует, он просто вернет `undefined`. Если подмассив с индексом `1` в массиве `fruits` существует, но в этом подмассиве нет элемента с индексом `1`, он также вернет значение `undefined`.\n\nВо-первых, мы пытаемся зарегистрировать второй элемент в `['🍍']` подмассива `[['🍊', '🍌'], ['🍍']]`. Этот подмассив содержит только один элемент, что означает, что в индексе `1` нет элемента, и возвращает значение `undefined`.\n\nЗатем мы вызываем функцию `getFruits` без передачи значения в качестве аргумента, что означает, что `fruits` по умолчанию имеет значение `undefined`. Поскольку мы условно связываем элемент с индексом `1` массива `fruits`, он возвращает значение `undefined`, поскольку этот элемент с индексом `1` не существует.\n\nНаконец, мы попытаемся зарегистрировать второй элемент в `['🍊', '🍌']` подмассива `['🍍'], ['🍊', '🍌']`. Элемент с индексом `1` в этом подмассиве — `🍌`, который регистрируется.",
    id: 146,
  },
  {
    grade: Grades.Middle,
    theme: Themes.CLASSES,
    question: "Что будет на выходе?",
    code: "class Calc {\n\tconstructor() {\n\t\tthis.count = 0 \n\t}\n\n\tincrease() {\n\t\tthis.count ++\n\t}\n}\n\nconst calc = new Calc()\nnew Calc().increase()\n\nconsole.log(calc.count)",
    correctAnswer: 1,
    variants: ["`0`", "`1`", "`undefined`", "`ReferenceError`"],
    explanation:
      "Мы устанавливаем переменную `calc` равной новому экземпляру класса `Calc`. Затем мы создаем экземпляр нового экземпляра `Calc` и вызываем метод увеличения для этого экземпляра. Поскольку свойство `count` находится в конструкторе класса `Calc`, свойство `count` не используется в прототипе `Calc`. Это означает, что значение `count` не было обновлено для экземпляра, на который указывает `calc`, `count` по-прежнему равен `0`.",
    id: 147,
  },
  {
    grade: Grades.Middle,
    theme: Themes.OBJECTS,
    question: "Что будет на выходе?",
    code: 'const user = {\n\temail: "e@mail.com",\n\tpassword: "12345"\n}\n\nconst updateUser = ({ email, password }) => {\n\tif (email) {\n\t\tObject.assign(user, { email })\n\t}\n\n\tif (password) {\n\t\tuser.password = password\n\t}\n\n\treturn user\n}\n\nconst updatedUser = updateUser({ email: "new@email.com" })\n\nconsole.log(updatedUser === user)',
    correctAnswer: 2,
    variants: ["`false`", "`true`", "`TypeError`", "`ReferenceError`"],
    explanation:
      "Функция `updateUser` обновляет значения свойств `email` и `password` у пользователя, если их значения переданы в функцию, после чего функция возвращает объект `user`. Возвращаемое значение функции `updateUser` — это объект `user`, что означает, что значение `updatedUser` является ссылкой на тот же объект `user`, на который указывает `user`. `updatedUser === user` равно `true`.",
    id: 148,
  },
  {
    grade: Grades.Junior,
    theme: Themes.DATA_TYPES,
    question: "Что будет на выходе?",
    code: "const fruit = ['🍌', '🍊', '🍎']\n\nfruit.slice(0, 1)\nfruit.splice(0, 1)\nfruit.unshift('🍇')\n\nconsole.log(fruit)",
    correctAnswer: 3,
    variants: [
      "`['🍌', '🍊', '🍎']`",
      "`['🍊', '🍎']`",
      "`['🍇', '🍊', '🍎']`",
      "`['🍇', '🍌', '🍊', '🍎']`",
    ],
    explanation:
      "Во-первых, мы вызываем метод `slice` для массива фруктов. Метод `slice` не изменяет исходный массив, а возвращает значение, которое было вырезано из массива: банановый смайлик.\nЗатем мы вызываем метод `splice` для массива фруктов. Метод `splice` изменяет исходный массив, что означает, что массив фруктов теперь состоит из `['🍊', '🍎']`.\nНаконец, мы вызываем метод `unshift` для массива `fruit`, который изменяет исходный массив, добавляя предоставленное значение, в данном случае `🍇`, в качестве первого элемента в массиве. Массив фруктов теперь состоит из `['🍇', '🍊', '🍎']`.",
    id: 149,
  },
  {
    grade: Grades.Junior,
    theme: Themes.DATA_TYPES,
    question: "Что будет на выходе?",
    code: "const animals = {};\nlet dog = { emoji: '🐶' }\nlet cat = { emoji: '🐈' }\n\nanimals[dog] = { ...dog, name: \"Mara\" }\nanimals[cat] = { ...cat, name: \"Sara\" }\n\nconsole.log(animals[dog])",
    correctAnswer: 2,
    variants: [
      '`{ emoji: "🐶", name: "Mara" }`',
      '`{ emoji: "🐈", name: "Sara" }`',
      "`undefined`",
      "`ReferenceError`",
    ],
    explanation:
      'Ключи объекта преобразуются в строки.\n\nПоскольку значение `dog` является объектом, `animals[dog]` на самом деле означает, что мы создаем новое свойство под названием `"object Object"`, равное новому объекту. `animals["object Object"]` теперь равно `{ emoji: "🐶", name: "Mara"}`.\n\n`cat` также является объектом, что означает, что `animals[cat]` на самом деле означает, что мы перезаписываем значение `animals["object Object"]` новыми свойствами кота.\n\nРегистрация `animals[dog]`, или фактически `animals["object Object"]`, поскольку преобразование объекта `dog` в строку приводит к `"object Object"`, возвращает `{ emoji: "🐈", name: " Сара"}`.',
    id: 150,
  },
  {
    grade: Grades.Junior,
    theme: Themes.OBJECTS,
    question: "Что будет на выходе?",
    code: 'const user = {\n\temail: "my@email.com",\n\tupdateEmail: email => {\n\t\tthis.email = email\n\t}\n}\n\nuser.updateEmail("new@email.com")\nconsole.log(user.email)',
    correctAnswer: 1,
    variants: [
      "`my@email.com`",
      "`new@email.com`",
      "`undefined`",
      "`ReferenceError`",
    ],
    explanation:
      "Функция `updateEmail` представляет собой стрелочную функцию и не привязана к объекту пользователя. Это означает, что ключевое слово `this` не относится к объекту `user`, а в данном случае относится к глобальной области видимости. Значение `email` в объекте `user` не обновляется. При регистрации значения `user.email` возвращается исходное значение `my@email.com`.",
    id: 151,
  },
  {
    grade: Grades.Junior,
    theme: Themes.ASYNC,
    question: "Что будет на выходе?",
    code: "const promise1 = Promise.resolve('First')\nconst promise2 = Promise.resolve('Second')\nconst promise3 = Promise.reject('Third')\nconst promise4 = Promise.resolve('Fourth')\n\nconst runPromises = async () => {\n\tconst res1 = await Promise.all([promise1, promise2])\n\tconst res2  = await Promise.all([promise3, promise4])\n\treturn [res1, res2]\n}\n\nrunPromises()\n\t.then(res => console.log(res))\n\t.catch(err => console.log(err))",
    correctAnswer: 4,
    variants: [
      "`[['First', 'Second'], ['Fourth']]`",
      "`[['First', 'Second'], ['Third', 'Fourth']]`",
      "`[['First', 'Second']]`",
      "`'Third'`",
    ],
    explanation:
      'Метод `Promise.all` выполняет переданные промисы параллельно. Если одно обещание не выполняется, метод `Promise.all` _отколняется_ со значением отклоненного обещания. В этом случае `promise3` отклонен со значением `"Third"`. Мы перехватываем отклоненное значение в цепочке методов `catch` при вызове `runPromises`, чтобы перехватывать любые ошибки внутри функции `runPromises`. Только `"Third"` регистрируется, так как `promise3` отклонено с этим значением.',
    id: 152,
  },
  {
    grade: Grades.Junior,
    theme: Themes.OBJECTS,
    question:
      'Каким должно быть значение `method` для регистрации `{ name: "Lydia", age: 22 }`?',
    code: 'const keys = ["name", "age"]\nconst values = ["Lydia", 22]\n\nconst method = /* ?? */\nObject[method](keys.map((_, i) => {\n\treturn [keys[i], values[i]]\n})) // { name: "Lydia", age: 22 }',
    correctAnswer: 3,
    variants: ["`entries`", "`values`", "`fromEntries`", "`forEach`"],
    explanation:
      'Метод `fromEntries` превращает двумерный массив в объект. Первый элемент в каждом подмассиве будет ключом, а второй элемент в каждом подмассиве будет значением. В этом случае мы сопоставляем массив `keys`, который возвращает массив, первый элемент которого является элементом массива ключей текущего индекса, а второй элемент является элементом массива значений текущего индекса.\n\nЭто создает массив подмассивов, содержащих правильные ключи и значения, что приводит к `{ name: "Lydia", age: 22 }`',
    id: 153,
  },
  {
    grade: Grades.Junior,
    theme: Themes.MISC,
    question: "Что будет на выходе?",
    code: 'const createMember = ({ email, address = {}}) => {\n\tconst validEmail = /.+\\@.+\\..+/.test(email)\n\tif (!validEmail) throw new Error("Valid email pls")\n\n\treturn {\n\t\temail,\n\t\taddress: address ? address : null\n\t}\n}\n\nconst member = createMember({ email: "my@email.com" })\nconsole.log(member)',
    correctAnswer: 3,
    variants: [
      '`{ email: "my@email.com", address: null }`',
      '`{ email: "my@email.com" }`',
      '`{ email: "my@email.com", address: {} }`',
      '`{ email: "my@email.com", address: undefined }`',
    ],
    explanation:
      "Значением по умолчанию для `address` является пустой объект `{}`. Когда мы устанавливаем переменную `member` равной объекту, возвращаемому функцией `createMember`, мы не передаем значение для адреса, что означает, что значение адреса является пустым объектом по умолчанию `{}`. Пустой объект является истинным значением, что означает, что условие `address ? address : null` условно возвращает `true`. Значением адреса является пустой объект `{}`.",
    id: 154,
  },
  {
    grade: Grades.Junior,
    theme: Themes.DATA_TYPES,
    question: "Что будет на выходе?",
    code: 'let randomValue = { name: "Lydia" }\nrandomValue = 23\n\nif (!typeof randomValue === "string") {\n\tconsole.log("It\'s not a string!")\n} else {\n\tconsole.log("Yay it\'s a string!")\n}',
    correctAnswer: 2,
    variants: [
      "`It's not a string!`",
      "`Yay it's a string!`",
      "`TypeError`",
      "`undefined`",
    ],
    explanation:
      'Условие в операторе `if` проверяет, равно ли значение `!typeof randomValue` "строке". Оператор `!` преобразует значение в логическое значение. Если значение истинно, возвращаемое значение будет "ложным", если значение ложным, возвращаемое значение будет "истинным". В этом случае возвращаемое значение `typeof randomValue` является истинным значением `"number"`, что означает, что значение `!typeof randomValue` является логическим значением `false`.\n\n`!typeof randomValue === "string"` всегда возвращает `false`, поскольку на самом деле мы проверяем `false === "string"`. Поскольку условие вернуло `false`, запускается блок кода оператора `else`, и в журнал заносится сообщение `Yay it\'s a string!`.',
    id: 155,
  },
];
export default questions;
