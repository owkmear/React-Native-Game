import { Grades, Themes } from "../../model";

const questions = [
  {
    grade: Grades.Junior,
    theme: Themes.DATA_TYPES,
    question: "Що буде в консолі?",
    code: 'function sayHi() {\n  console.log(name);\n  console.log(age);\n  var name = "Lydia";\n  let age = 21;\n}\n\nsayHi();',
    correctAnswer: 4,
    variants: [
      "`Lydia` та `undefined`",
      "`Lydia` та `ReferenceError`",
      "`ReferenceError` та `21`",
      "`undefined` та `ReferenceError`",
    ],
    explanation:
      'Всередині функції ми спершу визначаємо змінну `name` за допомогою ключового слова `var`. Це означає, що змінна буде знайдена (область пам\'яті під змінну буде виділена під час створення) зі значенням `undefined` за замовчуванням, до тих пір поки виконання коду не дійде до рядка, де визначається змінна. Ми ще не визначили значення `name`, коли намагаємося вивести її в консоль, тому в консолі буде `undefined`.\n\nЗмінні, визначені за допомогою `let` (і `const`), також знаходяться, але на відміну від `var`, не <i>створюються</i>. Доступ до них неможливий до тих пір, поки не виконається рядок їх визначення (ініціалізації). Це називається "тимчасова мертва зона". Коли ми намагаємося звернутися до змінних до того моменту як вони визначені, JavaScript видає `ReferenceError`.',
    id: 1,
  },
  {
    grade: Grades.Middle,
    theme: Themes.ASYNC,
    question: "Що буде в консолі?",
    code: "for (var i = 0; i < 3; i++) {\n  setTimeout(() => console.log(i), 1);\n}\n\nfor (let i = 0; i < 3; i++) {\n  setTimeout(() => console.log(i), 1);\n}",
    correctAnswer: 3,
    variants: [
      "`0 1 2` та `0 1 2`",
      "`0 1 2` та `3 3 3`",
      "`3 3 3` та `0 1 2`",
    ],
    explanation:
      "Через черги подій в JavaScript, функція `setTimeout` викликається _після того_ як цикл буде завершено. Так як змінна `i` в першому циклі була визначена за допомогою `var`, вона буде глобальною. У циклі ми кожен раз збільшуємо значення `i` на `1`, використовуючи унарний оператор `++.` До моменту виконання функції `setTimeout` значення `i` дорівнюватиме `3`, як показано в першому прикладі.\n\nУ другому циклі змінна `i` визначена за допомогою `let`. Такі змінні (а також `const`) мають блочну область видимості (блок це що завгодно між `{}`). З кожною ітерацією `i` матиме нове значення, і кожне значення буде замкнуто в своїй області видимості всередині циклу.",
    id: 2,
  },
  {
    grade: Grades.Junior,
    theme: Themes.OBJECTS,
    question: "Що буде в консолі?",
    code: "const shape = {\n  radius: 10,\n  diameter() {\n    return this.radius * 2;\n  },\n  perimeter: () => 2 * Math.PI * this.radius\n};\n\nshape.diameter();\nshape.perimeter();",
    correctAnswer: 2,
    variants: [
      "`20` та `62.83185307179586`",
      "`20` та `NaN`",
      "`20` та `63`",
      "`NaN` та `63`",
    ],
    explanation:
      "Зауваж, що `diameter` це звичайна функція, в той час як `perimeter` це стрілкова функція.\n\nУ стрілкових функцій значення `this` вказує на навколишню область видимості, на відміну від звичайних функцій! Це означає, що при виклику `perimeter` значення `this` у цій функції вказує не на об'єкт `shape`, а на зовнішню область видимості (наприклад, window).\n\nУ цього об'єкта немає ключа `radius`, тому повертається `undefined`.",
    id: 3,
  },
  {
    grade: Grades.Middle,
    theme: Themes.DATA_TYPES,
    question: "Що буде в консолі?",
    code: '+true;\n!"Lydia";',
    correctAnswer: 1,
    variants: ["`1` та `false`", "`false` та `NaN`", "`false` та `false`"],
    explanation:
      'Унарний плюс призводить операнд до числа. `true` це `1`, а `false` це `0`.\n\nСтрока `\'Lydia\'` це "справжнє" значення. Ми запитуємо "справжнє значення є помилковим"? Відповідь: `false`.',
    id: 4,
  },
  {
    grade: Grades.Junior,
    theme: Themes.OBJECTS,
    question: "Що з цього не є коректним?",
    code: 'const bird = {\n  size: "small"\n};\n\nconst mouse = {\n  name: "Mickey",\n  small: true\n};',
    correctAnswer: 1,
    variants: [
      "`mouse.bird.size` не є коректно",
      "`mouse[bird.size]` не є коректно",
      '`mouse[bird["size"]]` не є коректно',
      "Все варіант коректні",
    ],
    explanation:
      'В JavaScript все ключі об\'єкта є рядками (крім `Symbol`). І хоча ми не _набираємо_ їх як рядки, вони завжди перетворюються до рядків під капотом.\n\nJavaScript інтерпретує (або розпаковує) оператори. При використанні квадратних дужок JS зауважує `[` і продовжує поки не зустріне `]`. Тільки після цього він вирахує то, що знаходиться всередині дужок.\n\n`mouse[bird.size]`: Спершу визначається `bird.size`, що дорівнює `"small"`. `mouse["small"]` повертає `true`.\n\nАле із записом через крапку так не відбувається. У `mouse` немає ключа `bird`. Таким чином, `mouse.bird` дорівнює `undefined`. Потім ми запитуємо ключ `size`, використовуючи крапкову нотацію: `mouse.bird.size`. Так як `mouse.bird` це `undefined`, ми запитуємо `undefined.size`. Це не є дійсним, тому ми отримуємо помилку типу: `Can not read property "size" of undefined`.',
    id: 5,
  },
  {
    grade: Grades.Junior,
    theme: Themes.OBJECTS,
    question: "Що буде в консолі?",
    code: 'let c = { greeting: "Hey!" };\nlet d;\n\nd = c;\nc.greeting = "Hello";\nconsole.log(d.greeting);',
    correctAnswer: 1,
    variants: [
      "`Hello`",
      "`Hey`",
      "`undefined`",
      "`ReferenceError`",
      "`TypeError`",
    ],
    explanation:
      "В JavaScript всі об'єкти є _посилальними_ типами даних.\n\nСпершу змінна `c` вказує на об'єкт. Потім ми вказуємо змінної `d` посилатися на той самий об'єкт, що і `c`.\n\n<img src=\"https://i.imgur.com/ko5k0fs.png\" width=\"200\">\n\nКоли ти змінюєш один об'єкт, то змінюються значення всіх посилань, що вказують на цей об'єкт.",
    id: 6,
  },
  {
    grade: Grades.Middle,
    theme: Themes.DATA_TYPES,
    question: "Що буде в консолі?",
    code: "let a = 3;\nlet b = new Number(3);\nlet c = 3;\n\nconsole.log(a == b);\nconsole.log(a === b);\nconsole.log(b === c);",
    correctAnswer: 3,
    variants: [
      "`true` `false` `true`",
      "`false` `false` `true`",
      "`true` `false` `false`",
      "`false` `true` `true`",
    ],
    explanation:
      "`new Number()` це вбудований конструктор функції. І хоча він виглядає як число, це не справжнє число: у нього є ряд додаткових фіч і це об'єкт.\n\nОператор `==` призводить типи даних до якогось одного і перевіряє рівність _значень_. Обидва значення рівні `3`, тому повертається `true`.\n\nПри використанні оператора `===` значення і тип повинні бути однаковими. Але в нашому випадку це не так: `new Number()` це не число, це **об'єкт**. Тому обидва повертають `false`.",
    id: 7,
  },
  {
    grade: Grades.Middle,
    theme: Themes.CLASSES,
    question: "Яким буде результат?",
    code: 'class Chameleon {\n  static colorChange(newColor) {\n    this.newColor = newColor;\n    return this.newColor;\n  }\n\n  constructor({ newColor = "green" } = {}) {\n    this.newColor = newColor;\n  }\n}\n\nconst freddie = new Chameleon({ newColor: "purple" });\nfreddie.colorChange("orange");',
    correctAnswer: 4,
    variants: ["`orange`", "`purple`", "`green`", "`TypeError`"],
    explanation:
      "Функція `colorChange` є статичною. Статичні методи не мають доступу до екземплярів класу. Так як `freddie` це екземпляр, то статичний метод там не доступний. Тому результатом є помилка `TypeError`.",
    id: 8,
  },
  {
    grade: Grades.Junior,
    theme: Themes.OBJECTS,
    question: "Що буде в консолі?",
    code: "let greeting;\ngreetign = {}; // Typo!\nconsole.log(greetign);",
    correctAnswer: 1,
    variants: [
      "`{}`",
      "`ReferenceError: greetign is not defined`",
      "`undefined`",
    ],
    explanation:
      "В консолі виведеться об'єкт, тому що ми щойно створили порожній об'єкт в глобальному об'єкті! Коли ми замість `greeting` написали `greetign`, інтерпретатор JS насправді виконав `global.greetign = {}` (або `window.greetign = {}` в браузері).\n\nПотрібно використовувати `\"use strict\"`, щоб уникнути такої поведінки. Цей запис допоможе бути впевненим в тому, що змінна була визначена перед тим як їй присвоїли значення.",
    id: 9,
  },
  {
    grade: Grades.Junior,
    theme: Themes.FUNCTIONS,
    question: "Що станеться?",
    code: 'function bark() {\n  console.log("Woof!");\n}\n\nbark.animal = "dog";',
    correctAnswer: 1,
    variants: [
      "Нічого, все ок.",
      "`SyntaxError`. Не можна додавати властивості функцій таким способом.",
      "`undefined`",
      "`ReferenceError`",
    ],
    explanation:
      "В JavaScript це можливо, тому що функції це об'єкти! (Все є об'єктами крім примітивів).\n\nФункція - це спеціальний тип об'єкта, який можна викликати. Крім того, функція - це об'єкт з властивостями. Властивість такого об'єкта не можна викликати, так як воно не є функцією.",
    id: 10,
  },
  {
    grade: Grades.Junior,
    theme: Themes.CLASSES,
    question: "Що буде в консолі?",
    code: 'function Person(firstName, lastName) {\n  this.firstName = firstName;\n  this.lastName = lastName;\n}\n\nconst member = new Person("Lydia", "Hallie");\nPerson.getFullName = function() {\n  return `${this.firstName} ${this.lastName}`;\n};\n\nconsole.log(member.getFullName());\n```\n\n- A: `TypeError`\n- B: `SyntaxError`\n- C: `Lydia Hallie`\n- D: `undefined` `undefined`\n\n<details><summary><b>Відповідь</b></summary>\n<p>\n\n#### Відповідь: A\n\nНе можна додавати властивості конструктору, як звичайному об\'єкту. Якщо потрібно додати фічу до всіх об\'єктів, то необхідно використовувати прототипи. В даному випадку,\n\n```js\nPerson.prototype.getFullName = function() {\n  return `${this.firstName} ${this.lastName}`;\n};',
    correctAnswer: 1,
    variants: [
      "`TypeError`",
      "`SyntaxError`",
      "`Lydia Hallie`",
      "`undefined` `undefined`",
    ],
    explanation:
      "Не можна додавати властивості конструктору, як звичайному об'єкту. Якщо потрібно додати фічу до всіх об'єктів, то необхідно використовувати прототипи. В даному випадку,\n\n```js\nPerson.prototype.getFullName = function() {\n  return `${this.firstName} ${this.lastName}`;\n};\n```\n\nзробить метод `member.getFullName()` чинним. У чому тут перевага? Припустимо, що ми додали цей метод до конструктора. Можливо, не кожному екземпляру `Person` потрібен цей метод. Це призведе до великих втрат пам'яті, тому що всі екземпляри будуть мати цю властивість. Навпаки, якщо ми додамо цей метод тільки до прототипу, у нас буде тільки одне місце в пам'яті, до якого зможуть звертатися всі екземпляри!",
    id: 11,
  },
  {
    grade: Grades.Junior,
    theme: Themes.CLASSES,
    question: "Що буде в консолі?",
    code: 'function Person(firstName, lastName) {\n  this.firstName = firstName;\n  this.lastName = lastName;\n}\n\nconst lydia = new Person("Lydia", "Hallie");\nconst sarah = Person("Sarah", "Smith");\n\nconsole.log(lydia);\nconsole.log(sarah);',
    correctAnswer: 1,
    variants: [
      '`Person {firstName: "Lydia", lastName: "Hallie"}` та `undefined`',
      '`Person {firstName: "Lydia", lastName: "Hallie"}` та `Person {firstName: "Sarah", lastName: "Smith"}`',
      '`Person {firstName: "Lydia", lastName: "Hallie"}` та `{}`',
    ],
    explanation:
      "Для `sarah` ми не використали ключове слово `new`. Використання `new` призводить до створення нового об'єкта. Але без `new` він вказує на **глобальний об'єкт**!\n\nМи вказали, що `this.firstName` дорівнює `\"Sarah\"` і `this.lastName` дорівнює `\"Smith\"`. Насправді ми визначили `global.firstName = 'Sarah'` і `global.lastName = 'Smith'`. `sarah` залишилася `undefined`.",
    id: 12,
  },
  {
    grade: Grades.Junior,
    theme: Themes.EVENTS,
    question: "Назвіть три фази поширення подій",
    code: null,
    correctAnswer: 4,
    variants: [
      "Мета (Target) > Захоплення (Capturing) > Всплиття (Bubbling)",
      "Всплиття (Bubbling) > Мета (Target) > Захоплення (Capturing)",
      "Мета (Target) > Всплиття (Bubbling) > Захоплення (Capturing)",
      "Захоплення (Capturing) > Мета (Target) > Всплиття (Bubbling)",
    ],
    explanation:
      'Під час фази **захоплення** подія поширюється від батьківського елемента до елемента мети. Після досягнення **мети** починається фаза **спливання**.\n\n<img src="https://i.imgur.com/N18oRgd.png" width="200">',
    id: 13,
  },
  {
    grade: Grades.Junior,
    theme: Themes.CLASSES,
    question: "Всі об'єкти мають прототипи?",
    code: null,
    correctAnswer: 2,
    variants: ["Так", "Ні"],
    explanation:
      "Всі об'єкти мають прототипи, крім **базового об'єкта**. Базовий об'єкт має доступ до деяких методів і властивостей, таких як `.toString`. Саме тому ми можемо використовувати вбудовані методи JavaScript! Всі ці методи доступні в прототипі. Якщо JavaScript не може знайти метод безпосередньо у об'єкту, він продовжує пошук по ланцюжку прототипів поки не знайде.",
    id: 14,
  },
  {
    grade: Grades.Junior,
    theme: Themes.DATA_TYPES,
    question: "Результат коду?",
    code: 'function sum(a, b) {\n  return a + b;\n}\n\nsum(1, "2");',
    correctAnswer: 3,
    variants: ["`NaN`", "`TypeError`", '`"12"`', "`3`"],
    explanation:
      'JavaScript це **динамічно тіпізірованна мова**: ми не визначаємо тип змінних. Змінні можуть автоматично бути перетворені з одного типу в інший без нашої участі, що називається _неявним приведенням типів_. **Приведення** це перетворення з одного типу в інший.\n\nУ цьому прикладі, JavaScript конвертувати число `1` в рядок, щоб операція всередині функції мала сенс і повернула значення. Під час складання числа (`1`) і рядки (`\'2\'`) число перетворюється до рядка. Ми можемо додавати рядки ось так: `"Hello" + "World"`. Таким чином, "`1"` + `"2"` повертає "`12"`.',
    id: 15,
  },
  {
    grade: Grades.Middle,
    theme: Themes.BASICS,
    question: "Що буде в консолі?",
    code: "let number = 0;\nconsole.log(number++);\nconsole.log(++number);\nconsole.log(number);",
    correctAnswer: 3,
    variants: ["`1` `1` `2`", "`1` `2` `2`", "`0` `2` `2`", "`0` `1` `2`"],
    explanation:
      "**Постфіксний** унарний оператор `++`:\n\n1. Повертає значення (`0`)\n2. Інкрементує значення (тепер число дорівнює `1`)\n\n**Префіксний** унарний оператор `++`:\n\n1. Інкрементує значення (тепер число дорівнює `2`)\n2. Повертає значення (`2`)\n\nРезультат: `0 2 2`.",
    id: 16,
  },
  {
    grade: Grades.Middle,
    theme: Themes.BASICS,
    question: "Що буде в консолі?",
    code: 'function getPersonInfo(one, two, three) {\n  console.log(one);\n  console.log(two);\n  console.log(three);\n}\n\nconst person = "Lydia";\nconst age = 21;\n\ngetPersonInfo`${person} is ${age} years old`;',
    correctAnswer: 2,
    variants: [
      '`"Lydia"` `21` `["", " is ", " years old"]`',
      '`["", " is ", " years old"]` `"Lydia"` `21`',
      '`"Lydia"` `["", " is ", " years old"]` `21`',
    ],
    explanation:
      "При використанні тегованих шаблонних літералів першим аргументом завжди буде масив строкових значень. Решта аргументів будуть значення мати переданих виразів!",
    id: 17,
  },
  {
    grade: Grades.Middle,
    theme: Themes.BASICS,
    question: "Що буде в консолі?",
    code: 'function checkAge(data) {\n  if (data === { age: 18 }) {\n    console.log("You are an adult!");\n  } else if (data == { age: 18 }) {\n    console.log("You are still an adult.");\n  } else {\n    console.log(`Hmm.. You don\'t have an age I guess`);\n  }\n}\n\ncheckAge({ age: 18 });',
    correctAnswer: 3,
    variants: [
      "`You are an adult!`",
      "`You are still an adult.`",
      "`Hmm.. You don't have an age I guess`",
    ],
    explanation:
      "В операціях порівняння примітиви порівнюються за їх _значенням_, а об'єкти за _посиланнями_. JavaScript перевіряє, щоб об'єкти вказували на одну і ту ж область пам'яті.\n\nПорівнювані об'єкти в нашому прикладі не такі: об'єкт, переданий як параметр, вказує на іншу область пам'яті, ніж об'єкти, що використовуються в порівнянні.\n\nТому `{age: 18} === {age: 18}` і `{age: 18} == {age: 18}` повертають `false`.",
    id: 18,
  },
  {
    grade: Grades.Middle,
    theme: Themes.BASICS,
    question: "Що буде в консолі?",
    code: "function getAge(...args) {\n  console.log(typeof args);\n}\n\ngetAge(21);",
    correctAnswer: 3,
    variants: ['`"number"`', '`"array"`', '`"object"`', '`"NaN"`'],
    explanation:
      'Оператор поширення (`... args`) повертає масив з аргументами. Масив це об\'єкт, тому `typeof args` повертає `"object"`.',
    id: 19,
  },
  {
    grade: Grades.Middle,
    theme: Themes.BASICS,
    question: "Що буде в консолі?",
    code: 'function getAge() {\n  "use strict";\n  age = 21;\n  console.log(age);\n}\n\ngetAge();',
    correctAnswer: 3,
    variants: ["`21`", "`undefined`", "`ReferenceError`", "`TypeError`"],
    explanation:
      'Використовуючи `"use strict"`, можна бути впевненим, що ми помилково не оголосимо глобальні змінні. Ми раніше ніде не оголошували змінну `age`, тому з використанням `"use strict"` виникне ReferenceError. Без використання `"use strict"` помилки не виникне, а змінна `age` додасться в глобальний об\'єкт.',
    id: 20,
  },
  {
    grade: Grades.Middle,
    theme: Themes.BASICS,
    question: "Чому дорівнюватиме sum?",
    code: 'const sum = eval("10*10+5");',
    correctAnswer: 1,
    variants: ["`105`", '`"105"`', "`TypeError`", '`"10*10+5"`'],
    explanation:
      "`eval` виконує код, переданий у вигляді рядка. Якщо це рядок (як в даному випадку), то обчислюється вираз. Вираз `10 * 10 + 5` поверне число `105`.",
    id: 21,
  },
  {
    grade: Grades.Middle,
    theme: Themes.BASICS,
    question: "Як довго буде доступний cool_secret?",
    code: 'sessionStorage.setItem("cool_secret", 123);',
    correctAnswer: 2,
    variants: [
      "Завжди, дані не загубляться.",
      "Поки користувач не закриває вкладку.",
      "Поки користувач не закриє браузер, а не тільки вкладку.",
      "Поки користувач не вимикає комп'ютер.",
    ],
    explanation:
      "Дані, збережені в `sessionStorage` очищаються після закриття _вкладки_.\n\nПри використанні `localStorage` дані зберігаються назавжди. Очистити їх можна, наприклад, використовуючи `localStorage.clear()`.",
    id: 22,
  },
  {
    grade: Grades.Middle,
    theme: Themes.BASICS,
    question: "Що буде в консолі?",
    code: "var num = 8;\nvar num = 10;\n\nconsole.log(num);",
    correctAnswer: 2,
    variants: ["`8`", "`10`", "`SyntaxError`", "`ReferenceError`"],
    explanation:
      "За допомогою ключового слова `var`, можна визначати скільки завгодно змінних з одним і тим же ім'ям. Змінна зберігатиме останнє присвоєне значення.\n\nВи не можете зробити це з `let` або` const`, оскільки вони блочні.",
    id: 23,
  },
  {
    grade: Grades.Middle,
    theme: Themes.BASICS,
    question: "Що буде в консолі?",
    code: 'const obj = { 1: "a", 2: "b", 3: "c" };\nconst set = new Set([1, 2, 3, 4, 5]);\n\nobj.hasOwnProperty("1");\nobj.hasOwnProperty(1);\nset.has("1");\nset.has(1);',
    correctAnswer: 3,
    variants: [
      "`false` `true` `false` `true`",
      "`false` `true` `true` `true`",
      "`true` `true` `false` `true`",
      "`true` `true` `true` `true`",
    ],
    explanation:
      "Всі ключі об'єктів (крім `Symbols`) є рядками, навіть якщо задано не в вигляді рядків. Тому `obj.hasOwnProperty('1')` так само повертає `true`.\n\nАле це не працює для `set`. Значення `\"1\"` немає в `set`: `set.has ('1')`, тому повертається `false`. Але `set.has(1)` поверне `true`.",
    id: 24,
  },
  {
    grade: Grades.Middle,
    theme: Themes.BASICS,
    question: "Що буде в консолі?",
    code: 'const obj = { a: "one", b: "two", a: "three" };\nconsole.log(obj);',
    correctAnswer: 3,
    variants: [
      '`{ a: "one", b: "two" }`',
      '`{ b: "two", a: "three" }`',
      '`{ a: "three", b: "two" }`',
      "`SyntaxError`",
    ],
    explanation:
      "Якщо є два ключі з однаковим ім'ям, то ключ буде перезаписаний. Його позиція збережеться, але значенням буде встановлено останнім.",
    id: 25,
  },
  {
    grade: Grades.Middle,
    theme: Themes.BASICS,
    question:
      "Глобальний контекст виконання створює дві речі: глобальний об'єкт і this",
    code: null,
    correctAnswer: 1,
    variants: ["Так", "Ні", "В залежності від ситуації"],
    explanation:
      "Базовий контекст виконання це глобальний контекст виконання: це те, що є де завгодно в твоєму коді.",
    id: 26,
  },
  {
    grade: Grades.Middle,
    theme: Themes.BASICS,
    question: "Що буде в консолі?",
    code: "for (let i = 1; i < 5; i++) {\n  if (i === 3) continue;\n  console.log(i);\n}",
    correctAnswer: 3,
    variants: ["`1` `2`", "`1` `2` `3`", "`1` `2` `4`", "`1` `3` `4`"],
    explanation:
      "Оператор `continue` пропускає ітерацію, якщо умова повертає `true`.",
    id: 27,
  },
  {
    grade: Grades.Middle,
    theme: Themes.BASICS,
    question: "Яким буде результат?",
    code: 'String.prototype.giveLydiaPizza = () => {\n  return "Just give Lydia pizza already!";\n};\n\nconst name = "Lydia";\n\nname.giveLydiaPizza();',
    correctAnswer: 1,
    variants: [
      '`"Just give Lydia pizza already!"`',
      "`TypeError: not a function`",
      "`SyntaxError`",
      "`undefined`",
    ],
    explanation:
      "`String` це вбудований конструктор, до якого можна додавати властивості. Я додала метод до його прототипу. Рядки-примітиви автоматично конвертуються до рядків-об'єктів. Тому всі рядки (строкові об'єкти) мають доступ до цього методу!",
    id: 28,
  },
  {
    grade: Grades.Middle,
    theme: Themes.BASICS,
    question: "Що буде в консолі?",
    code: 'const a = {};\nconst b = { key: "b" };\nconst c = { key: "c" };\n\na[b] = 123;\na[c] = 456;\n\nconsole.log(a[b]);',
    correctAnswer: 2,
    variants: ["`123`", "`456`", "`undefined`", "`ReferenceError`"],
    explanation:
      'Ключі об\'єкта автоматично конвертуються в рядки. Ми збираємося додати об\'єкт в якості ключа до об\'єкта `a` зі значенням `123`.\n\nПроте, коли ми наводимо об\'єкт до рядка, він стає `"[object Object]"`. Таким чином, ми говоримо, що `a["object Object"] = 123`. Потім ми робимо те ж саме. `c` це інший об\'єкт, який ми неявно наводимо до рядка. Тому `a["object Object"] = 456`.\n\nПотім, коли ми виводимо `a[b]`, ми маємо на увазі `a["object Object"]`. Ми тільки що встановили туди значення `456`, тому в результаті отримуємо `456`.',
    id: 29,
  },
  {
    grade: Grades.Middle,
    theme: Themes.BASICS,
    question: "Яким буде результат?",
    code: 'const foo = () => console.log("First");\nconst bar = () => setTimeout(() => console.log("Second"));\nconst baz = () => console.log("Third");\n\nbar();\nfoo();\nbaz();',
    correctAnswer: 2,
    variants: [
      "`First` `Second` `Third`",
      "`First` `Third` `Second`",
      "`Second` `First` `Third`",
      "`Second` `Third` `First`",
    ],
    explanation:
      'Ми викликаємо функцію `setTimeout` першою. Тим не менш, вона виводиться в консоль останньою.\n\nЦе відбувається через те, що в браузерах у нас є не тільки рантайм движок, але і `WebAPI`. `WebAPI` надає нам функцію `setTimeout` і багато інших можливостей. Наприклад, DOM.\n\nПісля того як _коллбек_ відправлений в `WebAPI`, функція `setTimeout` (але не коллбек!) виймається з стека.\n\n<img src="https://i.imgur.com/X5wsHOg.png" width="200">\n\nТепер викликається `foo`, і `"First"` виводиться в консоль.\n\n<img src="https://i.imgur.com/Pvc0dGq.png" width="200">\n\n`foo` дістається з стека, і викликається `baz`. `"Third"` виводиться в консоль.\n\n<img src="https://i.imgur.com/WhA2bCP.png" width="200">\n\n`WebAPI` не може додавати вміст в стек коли захоче. Замість цього він відправляє коллбек-функцію в так звану _чергу_.\n\n<img src="https://i.imgur.com/NSnDZmU.png" width="200">\n\nТут на сцену виходить цикл подій (event loop). **Event loop** перевіряє стек і черга завдань. Якщо стек порожній, то він бере перший елемент з черги і відправляє його в стек.\n\n<img src="https://i.imgur.com/uyiScAI.png" width="200">\n\nВикликається `bar`, в консоль виводиться `"Second"` і ця функція дістається з стека.',
    id: 30,
  },
  {
    grade: Grades.Middle,
    theme: Themes.BASICS,
    question: "Що буде в `event.target` після кліка на кнопку?",
    code: null,
    correctAnswer: 3,
    variants: [
      "Зовнішній `div`",
      "Внутрішній `div`",
      "`button`",
      "Масив з усіма вкладеними елементами",
    ],
    explanation:
      "Метою події є **найглибший** вкладений елемент. Зупинити поширення подій можна за допомогою `event.stopPropagation`",
    id: 31,
  },
  {
    grade: Grades.Middle,
    theme: Themes.BASICS,
    question: "Що буде в консолі після кліка по параграфу?",
    code: null,
    correctAnswer: 1,
    variants: ["`p` `div`", "`div` `p`", "`p`", "`div`"],
    explanation:
      "Після кліка по `p` буде виведено `p` та `div`. У циклі життя події є три фази: **захоплення**, **мета** і **спливання**. За замовчуванням обробники подій виконуються на фазі спливання (якщо не встановлено параметр `useCapture` в `true`). Спливання йде з найглибшого елемента вгору.",
    id: 32,
  },
  {
    grade: Grades.Middle,
    theme: Themes.BASICS,
    question: "Що буде в консолі?",
    code: 'const person = { name: "Lydia" };\n\nfunction sayHi(age) {\n  console.log(`${this.name} is ${age}`);\n}\n\nsayHi.call(person, 21);\nsayHi.bind(person, 21);',
    correctAnswer: 4,
    variants: [
      "`undefined is 21` `Lydia is 21`",
      "`function` `function`",
      "`Lydia is 21` `Lydia is 21`",
      "`Lydia is 21` `function`",
    ],
    explanation:
      "В обох випадках ми передаємо об'єкт, на який буде вказувати `this`. Але `.call` виконується _відразу ж_!\n\n`.bind` повертає _копію_ функції, але з прив'язаним контекстом. Вона не виконується негайно.",
    id: 33,
  },
  {
    grade: Grades.Middle,
    theme: Themes.BASICS,
    question: "Яким буде результат?",
    code: "function sayHi() {\n  return (() => 0)();\n}\n\ntypeof sayHi();",
    correctAnswer: 2,
    variants: ['`"object"`', '`"number"`', '`"function"`', '`"undefined"`'],
    explanation:
      'Функція `sayHi` повертає значення, що повертається з _негайно викликаного функціонального вираза_ (IIFE). Результатом є `0` типу `"number"`.\n\nДля інформації: в JS 7 вбудованих типів: `null`, `undefined`, `boolean`, `number`, `string`, `object`, `symbol`, та `bigint`. `"Function"` не є окремим типом, тому що функції є об\'єктами типу `"object"`.',
    id: 34,
  },
  {
    grade: Grades.Middle,
    theme: Themes.BASICS,
    question: 'Які з цих значень є "помилковими"?',
    code: '0;\nnew Number(0);\n("");\n(" ");\nnew Boolean(false);\nundefined;',
    correctAnswer: 1,
    variants: [
      "`0`, `''`, `undefined`",
      "`0`, `new Number(0)`, `''`, `new Boolean(false)`, `undefined`",
      "`0`, `''`, `new Boolean(false)`, `undefined`",
      "Всі значення.",
    ],
    explanation:
      'Є тільки шість "помилкових" значень:\n\n- `undefined`\n- `null`\n- `NaN`\n- `0`\n- `\'\'` (порожній рядок)\n- `false`\n\nКонструктори функцій, такі як new `Number` та `new Boolean` є "істинними".',
    id: 35,
  },
  {
    grade: Grades.Middle,
    theme: Themes.BASICS,
    question: "Що буде в консолі?",
    code: "console.log(typeof typeof 1);",
    correctAnswer: 2,
    variants: ['`"number"`', '`"string"`', '`"object"`', '`"undefined"`'],
    explanation:
      '`typeof 1` повертає `"number"`.\n`typeof "number"` повертає `"string"`',
    id: 36,
  },
  {
    grade: Grades.Middle,
    theme: Themes.BASICS,
    question: "Що буде в консолі?",
    code: "const numbers = [1, 2, 3];\nnumbers[10] = 11;\nconsole.log(numbers);",
    correctAnswer: 3,
    variants: [
      "`[1, 2, 3, 7 x null, 11]`",
      "`[1, 2, 3, 11]`",
      "`[1, 2, 3, 7 x empty, 11]`",
      "`SyntaxError`",
    ],
    explanation:
      'Коли в масив додається значення, яке виходить за межі довжини масиву, JavaScript створює так звані "порожні клітинки". Насправді вони мають значення `undefined`, але в консолі виводяться так:\n\n`[1, 2, 3, 7 x empty, 11]`\n\nв залежності від місця використання (може відрізнятися для браузерів, Node, і т.д.).',
    id: 37,
  },
  {
    grade: Grades.Middle,
    theme: Themes.BASICS,
    question: "Що буде в консолі?",
    code: "(() => {\n  let x, y;\n  try {\n    throw new Error();\n  } catch (x) {\n    (x = 1), (y = 2);\n    console.log(x);\n  }\n  console.log(x);\n  console.log(y);\n})();",
    correctAnswer: 1,
    variants: [
      "`1` `undefined` `2`",
      "`undefined` `undefined` `undefined`",
      "`1` `1` `2`",
      "`1` `undefined` `undefined`",
    ],
    explanation:
      "Блок `catch` отримує аргумент `x`. Це не той же `x`, який визначено в якості змінної перед рядком `try`.\n\nПотім ми присвоюємо даному аргументу значення `1` та встановлюємо значення для змінної `y`. Потім виводимо в консоль значення аргументу `x`, що дорівнює `1`.\n\nЗа межами блоку `catch` змінна `x` все ще `undefined`, а `y` дорівнює `2`. Коли ми викликаємо` console.log(x)` за межами блоку `catch`, цей виклик повертає `undefined`, а `y` повертає `2`.",
    id: 38,
  },
  {
    grade: Grades.Middle,
    theme: Themes.BASICS,
    question: "Все в JavaScript це...",
    code: null,
    correctAnswer: 1,
    variants: [
      "примітив або об'єкт",
      "функція або об'єкт",
      "питання з підступом! тільки об'єкти",
      "число або об'єкт",
    ],
    explanation:
      "В JavaScript є тільки примітиви і об'єкти.\n\nТипи примітивів: `boolean`, `null`, `undefined`, `bigint`, `number`, `string`, та `symbol`.\n\nВідмінністю примітиву від об'єкта є те, що примітиви не мають властивостей або методів. Проте, `'foo'.toUpperCase()` перетворюється в `'FOO'` та не викликає `TypeError`. Це відбувається тому, що при спробі отримання властивості або методу у примітиву (наприклад, рядки), JavaScript неявно оберне примітив об'єктом, використовуючи один з класів-обгорток (наприклад, `String`), а потім відразу ж знищить обгортку після обчислення виразу. Всі примітиви крім `null` та `undefined` поводяться таким чином.",
    id: 39,
  },
  {
    grade: Grades.Middle,
    theme: Themes.BASICS,
    question: "Що буде в консолі?",
    code: "[[0, 1], [2, 3]].reduce(\n  (acc, cur) => {\n    return acc.concat(cur);\n  },\n  [1, 2]\n);",
    correctAnswer: 3,
    variants: [
      "`[0, 1, 2, 3, 1, 2]`",
      "`[6, 1, 2]`",
      "`[1, 2, 0, 1, 2, 3]`",
      "`[1, 2, 6]`",
    ],
    explanation:
      "`[1, 2]` - початкове значення, з яким ініціалізується змінна `acc`. Після першого проходу `acc` дорівнюватиме `[1,2]`, а `cur` буде `[0,1]`. Після конкатенації результат буде `[1, 2, 0, 1]`.\n\nПотім `acc` дорівнює `[1, 2, 0, 1]`, а cur `[2, 3]`. Після злиття отримаємо `[1, 2, 0, 1, 2, 3]`.",
    id: 40,
  },
  {
    grade: Grades.Middle,
    theme: Themes.BASICS,
    question: "Що буде в консолі?",
    code: '!!null;\n!!"";\n!!1;',
    correctAnswer: 2,
    variants: [
      "`false` `true` `false`",
      "`false` `false` `true`",
      "`false` `true` `true`",
      "`true` `true` `false`",
    ],
    explanation:
      '`null` "НЕправдивий". `!null` повертає `true`. `!true` повертає `false`.\n\n`""` "НЕправдивий". `!""` повертає `true`. `!true` повертає `false`.\n\n`1` "правдивий". `!1` повертає `false`. `!false` повертає `true`.',
    id: 41,
  },
  {
    grade: Grades.Middle,
    theme: Themes.BASICS,
    question: "Що повертає метод `setInterval`?",
    code: 'setInterval(() => console.log("Hi"), 1000);',
    correctAnswer: 1,
    variants: [
      "унікальний id",
      "вказану кількість мілісекунд",
      "передану функцію",
      "`undefined`",
    ],
    explanation:
      "Цей метод повертає унікальний id, який може бути використаний для очищення інтервалу за допомогою функції `clearInterval()`.",
    id: 42,
  },
  {
    grade: Grades.Middle,
    theme: Themes.BASICS,
    question: "What does this return?",
    code: '[..."Lydia"];',
    correctAnswer: 1,
    variants: [
      '`["L", "y", "d", "i", "a"]`',
      '`["Lydia"]`',
      '`[[], "Lydia"]`',
      '`[["L", "y", "d", "i", "a"]]`',
    ],
    explanation:
      "Рядок є ітерабельною сутністю. Оператор поширення перетворює кожен символ в окремий елемент.",
    id: 43,
  },
];
export default questions;
