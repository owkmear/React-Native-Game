import { Grades, Themes } from "../../model";

const questions = [
  {
    grade: Grades.Junior,
    theme: Themes.DATA_TYPES,
    question: "Qual è l'output?",
    code: "function sayHi() {\n  console.log(name);\n  console.log(age);\n  var name = 'Lydia';\n  let age = 21;\n}\n\nsayHi();",
    correctAnswer: 4,
    variants: [
      "`Lydia` e `undefined`",
      "`Lydia` e `ReferenceError`",
      "`ReferenceError` e `21`",
      "`undefined` e `ReferenceError`",
    ],
    explanation:
      "All'interno della funzione, dichiariamo prima la variabile `name` con la parola chiave `var`. Ciò significa che la variabile viene sollevata all'interno del codice (ovvero lo spazio di memoria viene impostato durante la fase di creazione) e viene inizializzata con il valore predefinito di `undefined`, finché non arriviamo effettivamente alla riga in cui la definiamo. \nAl momento in cui proviamo ad eseguire il log della variabile `name` non l'abbiamo ancora dichiarata, quindi mantiene il valore di `undefined`. \n\nLe variabili dichiarate con la chiave `let` (o `const`) vengono sollevate, ma a differenza delle variabili dichiarate con `var`, non vengono _inizializzate_. Per questo motivo non sono accessibili prima della loro dichiarazione (dove le inizializzaimo). Questa è chiamata \"temporal dead zone\". Quando proviamo ad accedere alle variabili prima che vengano dichiarate, JavaScript genera un `ReferenceError`.",
    id: 1,
  },
  {
    grade: Grades.Middle,
    theme: Themes.ASYNC,
    question: "Qual è l'output?",
    code: "for (var i = 0; i < 3; i++) {\n  setTimeout(() => console.log(i), 1);\n}\n\nfor (let i = 0; i < 3; i++) {\n  setTimeout(() => console.log(i), 1);\n}",
    correctAnswer: 3,
    variants: ["`0 1 2` e `0 1 2`", "`0 1 2` e `3 3 3`", "`3 3 3` e `0 1 2`"],
    explanation:
      "A causa della coda degli eventi in JavaScript la funzione di callback `setTimeout` viene chiamata _dopo_ che il loop è stato eseguito. Poiché la variabile `i` nel primo loop è stata dichiarata usando la chiave `var`, questo valore è globale. Durante il loop abbiamo incrementato ogni volta il valore di `i` di `1` usando l'operatore unario `++`. Quando è stata invocata la funzione di callback `setTimeout`, `i` nel primo esempio risultava sin dal principio uguale a `3`.\n\nNel secondo loop, la variabile `i` è stata dichiarata usando la chiave `let`: le variabili dichiarate con la chiave `let` (e `const`) hanno lo scope del blocco (un blocco è qualsiasi cosa tra `{ }`). Durante ogni iterazione, `i` avrà un nuovo valore e ogni valore avrà lo scope all'interno del loop.",
    id: 2,
  },
  {
    grade: Grades.Junior,
    theme: Themes.OBJECTS,
    question: "Qual è l'output?",
    code: "const shape = {\n  radius: 10,\n  diameter() {\n    return this.radius * 2;\n  },\n  perimeter: () => 2 * Math.PI * this.radius,\n};\n\nconsole.log(shape.diameter());\nconsole.log(shape.perimeter());",
    correctAnswer: 2,
    variants: [
      "`20` e `62.83185307179586`",
      "`20` e `NaN`",
      "`20` e `63`",
      "`NaN` e `63`",
    ],
    explanation:
      "Il valore di `diameter` è una funzione regolare, mentre il valore di `perimeter` è generato con una arrow function.\n\nNelle arrow functions, la chiave `this` fa riferimento al suo scope interno a differenza delle funzioni regolari. Questo vuol dire che quando richiamiamo `perimeter` non stiamo facendo riferimento all'oggetto shape, ma al suo ambito circostante (ad esempio window).\n\nNon troviamo quindi alcun valore `radius` in quell'oggetto e quindi viene restituito `NaN`.",
    id: 3,
  },
  {
    grade: Grades.Middle,
    theme: Themes.DATA_TYPES,
    question: "Qual è l'output?",
    code: "+true;\n!'Lydia';",
    correctAnswer: 1,
    variants: ["`1` and `false`", "`false` and `NaN`", "`false` and `false`"],
    explanation:
      "Il + unario tenta di convertire un operando in un numero. `true` equivale ad `1` e `false` equivale a `0`.\n\nLa stringa `'Lydia'` è un valore veritiero. Quello che in realtà ci stiamo chiedendo con `!'Lydia'` è \"questo valore veritiero è falso?\". Per cui la risposta è `false`.",
    id: 4,
  },
  {
    grade: Grades.Junior,
    theme: Themes.OBJECTS,
    question: "Quale affermazione è vera?",
    code: "const bird = {\n  size: 'small',\n};\n\nconst mouse = {\n  name: 'Mickey',\n  small: true,\n};",
    correctAnswer: 1,
    variants: [
      "`mouse.bird.size` non è valido",
      "`mouse[bird.size]` non è valido",
      '`mouse[bird["size"]]` non è valido',
      "Sono tutte valide",
    ],
    explanation:
      'In JavaScript, tutte le chiavi degli oggetti sono stringhe (a meno che non sia un simbolo). Anche se potremmo non scriverle come stringhe, vengono sempre convertite come tali.\n\nJavaScript interpreta le istruzioni, quindi quando usiamo la bracket notation, vede la prima parentesi aperta `[` e continua finché non trova la parentesi chiusa `]`. Solo allora valuterà la dichiarazione.\n\nQuando in JavaScript richiamiamo `mouse[bird.size]`: per prima cosa viene valorizzato `bird.size`, che è `"small"`, per JS viene tradotto quindi come `mouse["small"]` che restituisce `true`.\n\nCon l\'utilizzo del punto questo non accade perché `mouse` non ha una chiave chiamata `bird`, e questo significa che `mouse.bird` è `undefined`. Per JavaScript quindi l\'istruzione `mouse.bird.size` viene tradotta con `mouse.undefined.size` che è un valore non valido e che quindi genererà un errore simile a `Cannot read property "size" of undefined`.',
    id: 5,
  },
  {
    grade: Grades.Junior,
    theme: Themes.OBJECTS,
    question: "Qual è l'output?",
    code: "let c = { greeting: 'Hey!' };\nlet d;\n\nd = c;\nc.greeting = 'Hello';\nconsole.log(d.greeting);",
    correctAnswer: 1,
    variants: [
      "`Hello`",
      "`Hey!`",
      "`undefined`",
      "`ReferenceError`",
      "`TypeError`",
    ],
    explanation:
      "In JavaScript, tutti gli oggetti interagiscono per _referenza_.\n\nLa variabile `c` contiene come valore un oggetto. Alla variabile `d` assegniamo come valore il riferimento di `c` che quindi contiene l'oggetto (e non un suo clone).\n\n![Image](https://i.imgur.com/ko5k0fs.png)\n\nQuando modifichi il valore di questo oggetto, lo stai modificando sia per `c`che per `d`, che contiene il suo riferimento.",
    id: 6,
  },
  {
    grade: Grades.Middle,
    theme: Themes.DATA_TYPES,
    question: "Qual è l'output?",
    code: "let a = 3;\nlet b = new Number(3);\nlet c = 3;\n\nconsole.log(a == b);\nconsole.log(a === b);\nconsole.log(b === c);",
    correctAnswer: 3,
    variants: [
      "`true` `false` `true`",
      "`false` `false` `true`",
      "`true` `false` `false`",
      "`false` `true` `true`",
    ],
    explanation:
      "`new Number()` è una funzione costruttore integrata. Nonostante sembri un numero, in realtà non lo è, si tratta infatti di un oggetto con un sacco di funzioni extra.\n\nQuando utilizziamo l'operatore `==`, stiamo verificando solo se il suo _valore_ è uguale. Entrambe le variabili hanno il valore di `3`, quindi il primo log restituisce `true`.\n\nQuando invece utilizziamo l'operatore `===`, stiamo verificando che sia il valore che il tipo di valore siano uguali. `new Number()` non è un numero, è un **oggetto** quindi entrambi i log restituiscono `false`.",
    id: 7,
  },
  {
    grade: Grades.Middle,
    theme: Themes.CLASSES,
    question: "Qual è l'output?",
    code: "class Chameleon {\n  static colorChange(newColor) {\n    this.newColor = newColor;\n    return this.newColor;\n  }\n\n  constructor({ newColor = 'green' } = {}) {\n    this.newColor = newColor;\n  }\n}\n\nconst freddie = new Chameleon({ newColor: 'purple' });\nconsole.log(freddie.colorChange('orange'));",
    correctAnswer: 4,
    variants: ["`orange`", "`purple`", "`green`", "`TypeError`"],
    explanation:
      "La funzione `colorChange` è statica. I metodi statici sono progettati per vivere solo nel costruttore in cui vengono creati e non possono essere passati a nessun figlio o richiamati su istanze di classe. Poiché `freddie` è un'istanza della classe `Chameleon`, la funzione non può essere chiamata su di essa. Viene restituito quindi un errore di tipo `TypeError`.",
    id: 8,
  },
  {
    grade: Grades.Junior,
    theme: Themes.OBJECTS,
    question: "Qual è l'output?",
    code: "let greeting;\ngreetign = {}; // Typo!\nconsole.log(greetign);",
    correctAnswer: 1,
    variants: [
      "`{}`",
      "`ReferenceError: greetign is not defined`",
      "`undefined`",
    ],
    explanation:
      'Il nostro log restituisce un oggetto perché abbiamo appena creato un oggetto vuoto come oggetto globale nel momento in cui per errore abbiamo digitato `greetign` al posto di `greeting`.\n\nIl nostro interprete a quel punto ha letto `global.greetign = {}` (o `window.greetign = {}` se parliamo di un browser).\n\nPer evitare ciò, possiamo usare `"use strict"`. Questo assicura di aver dichiarato una variabile prima di impostarla uguale a qualsiasi cosa.',
    id: 9,
  },
  {
    grade: Grades.Junior,
    theme: Themes.FUNCTIONS,
    question: "Cosa succede se facciamo questo?",
    code: "function bark() {\n  console.log('Woof!');\n}\n\nbark.animal = 'dog';",
    correctAnswer: 1,
    variants: [
      "Niente, va benissimo!",
      "`SyntaxError`. Non è possibile aggiungere proprietà a una funzione in questo modo.",
      '`"Woof"` viene registrato.',
      "`ReferenceError`",
    ],
    explanation:
      "In JavaScript non succede nulla, perché le funzioni sono oggetti! (Tutto tranne i tipi primitivi sono oggetti).\n\nUna funzione è un tipo speciale di oggetto. Il codice che scrivi non è la funzione effettiva. La funzione è un oggetto con delle proprietà e quindi questa proprietà è invocabile.",
    id: 10,
  },
  {
    grade: Grades.Junior,
    theme: Themes.CLASSES,
    question: "Qual è l'output?",
    code: "function Person(firstName, lastName) {\n  this.firstName = firstName;\n  this.lastName = lastName;\n}\n\nconst member = new Person('Lydia', 'Hallie');\nPerson.getFullName = function() {\n  return `${this.firstName} ${this.lastName}`;\n};\n\nconsole.log(member.getFullName());",
    correctAnswer: 1,
    variants: [
      "`TypeError`",
      "`SyntaxError`",
      "`Lydia Hallie`",
      "`undefined` `undefined`",
    ],
    explanation:
      "In JavaScript, le funzioni sono oggetti e quindi il metodo `getFullName` viene aggiunto al costruttore della funzione stessa. Per questo motivo possiamo chiamare `Person.getFullName()`, mentre `member.getFullName` genera un `TypeError`.\n\nSe vuoi che un metodo sia disponibile per tutte le istanze dell'oggetto, devi aggiungerlo alla proprietà del prototipo:\n\n\n```js\nPerson.prototype.getFullName = function() {\n  return `${this.firstName} ${this.lastName}`;\n};\n```",
    id: 11,
  },
  {
    grade: Grades.Junior,
    theme: Themes.CLASSES,
    question: "Qual è l'output?",
    code: "function Person(firstName, lastName) {\n  this.firstName = firstName;\n  this.lastName = lastName;\n}\n\nconst lydia = new Person('Lydia', 'Hallie');\nconst sarah = Person('Sarah', 'Smith');\n\nconsole.log(lydia);\nconsole.log(sarah);",
    correctAnswer: 1,
    variants: [
      '`Person {firstName: "Lydia", lastName: "Hallie"}` and `undefined`',
      '`Person {firstName: "Lydia", lastName: "Hallie"}` and `Person {firstName: "Sarah", lastName: "Smith"}`',
      '`Person {firstName: "Lydia", lastName: "Hallie"}` and `{}`',
      '`Person {firstName: "Lydia", lastName: "Hallie"}` and `ReferenceError`',
    ],
    explanation:
      "Per la const `sarah`, non abbiamo usato la chiave `new`. Quando si usa `new`, `this` si riferisce al nuovo oggetto vuoto che creiamo. Tuttavia, se non aggiungiamo `new`, `this` si riferisce all'**oggetto globale**!\n\nAbbiamo quindi scritto che `this.firstName` equivale a `\"Sarah\"` e `this.lastName` equivale a `\"Smith\"`. Quello che abbiamo effettivamente fatto è definire `global.firstName = 'Sarah'` e `global.lastName = 'Smith'`. La `const` `sarah` viene lasciata come `non definita`, perché non restituiamo un valore dalla funzione `Persona`.",
    id: 12,
  },
  {
    grade: Grades.Junior,
    theme: Themes.EVENTS,
    question: "Quali sono le tre fasi della propagazione degli eventi?",
    code: null,
    correctAnswer: 4,
    variants: [
      "Target > Capturing > Bubbling",
      "Bubbling > Target > Capturing",
      "Target > Bubbling > Capturing",
      "Capturing > Target > Bubbling",
    ],
    explanation:
      "Durante la fase di **capturing**, l'evento passa attraverso gli elementi predecessori fino all'elemento target. Quindi raggiunge l'elemento **target** e inizia il **bubbling**.\n\n![Image](https://i.imgur.com/N18oRgd.png)",
    id: 13,
  },
  {
    grade: Grades.Junior,
    theme: Themes.CLASSES,
    question: "Tutti gli oggetti hanno prototipi.",
    code: null,
    correctAnswer: 2,
    variants: ["true", "false"],
    explanation:
      "Tutti gli oggetti hanno prototipi, ad eccezione dell'**oggetto base**. L'oggetto base è l'oggetto creato dall'utente, o un oggetto creato usando la parola chiave `new`. L'oggetto base ha accesso ad alcuni metodi e proprietà, come `.toString`. Questo è il motivo per cui puoi utilizzare i metodi JavaScript built-in! Tutti questi metodi sono disponibili sul prototype. Quindi, anche se JavaScript non riesce a trovarlo direttamente sul tuo oggetto, scende lungo la chain del prototype e lo trova lì, il che lo rende accessibile anche per l'oggetto creato da te.",
    id: 14,
  },
  {
    grade: Grades.Junior,
    theme: Themes.DATA_TYPES,
    question: "Qual è l'output?",
    code: "function sum(a, b) {\n  return a + b;\n}\n\nsum(1, '2');",
    correctAnswer: 3,
    variants: ["`NaN`", "`TypeError`", '`"12"`', "`3`"],
    explanation:
      'JavaScript è un **linguaggio tipizzato dinamicamente**: non specifichiamo quali tipi siano determinate variabili. I valori possono essere automaticamente convertiti in un altro tipo, questa azione è chiamata _coercizione implicita del tipo_. **Coercizione** è la conversione da un tipo all\'altro.\n\nIn questo esempio, JavaScript converte il numero `1` in una stringa, in modo che la funzione abbia un senso e restituisca un valore. Durante l\'aggiunta di un tipo numerico (`1`) e di un tipo stringa (`\'2\'`), il numero viene trattato come una stringa. Possiamo concatenare stringhe come `"Hello" + "World"`, quindi quello che sta succedendo qui è `"1" + "2"` che restituisce `"12"`.',
    id: 15,
  },
  {
    grade: Grades.Junior,
    theme: Themes.BASICS,
    question: "Qual è l'output?",
    code: "let number = 0;\nconsole.log(number++);\nconsole.log(++number);\nconsole.log(number);",
    correctAnswer: 3,
    variants: ["`1` `1` `2`", "`1` `2` `2`", "`0` `2` `2`", "`0` `1` `2`"],
    explanation:
      "Utilizzando l'operatore unario come **postfisso** `number++` succede che:\n\n1. Restituisce prima il suo valore (`0`)\n2. Subito dopo incrementa il valore di 1 (quindi è ora `1`)\n\nUtilizzando l'operatore unario come **prefisso** `++number` succede che:\n\n1. Incrementa prima il valore (il numero è ora `2`)\n2. Restituisce subito dopo il valore già incrementato (`2`)\n\nQuindi il nostro log sarà  `0 2 2`.",
    id: 16,
  },
  {
    grade: Grades.Junior,
    theme: Themes.FUNCTIONS,
    question: "Qual è l'output?",
    code: "function getPersonInfo(one, two, three) {\n  console.log(one);\n  console.log(two);\n  console.log(three);\n}\n\nconst person = 'Lydia';\nconst age = 21;\n\ngetPersonInfo`${person} is ${age} years old`;",
    correctAnswer: 2,
    variants: [
      '`"Lydia"` `21` `["", " is ", " years old"]`',
      '`["", " is ", " years old"]` `"Lydia"` `21`',
      '`"Lydia"` `["", " is ", " years old"]` `21`',
    ],
    explanation:
      "Utilizzando i template literals, il valore del primo argomento sarà un array di valori della stringa. Gli altri argomenti prenderanno i valori dell'espressione passata.",
    id: 17,
  },
  {
    grade: Grades.Junior,
    theme: Themes.OBJECTS,
    question: "Qual è l'output?",
    code: "function checkAge(data) {\n  if (data === { age: 18 }) {\n    console.log('You are an adult!');\n  } else if (data == { age: 18 }) {\n    console.log('You are still an adult.');\n  } else {\n    console.log(`Hmm.. You don't have an age I guess`);\n  }\n}\n\ncheckAge({ age: 18 });",
    correctAnswer: 3,
    variants: [
      "`You are an adult!`",
      "`You are still an adult.`",
      "`Hmm.. You don't have an age I guess`",
    ],
    explanation:
      "Quando si verifica l'uguaglianza, i primitivi vengono confrontati in base al loro _valore_, mentre gli oggetti vengono confrontati in base al loro _riferimento_. JavaScript controlla se gli oggetti hanno un riferimento alla stessa posizione in memoria.\n\nI due oggetti che stiamo confrontando non lo hanno: l'oggetto che abbiamo passato come parametro si riferisce a una posizione di memoria diversa rispetto all'oggetto che abbiamo usato per verificare l'uguaglianza.\n\nQuesto è il motivo per cui sia `{ age: 18 } === { age: 18 }` e `{ age: 18 } == { age: 18 }` restituiscono `false`.",
    id: 18,
  },
  {
    grade: Grades.Junior,
    theme: Themes.FUNCTIONS,
    question: "Qual è l'output?",
    code: "function getAge(...args) {\n  console.log(typeof args);\n}\n\ngetAge(21);",
    correctAnswer: 3,
    variants: ['`"number"`', '`"array"`', '`"object"`', '`"NaN"`'],
    explanation:
      'Il parametro rest (`...args`) ci permette di "collettare" tutti gli argomenti in un array. L\'array è un oggetto, quindi `typeof args` restituisce `"oggetto"`',
    id: 19,
  },
  {
    grade: Grades.Junior,
    theme: Themes.BASICS,
    question: "Qual è l'output?",
    code: "function getAge() {\n  'use strict';\n  age = 21;\n  console.log(age);\n}\n\ngetAge();",
    correctAnswer: 3,
    variants: ["`21`", "`undefined`", "`ReferenceError`", "`TypeError`"],
    explanation:
      'Con `"use strict"`, puoi assicurarti di non dichiarare variabili globali per sbaglio. In questo caso la variabile `age` non è mai stata dichiarata, e siccome usiamo `"use strict"`, genererà un `ReferenceError`. Se non avessimo usato `"use strict"`, avrebbe funzionato perché la proprietà `age` sarebbe stata aggiunta all\'oggetto globale.',
    id: 20,
  },
  {
    grade: Grades.Junior,
    theme: Themes.BASICS,
    question: "Qual è il valore di `sum`?",
    code: "const sum = eval('10*10+5');",
    correctAnswer: 1,
    variants: ["`105`", '`"105"`', "`TypeError`", '`"10*10+5"`'],
    explanation:
      "`eval` \"valuta\" i codici passati come stringa. Se è un'espressione, come in questo caso, valuta l'espressione. L'espressione è `10 * 10 + 5`. Quindi il valore restituito è il numero `105`.",
    id: 21,
  },
  {
    grade: Grades.Junior,
    theme: Themes.STORAGE,
    question: "Per quanto tempo cool_secret è accessibile?",
    code: "sessionStorage.setItem('cool_secret', 123);",
    correctAnswer: 2,
    variants: [
      "Per sempre, i dati non vanno persi.",
      "Fin quando l'utente chiude la scheda.",
      "Fin quando l'utente chiude l'intero browser, non solo la scheda.",
      "Fin quando l'utente spegne il proprio computer.",
    ],
    explanation:
      "I dati memorizzati in `sessionStorage` vengono rimossi dopo aver chiuso la _tab_.\n\nSe avessi usato `localStorage`, i dati sarebbero rimasti lì per sempre, a meno che, ad esempio, non fosse stato invocato `localStorage.clear()`.",
    id: 22,
  },
  {
    grade: Grades.Junior,
    theme: Themes.BASICS,
    question: "Qual è l'output?",
    code: "var num = 8;\nvar num = 10;\n\nconsole.log(num);",
    correctAnswer: 2,
    variants: ["`8`", "`10`", "`SyntaxError`", "`ReferenceError`"],
    explanation:
      "Con la chiave `var` puoi dichiarare più variabili con lo stesso nome. La variabile conterrà quindi l'ultimo valore.\n\nNon puoi farlo con `let` o `const` poiché sono block-scoped.",
    id: 23,
  },
  {
    grade: Grades.Junior,
    theme: Themes.DATA_TYPES,
    question: "Qual è l'output?",
    code: "const obj = { 1: 'a', 2: 'b', 3: 'c' };\nconst set = new Set([1, 2, 3, 4, 5]);\n\nobj.hasOwnProperty('1');\nobj.hasOwnProperty(1);\nset.has('1');\nset.has(1);",
    correctAnswer: 3,
    variants: [
      "`false` `true` `false` `true`",
      "`false` `true` `true` `true`",
      "`true` `true` `false` `true`",
      "`true` `true` `true` `true`",
    ],
    explanation:
      "Tutte le chiavi degli oggetti (esclusi i simboli) sono stringhe, anche se non vengono scritte come tali. Questo è il motivo per cui anche `obj.hasOwnProperty('1')` restituisce true.\n\nPer i set non funziona allo stesso modo degli oggetti. Non c'è alcun `'1'` nel nostro set, per cui `set.has('1')` restituisce `false`, è però presente il tipo numerico `1` per cui `set.has(1)` restituisce `true`.",
    id: 24,
  },
  {
    grade: Grades.Junior,
    theme: Themes.OBJECTS,
    question: "Qual è l'output?",
    code: "const obj = { a: 'one', b: 'two', a: 'three' };\nconsole.log(obj);",
    correctAnswer: 3,
    variants: [
      '`{ a: "one", b: "two" }`',
      '`{ b: "two", a: "three" }`',
      '`{ a: "three", b: "two" }`',
      "`SyntaxError`",
    ],
    explanation:
      "Se hai due chiavi con lo stesso nome, questa verrà sostituita. Sarà quindi ancora nella sua prima posizione, ma con l'ultimo valore specificato.",
    id: 25,
  },
  {
    grade: Grades.Junior,
    theme: Themes.OBJECTS,
    question:
      'Il contesto di esecuzione globale JavaScript crea due cose: l\'oggetto globale e la parola chiave "this".',
    code: null,
    correctAnswer: 1,
    variants: ["true", "false", "it depends"],
    explanation:
      "Il contesto di esecuzione di base è il contesto di esecuzione globale: è ciò che è accessibile ovunque nel codice.",
    id: 26,
  },
  {
    grade: Grades.Junior,
    theme: Themes.BASICS,
    question: "Qual è l'output?",
    code: "for (let i = 1; i < 5; i++) {\n  if (i === 3) continue;\n  console.log(i);\n}",
    correctAnswer: 3,
    variants: ["`1` `2`", "`1` `2` `3`", "`1` `2` `4`", "`1` `3` `4`"],
    explanation:
      "L'istruzione `continue` salta un'iterazione se una certa condizione restituisce `true`.",
    id: 27,
  },
  {
    grade: Grades.Junior,
    theme: Themes.CLASSES,
    question: "Qual è l'output?",
    code: "String.prototype.giveLydiaPizza = () => {\n  return 'Just give Lydia pizza already!';\n};\n\nconst name = 'Lydia';\n\nconsole.log(name.giveLydiaPizza())",
    correctAnswer: 1,
    variants: [
      '`"Just give Lydia pizza already!"`',
      "`TypeError: not a function`",
      "`SyntaxError`",
      "`undefined`",
    ],
    explanation:
      "`String` è un costruttore built-in, a cui possiamo aggiungere proprietà. In questo caso è stato appena aggiunto un metodo al suo prototipo. \nLe stringhe primitive vengono automaticamente convertite in un oggetto stringa, generato dalla string prototype function. Quindi, tutte le stringhe hanno accesso a quel metodo!",
    id: 28,
  },
  {
    grade: Grades.Middle,
    theme: Themes.DATA_TYPES,
    question: "Qual è l'output?",
    code: "const a = {};\nconst b = { key: 'b' };\nconst c = { key: 'c' };\n\na[b] = 123;\na[c] = 456;\n\nconsole.log(a[b]);",
    correctAnswer: 2,
    variants: ["`123`", "`456`", "`undefined`", "`ReferenceError`"],
    explanation:
      'Le chiavi degli oggetti vengono automaticamente convertite in stringhe. Stiamo cercando di impostare un oggetto come chiave per l\'oggetto `a` con il valore di `123`.\n\nTuttavia, quando convertiamo in stringa un oggetto, diventa `"[object Object]"`. Quindi quello che stiamo dicendo qui è che `a["[object Object]"] = 123`. `c` è un altro oggetto che stiamo implicitamente stringendo. Quindi, `a["[object Object]"] = 456`.\n\nQuindi, quando facciamo console.log di `a[b]`, che in realtà è `a["[object Object]"]` che abbiamo appena valorizzato con `456`, restituisce `456`.',
    id: 29,
  },
  {
    grade: Grades.Junior,
    theme: Themes.ASYNC,
    question: "Qual è l'output?",
    code: "const foo = () => console.log('First');\nconst bar = () => setTimeout(() => console.log('Second'));\nconst baz = () => console.log('Third');\n\nbar();\nfoo();\nbaz();",
    correctAnswer: 2,
    variants: [
      "`First` `Second` `Third`",
      "`First` `Third` `Second`",
      "`Second` `First` `Third`",
      "`Second` `Third` `First`",
    ],
    explanation:
      'Abbiamo una funzione `setTimeout` e l\'abbiamo invocata per prima. Eppure, viene loggata per ultima.\n\nQuesto succede perché nei browser non abbiamo solo il runtime engine, ma anche qualcosa chiamata `WebAPI`. La `WebAPI` ci fornisce la funzione `setTimeout` con cui iniziare, e per esempio il DOM.\n\nDopo che la _callback_ è stata inviata alla `WebAPI`, la stessa funzione `setTimeout` (ma non la sua callback) viene eliminata dallo stack.\n\n![Image](https://i.imgur.com/X5wsHOg.png)\n\nOra, `foo` viene invocato e `"First"` viene loggato.\n\n![Image](https://i.imgur.com/Pvc0dGq.png)\n\n`foo` viene quindi tolto dallo stack e `baz` viene invocato. `"Third"` viene loggato.\n\n![Image](https://i.imgur.com/WhA2bCP.png)\n\nLa WebAPI non può semplicemente aggiungere elementi allo stack ogni volta che è pronta, spinge quindi la funzione di callback in quella che chiamiamo _queue_.\n\n![Image](https://i.imgur.com/NSnDZmU.png)\n\nÈ qui che un ciclo di eventi inizia a funzionare. Un **event loop** esamina lo stack e la coda delle attività. Se lo stack è vuoto, prende la prima cosa in coda e la inserisce nello stack.\n\n![Image](https://i.imgur.com/uyiScAI.png)\n\n`bar` viene invocato, `"Second"` viene registrato e viene tolto dallo stack.',
    id: 30,
  },
  {
    grade: Grades.Junior,
    theme: Themes.EVENTS,
    question: "Quale sarà event.target cliccando sul bottone?",
    code: null,
    correctAnswer: 3,
    variants: [
      "`div` esterno",
      "`div` interno",
      "`button`",
      "Un array di tutti gli elementi nidificati",
    ],
    explanation:
      "L'elemento annidato più in profondità è quello che ha causato l'evento ed è quindi l'event.target. Puoi stoppare la propagazione con `event.stopPropagation`",
    id: 31,
  },
  {
    grade: Grades.Junior,
    theme: Themes.EVENTS,
    question: "Cliccando sul paragrafo, quale sarà l'output loggato?",
    code: null,
    correctAnswer: 1,
    variants: ["`p` `div`", "`div` `p`", "`p`", "`div`"],
    explanation:
      "Se clicchiamo su `p`, vediamo due log: `p` e `div`. Durante la propagazione dell'evento, ci sono 3 fasi: capturing, target, e bubbling. Di default, i gestori di eventi vengono eseguiti nella fase di bubbling (a meno che non si imposti `useCapture` su `true`) e va quindi dall'elemento annidato più profondo verso l'esterno.",
    id: 32,
  },
  {
    grade: Grades.Junior,
    theme: Themes.FUNCTIONS,
    question: "Qual è l'output?",
    code: "const person = { name: 'Lydia' };\n\nfunction sayHi(age) {\n  return `${this.name} is ${age}`;\n}\n\nconsole.log(sayHi.call(person, 21));\nconsole.log(sayHi.bind(person, 21));",
    correctAnswer: 4,
    variants: [
      "`undefined is 21` `Lydia is 21`",
      "`function` `function`",
      "`Lydia is 21` `Lydia is 21`",
      "`Lydia is 21` `function`",
    ],
    explanation:
      "Con entrambi possiamo passare l'oggetto a cui vogliamo che la chiave `this` faccia riferimento. Tuttavia, anche `.call` viene _eseguito immediatamente_!\n\n`.bind.` restituisce una _copia_ della funzione, ma con un contesto vincolato! Non viene eseguito immediatamente.",
    id: 33,
  },
  {
    grade: Grades.Junior,
    theme: Themes.FUNCTIONS,
    question: "Qual è l'output?",
    code: "function sayHi() {\n  return (() => 0)();\n}\n\nconsole.log(typeof sayHi());",
    correctAnswer: 2,
    variants: ['`"object"`', '`"number"`', '`"function"`', '`"undefined"`'],
    explanation:
      'La funzione `sayHi` restituisce il valore dato dell\'espressione della immediately invoked function expression (IIFE). Questa funzione ha restituito `0`, che è di tipo `"numero"`.\n\nCi sono solo 7 tipi built-in: `null`, `undefined`, `boolean`, `number`, `string`, `object` e `symbol`. `"function"` non è un tipo, poiché le funzioni sono oggetti, è quindi di tipo "oggetto"`.',
    id: 34,
  },
  {
    grade: Grades.Middle,
    theme: Themes.BASICS,
    question: "Quale di questi valori è falso?",
    code: "0;\nnew Number(0);\n('');\n(' ');\nnew Boolean(false);\nundefined;",
    correctAnswer: 1,
    variants: [
      "`0`, `''`, `undefined`",
      "`0`, `new Number(0)`, `''`, `new Boolean(false)`, `undefined`",
      "`0`, `''`, `new Boolean(false)`, `undefined`",
      "Sono tutti falsi",
    ],
    explanation:
      "Ci sono 8 valori falsi:\n\n- `undefined`\n- `null`\n- `NaN`\n- `false`\n- `''` (empty string)\n- `0`\n- `-0`\n- `0n` (BigInt(0))\n\nI costruttori di funzioni, come `new Number` e `new Boolean` sono veritieri.",
    id: 35,
  },
  {
    grade: Grades.Junior,
    theme: Themes.DATA_TYPES,
    question: "Qual è l'output?",
    code: "console.log(typeof typeof 1);",
    correctAnswer: 2,
    variants: ['`"number"`', '`"string"`', '`"object"`', '`"undefined"`'],
    explanation:
      '`typeof 1` ritorna `"number"`.\n`typeof "number"` ritorna `"string"`',
    id: 36,
  },
  {
    grade: Grades.Junior,
    theme: Themes.BASICS,
    question: "Qual è l'output?",
    code: "const numbers = [1, 2, 3];\nnumbers[10] = 11;\nconsole.log(numbers);",
    correctAnswer: 3,
    variants: [
      "`[1, 2, 3, 7 x null, 11]`",
      "`[1, 2, 3, 11]`",
      "`[1, 2, 3, 7 x empty, 11]`",
      "`SyntaxError`",
    ],
    explanation:
      'Quando imposti un valore su un elemento in un array che supera la lunghezza dell\'array JavaScript crea degli "slot vuoti". Questi in realtà hanno il valore di `undefined`, ma vedrai qualcosa come:\n\n`[1, 2, 3, 7 x empty, 11]`\n\na seconda di dove lo esegui (è diverso per ogni browser, node, ecc.)',
    id: 37,
  },
  {
    grade: Grades.Middle,
    theme: Themes.FUNCTIONS,
    question: "Qual è l'output?",
    code: "(() => {\n  let x, y;\n  try {\n    throw new Error();\n  } catch (x) {\n    (x = 1), (y = 2);\n    console.log(x);\n  }\n  console.log(x);\n  console.log(y);\n})();",
    correctAnswer: 1,
    variants: [
      "`1` `undefined` `2`",
      "`undefined` `undefined` `undefined`",
      "`1` `1` `2`",
      "`1` `undefined` `undefined`",
    ],
    explanation:
      'Il blocco `catch` riceve l\'argomento `x` ma non è la stessa `x` della variabile, bensì passiamo un argomento della funzione. Questa "variabile" `x` è block-scoped quindi ha un ambito di blocco.\n\nSubito dopo impostiamo il valore di variabile block-scoped a `1` e impostiamo il valore della variabile `y`. Ora facciamo un console.log della variabile block-scoped `x`, che è uguale a `1`.\n\nFuori dal blocco `catch`, `x` è ancora `undefined` e `y` è `2` quindi quando facciamo `console.log(x)` al di fuori del blocco `catch`, otterremo `undefined` e `y` restituirà `2`.',
    id: 38,
  },
  {
    grade: Grades.Junior,
    theme: Themes.DATA_TYPES,
    question: "Tutto in JavaScript è...",
    code: null,
    correctAnswer: 1,
    variants: [
      "o un primitivo o un oggetto",
      "o una funzione o un oggetto",
      "Questa è una domanda trabocchetto! Sono solo oggetti",
      "un numero o un oggetto",
    ],
    explanation:
      "JavaScript ha solo tipi primitivi e oggetti.\n\nI tipi primitivi sono `boolean`, `null`, `undefined`, `bigint`, `number`, `string` e `symbol`.\n\nCiò che differenzia un tipo primitivo da un oggetto è che i primitivi non hanno proprietà o metodi. Tuttavia, noterai che `'foo'.toUpperCase()` restituisce `'FOO'` e non genera un `TypeError`. Questo perché quando si tenta di accedere a una proprietà o a un metodo su di un tipo primitivo come lo è una stringa, JavaScript racchiuderà implicitamente il tipo primitivo utilizzando una delle classi wrapper, ovvero \"String\", valuterà l'espressione ed eliminerà il wrapper una volta terminato. Tutti i primitivi tranne `null` e `undefined` subiscono questo comportamento.",
    id: 39,
  },
  {
    grade: Grades.Junior,
    theme: Themes.BASICS,
    question: "Qual è l'output?",
    code: "[[0, 1], [2, 3]].reduce(\n  (acc, cur) => {\n    return acc.concat(cur);\n  },\n  [1, 2],\n);",
    correctAnswer: 3,
    variants: [
      "`[0, 1, 2, 3, 1, 2]`",
      "`[6, 1, 2]`",
      "`[1, 2, 0, 1, 2, 3]`",
      "`[1, 2, 6]`",
    ],
    explanation:
      "`[1, 2]` rappresenta il nostro valore interno. Ovvero il valore con cui iniziamo e il valore del primo `acc`. Durante il primo round, `acc` è `[1,2]` e `cur` è `[0, 1]`. Li concateniamo ottenendo `[1, 2, 0, 1]`.\n\nA questo punto `acc` corrisponderà a `[1, 2, 0, 1]` e `cur` sarà ancora `[2, 3]`. Li concateniamo e otteniamo `[1, 2, 0, 1, 2, 3]`",
    id: 40,
  },
  {
    grade: Grades.Junior,
    theme: Themes.BASICS,
    question: "Qual è l'output?",
    code: "!!null;\n!!'';\n!!1;",
    correctAnswer: 2,
    variants: [
      "`false` `true` `false`",
      "`false` `false` `true`",
      "`false` `true` `true`",
      "`true` `true` `false`",
    ],
    explanation:
      '`null` è falso. `!null` restituisce `true`. `!true` restituisce `false`.\n\n`""` è falso. `!""` restituisce `true`. `!true` restituisce `false`.\n\n`1` è vero. `!1` restituisce `falso`. `!false` restituisce `true`.',
    id: 41,
  },
  {
    grade: Grades.Junior,
    theme: Themes.FUNCTIONS,
    question: "Cosa restituisce il metodo `setInterval` nel browser?",
    code: "setInterval(() => console.log('Hi'), 1000);",
    correctAnswer: 1,
    variants: [
      "un ID univoco",
      "la quantità di millisecondi specificata",
      "la funzione passata",
      "`undefined`",
    ],
    explanation:
      "Restituisce un ID univoco. Questo id può essere usato per cancellare quell'intervallo con la funzione `clearInterval()`.",
    id: 42,
  },
  {
    grade: Grades.Junior,
    theme: Themes.DATA_TYPES,
    question: "Cosa restituisce?",
    code: "[...'Lydia'];",
    correctAnswer: 1,
    variants: [
      '`["L", "y", "d", "i", "a"]`',
      '`["Lydia"]`',
      '`[[], "Lydia"]`',
      '`[["L", "y", "d", "i", "a"]]`',
    ],
    explanation:
      "Una stringa è un iterabile. L'operatore spread mappa ogni carattere di una stringa rendendola parte di array.",
    id: 43,
  },
  {
    grade: Grades.Junior,
    theme: Themes.ASYNC,
    question: "Qual è l'output?",
    code: "function* generator(i) {\n  yield i;\n  yield i * 2;\n}\n\nconst gen = generator(10);\n\nconsole.log(gen.next().value);\nconsole.log(gen.next().value);",
    correctAnswer: 3,
    variants: [
      "`[0, 10], [10, 20]`",
      "`20, 20`",
      "`10, 20`",
      "`0, 10 and 10, 20`",
    ],
    explanation:
      'Le funzioni regolari non possono essere interrotte a metà dopo l\'invocazione. Tuttavia, una funzione "generator" può essere stoppata a metà e in seguito continuare da dove si era interrotta. Ogni volta che una funzione generator incontra una parola chiave `yield`, la funzione restituisce il valore specificato dopo di essa. Nota che la funzione del generator in quel caso non _restituisce (return)_ il valore, _rende (yeld)_ il valore.\n\nCome prima cosa inizializziamo la funzione del generator con `i` uguale a `10`. Invochiamo la funzione usando il metodo `next()`. La prima volta che invochiamo la funzione generator, `i` è uguale a `10`, incontra la prima parola chiave `yield` quindi restituisce il valore di `i`. Il generatore è ora "in pausa" e `10` viene loggato.\n\nInvochiamo di nuovo la funzione con il metodo `next()`. Inizia a continuare da dove si era fermata in precedenza, sempre con `i` uguale a `10`. Ora incontra il secondo `yield` e restituisce `i * 2`, quindi restituisce `10 * 2`, che è `20`. Ciò risulta in `10, 20`.',
    id: 44,
  },
  {
    grade: Grades.Junior,
    theme: Themes.FUNCTIONS,
    question: "Cosa restituisce?",
    code: "const firstPromise = new Promise((res, rej) => {\n  setTimeout(res, 500, 'one');\n});\n\nconst secondPromise = new Promise((res, rej) => {\n  setTimeout(res, 100, 'two');\n});\n\nPromise.race([firstPromise, secondPromise]).then(res => console.log(res));",
    correctAnswer: 2,
    variants: ['`"one"`', '`"two"`', '`"two" "one"`', '`"one" "two"`'],
    explanation:
      "Quando passiamo più promises al metodo `Promise.race`, questo risolve/rifiuta la _prima_ promise. Al metodo `setTimeout` passiamo un timer: 500ms per la prima promise (`firstPromise`) e 100ms per la seconda promise (`secondPromise`). Ciò significa che `secondPromise` si risolve prima con il valore di `'due'`. `res` ora contiene il valore di `'two'`, che viene loggato.",
    id: 45,
  },
  {
    grade: Grades.Junior,
    theme: Themes.OBJECTS,
    question: "Qual è l'output?",
    code: "let person = { name: 'Lydia' };\nconst members = [person];\nperson = null;\n\nconsole.log(members);",
    correctAnswer: 4,
    variants: ["`null`", "`[null]`", "`[{}]`", '`[{ name: "Lydia" }]`'],
    explanation:
      "Per prima cosa, dichiariamo una variabile `person` con un oggetto che ha una proprietà `name`.\n\n![Image](https://i.imgur.com/TML1MbS.png)\n\nQuindi, dichiariamo una variabile chiamata `members`. Impostiamo il primo elemento di quell'array uguale al valore della variabile `person`. Gli oggetti interagiscono per _riferimento_ quando vengono impostati uguali tra loro. Quando assegni un riferimento da una variabile all'altra, esegui una _copia_ di quel riferimento. (nota che non hanno lo _stesso_ riferimento!)\n\n![Image](https://i.imgur.com/FSG5K3F.png)\n\nQuindi, impostiamo la variabile `person` uguale a `null`.\n\n![Image](https://i.imgur.com/sYjcsMT.png)\n\nStiamo modificando solo il valore della variabile `person`, e non il primo elemento nell'array, poiché quell'elemento ha un riferimento diverso (copiato) dall'oggetto. Il primo elemento in `members` mantiene ancora il suo riferimento all'oggetto originale. Quando logghiamo l'array `members`, il primo elemento contiene ancora il valore dell'oggetto, che viene loggato.",
    id: 46,
  },
  {
    grade: Grades.Junior,
    theme: Themes.DATA_TYPES,
    question: "Qual è l'output?",
    code: "const person = {\n  name: 'Lydia',\n  age: 21,\n};\n\nfor (const item in person) {\n  console.log(item);\n}",
    correctAnswer: 2,
    variants: [
      '`{ name: "Lydia" }, { age: 21 }`',
      '`"name", "age"`',
      '`"Lydia", 21`',
      '`["name", "Lydia"], ["age", 21]`',
    ],
    explanation:
      "Con il ciclo `for-in`, possiamo iterare le chiavi degli oggetti, in questo caso `name` e `age`. Le chiavi degli oggetti sono stringhe (se non sono un simbolo). In ogni ciclo, impostiamo il valore di `item` uguale alla chiave corrente su cui sta iterando. Il primo `item` è uguale a `name` e viene loggato, `item` sarà poi uguale a `age`, che viene loggato.",
    id: 47,
  },
  {
    grade: Grades.Junior,
    theme: Themes.BASICS,
    question: "Qual è l'output?",
    code: "console.log(3 + 4 + '5');",
    correctAnswer: 2,
    variants: ['`"345"`', '`"75"`', "`12`", '`"12"`'],
    explanation:
      'L\'associazione è l\'ordine in cui il compilatore valuta le espressioni, da sinistra a destra o da destra a sinistra. Questo accade solo se tutti gli operatori hanno la _stessa_ precedenza. Abbiamo solo un tipo di operatore: `+`. Inoltre, l\'associazione è da sinistra a destra.\n\n`3 + 4` viene valutato per primo. E risulta nell\'addizione dei due valori che restituiscono quindi `7`.\n\n`7 + \'5\'` risulta in `"75"` per via della coercizione. JavaScript converte il numero `7` in una stringa, (vedi la domanda 15). Possiamo concatenare due stringhe usando l\'operatore `+`. `"7" + "5"` risulta quindi in "75"`.',
    id: 48,
  },
  {
    grade: Grades.Junior,
    theme: Themes.DATA_TYPES,
    question: "Qual è il valore di `num`?",
    code: "const num = parseInt('7*6', 10);",
    correctAnswer: 3,
    variants: ["`42`", '`"42"`', "`7`", "`NaN`"],
    explanation:
      'Viene restituito solo il primo valore della stringa. In base alla _radice_ (ovvero il secondo argomento per specificare sulla base di quale tipo di numero vogliamo analizzarlo: base 10, esadecimale, ottale, binario, ecc.), `parseInt` controlla se i caratteri nella stringa sono validi. Una volta che incontra un carattere che non è un numero valido nella radice, interrompe l\'analisi e ignora i seguenti caratteri.\n\n`*` non è un numero valido. Analizza solo `"7"` nel decimale `7`. `num` ora contiene il valore di `7`.',
    id: 49,
  },
  {
    grade: Grades.Junior,
    theme: Themes.DATA_TYPES,
    question: "Qual è l'output?",
    code: "[1, 2, 3].map(num => {\n  if (typeof num === 'number') return;\n  return num * 2;\n});",
    correctAnswer: 3,
    variants: [
      "`[]`",
      "`[null, null, null]`",
      "`[undefined, undefined, undefined]`",
      "`[ 3 x empty ]`",
    ],
    explanation:
      "Quando si esegue il mapping sull'array, il valore di `num` è uguale all'elemento su cui sta attualmente scorrendo. In questo caso, gli elementi sono numeri, quindi la condizione dell'istruzione if `typeof num === \"number\"` restituisce `true`. La funzione map crea un nuovo array e inserisce i valori restituiti dalla funzione.\n\nTuttavia, non ritorniamo un valore. Quando non ritorniamo un valore dalla funzione, la funzione restituisce `undefined`. Per ogni elemento nell'array, viene chiamato il blocco funzione, quindi per ogni elemento restituiamo `undefined`.",
    id: 50,
  },
  {
    grade: Grades.Junior,
    theme: Themes.OBJECTS,
    question: "Qual è l'output?",
    code: "function getInfo(member, year) {\n  member.name = 'Lydia';\n  year = '1998';\n}\n\nconst person = { name: 'Sarah' };\nconst birthYear = '1997';\n\ngetInfo(person, birthYear);\n\nconsole.log(person, birthYear);",
    correctAnswer: 1,
    variants: [
      '`{ name: "Lydia" }, "1997"`',
      '`{ name: "Sarah" }, "1998"`',
      '`{ name: "Lydia" }, "1998"`',
      '`{ name: "Sarah" }, "1997"`',
    ],
    explanation:
      'Gli argomenti vengono passati come _valori_, a meno che il loro valore non sia un oggetto, quindi vengono passati come _reference_. `birthYear` viene passato per valore, poiché è una stringa, non un oggetto. Quando passiamo argomenti per valore, viene creata una _copia_ di quel valore (vedi domanda 46).\n\nLa variabile `birthYear` ha un riferimento al valore `"1997"`. Anche l\'argomento `year` fa riferimento al valore `"1997"`, ma non è lo stesso valore a cui fa riferimento `birthYear`. Quando aggiorniamo il valore di `year` impostando `year` uguale a `"1998"`, stiamo solo aggiornando il valore di `year`. `birthYear` è ancora uguale a `"1997"`.\n\nIl valore di `person` è un oggetto. L\'argomento `member` ha un riferimento (copiato) dello stesso oggetto. Quando modifichiamo una proprietà dell\'oggetto a cui `member` fa riferimento, verrà modificato anche il valore di `person`, poiché entrambi hanno un riferimento allo stesso oggetto. La proprietà `name` di `person` è ora uguale al valore `"Lydia"`',
    id: 51,
  },
  {
    grade: Grades.Junior,
    theme: Themes.ERRORS,
    question: "Qual è l'output?",
    code: "function greeting() {\n  throw 'Hello world!';\n}\n\nfunction sayHi() {\n  try {\n    const data = greeting();\n    console.log('It worked!', data);\n  } catch (e) {\n    console.log('Oh no an error:', e);\n  }\n}\n\nsayHi();",
    correctAnswer: 4,
    variants: [
      "`It worked! Hello world!`",
      "`Oh no an error: undefined`",
      "`SyntaxError: can only throw Error objects`",
      "`Oh no an error: Hello world!`",
    ],
    explanation:
      "Con l'istruzione `throw`, possiamo creare errori personalizzati. Con questa istruzione, puoi generare eccezioni. Un'eccezione può essere una <b>stringa</b>, un <b>numero</b>, un <b>booleano</b> o un <b>oggetto</b>. In questo caso, la nostra eccezione è la stringa `'Hello world!'`.\n\nCon l'istruzione `catch`, possiamo specificare cosa fare se viene generata un'eccezione nel blocco `try`. Viene generata un'eccezione: la stringa `'Hello world!'`. `e` è ora uguale a quella stringa, che logghiamo. Ciò si traduce in `'Oh an error: Hello world!'`.",
    id: 52,
  },
  {
    grade: Grades.Junior,
    theme: Themes.FUNCTIONS,
    question: "Qual è l'output?",
    code: "function Car() {\n  this.make = 'Lamborghini';\n  return { make: 'Maserati' };\n}\n\nconst myCar = new Car();\nconsole.log(myCar.make);",
    correctAnswer: 2,
    variants: [
      '`"Lamborghini"`',
      '`"Maserati"`',
      "`ReferenceError`",
      "`TypeError`",
    ],
    explanation:
      'Quando si restituisce una proprietà, il valore della proprietà è uguale al valore _restituito_, non al valore impostato nella funzione di costruzione. Restituiamo la stringa `"Maserati"`, quindi `myCar.make` è uguale a `"Maserati"`.',
    id: 53,
  },
  {
    grade: Grades.Senior,
    theme: Themes.OBJECTS,
    question: "Qual è l'output?",
    code: "(() => {\n  let x = (y = 10);\n})();\n\nconsole.log(typeof x);\nconsole.log(typeof y);",
    correctAnswer: 1,
    variants: [
      '`"undefined", "number"`',
      '`"number", "number"`',
      '`"object", "number"`',
      '`"number", "undefined"`',
    ],
    explanation:
      '`let x = (y = 10);` in realtà è un\'abbreviazione per:\n\n``` js\ny = 10;\nlet x = y;\n```\n\nQuando impostiamo `y` uguale a `10`, in realtà aggiungiamo una proprietà `y` all\'oggetto globale (`window` nel browser, `global` in Node). In un browser, `window.y` ora è uguale a `10`.\n\nQuindi, dichiariamo una variabile `x` con il valore di `y`, che è `10`. Le variabili dichiarate con la parola chiave `let` sono _block scoped_, ovvero sono definite solo all\'interno del blocco in cui sono dichiarate, l\'espressione di funzione immediatamente invocata (IIFE) in questo caso. Quando utilizziamo l\'operatore `typeof`, l\'operando `x` non è definito: stiamo cercando di accedere a `x` al di fuori del blocco in cui è dichiarato. Ciò significa che `x` non è definito. I valori a cui non è stato assegnato un valore o dichiarati sono di tipo `"undefined"`. `console.log(typeof x)` restituisce `"undefined"`.\n\nTuttavia, abbiamo creato una variabile globale `y` quando abbiamo impostato `y` uguale a `10`. Questo valore è accessibile ovunque nel nostro codice. `y` è definito e contiene un valore di tipo `"number"`. `console.log(typeof y)` restituisce `"number"`.',
    id: 54,
  },
  {
    grade: Grades.Middle,
    theme: Themes.CLASSES,
    question: "Qual è l'output?",
    code: "class Dog {\n  constructor(name) {\n    this.name = name;\n  }\n}\n\nDog.prototype.bark = function() {\n  console.log(`Woof I am ${this.name}`);\n};\n\nconst pet = new Dog('Mara');\n\npet.bark();\n\ndelete Dog.prototype.bark;\n\npet.bark();",
    correctAnswer: 1,
    variants: [
      '`"Woof I am Mara"`, `TypeError`',
      '`"Woof I am Mara"`, `"Woof I am Mara"`',
      '`"Woof I am Mara"`, `undefined`',
      "`TypeError`, `TypeError`",
    ],
    explanation:
      "Possiamo eliminare le proprietà dagli oggetti usando la parola chiave `delete`, anche sul prototype. Eliminando una proprietà sul prototipo, questa non è più disponibile nella catena di prototype. In questo caso, la funzione `bark` non è più disponibile sul prototipo dopo `delete Dog.prototype.bark`, ma proviamo comunque ad accedervi.\n\nQuando proviamo a invocare qualcosa che non è una funzione, viene lanciato un `TypeError`. In questo caso `TypeError: pet.bark is not a function`, poiché `pet.bark` è `undefined`.",
    id: 55,
  },
  {
    grade: Grades.Junior,
    theme: Themes.DATA_TYPES,
    question: "Qual è l'output?",
    code: "const set = new Set([1, 1, 2, 3, 4]);\n\nconsole.log(set);",
    correctAnswer: 4,
    variants: [
      "`[1, 1, 2, 3, 4]`",
      "`[1, 2, 3, 4]`",
      "`{1, 1, 2, 3, 4}`",
      "`{1, 2, 3, 4}`",
    ],
    explanation:
      "L'oggetto `Set` è una collezione di valori _unici_: un valore può verificarsi solo una volta in un set.\n\nAbbiamo passato l'array `[1, 1, 2, 3, 4]` con il valore duplicato `1`. Poiché non possiamo avere due valori uguali in un set, uno di essi viene rimosso. Ciò risulta in `{1, 2, 3, 4}`.",
    id: 56,
  },
  {
    grade: Grades.Middle,
    theme: Themes.MODULES,
    question: "Qual è l'output?",
    code: "// counter.js\nlet counter = 10;\nexport default counter;",
    correctAnswer: 3,
    variants: ["`10`", "`11`", "`Error`", "`NaN`"],
    explanation:
      "Un modulo importato è di _sola lettura_: non è quindi possibile modificare il modulo importato. Solo il modulo che li esporta può cambiarne il valore.\n\nQuando proviamo ad incrementare il valore di `myCounter`, viene generato un errore: perché `myCounter` è di sola lettura e non può essere modificato.",
    id: 57,
  },
  {
    grade: Grades.Junior,
    theme: Themes.OBJECTS,
    question: "Qual è l'output?",
    code: "const name = 'Lydia';\nage = 21;\n\nconsole.log(delete name);\nconsole.log(delete age);",
    correctAnswer: 1,
    variants: [
      "`false`, `true`",
      '`"Lydia"`, `21`',
      "`true`, `true`",
      "`undefined`, `undefined`",
    ],
    explanation:
      "L'operatore `delete` restituisce un valore booleano: `true` su una cancellazione riuscita, altrimenti restituirà `false`. Tuttavia, le variabili dichiarate con la parola chiave `var`, `const` o `let` non possono essere cancellate usando l'operatore `delete`.\n\nLa variabile `name` è stata dichiarata con la chiave `const`, quindi la sua cancellazione non va a buon fine e viene restituito `false`. Quando impostiamo `age` uguale a `21`, abbiamo effettivamente aggiunto una proprietà chiamata `age` all'oggetto globale. Puoi eliminare con successo le proprietà dagli oggetti in questo modo, anche l'oggetto globale, quindi `delete age` restituisce `true`.",
    id: 58,
  },
  {
    grade: Grades.Junior,
    theme: Themes.BASICS,
    question: "Qual è l'output?",
    code: "const numbers = [1, 2, 3, 4, 5];\nconst [y] = numbers;\n\nconsole.log(y);",
    correctAnswer: 3,
    variants: ["`[[1, 2, 3, 4, 5]]`", "`[1, 2, 3, 4, 5]`", "`1`", "`[1]`"],
    explanation:
      "Possiamo spacchettare i valori da un array o proprietà dagli oggetti attraverso la destrutturazione. Per esempio:\n\n``` js\n[a, b] = [1, 2];\n```\n\n![Image](https://i.imgur.com/ADFpVop.png)\n\nIl valore di `a` ora è `1`, e il valore di `b` è ora `2`. Quello che abbiamo effettivamente fatto nella domanda è:\n\n``` js\n[y] = [1, 2, 3, 4, 5];\n```\n\n![Image](https://i.imgur.com/NzGkMNk.png)\n\nQuesto significa che il valore di `y` è uguale al primo valore nell'array, che è il numero `1`. Quando registriamo `y`, viene restituito `1`.",
    id: 59,
  },
  {
    grade: Grades.Junior,
    theme: Themes.DATA_TYPES,
    question: "Qual è l'output?",
    code: "const user = { name: 'Lydia', age: 21 };\nconst admin = { admin: true, ...user };\n\nconsole.log(admin);",
    correctAnswer: 2,
    variants: [
      '`{ admin: true, user: { name: "Lydia", age: 21 } }`',
      '`{ admin: true, name: "Lydia", age: 21 }`',
      '`{ admin: true, user: ["Lydia", 21] }`',
      "`{ admin: true }`",
    ],
    explanation:
      "È possibile combinare oggetti utilizzando l'operatore spread `...`. Questo ti consente di creare copie delle coppie chiave/valore di un oggetto e aggiungerle a un altro oggetto. In questo caso, creiamo copie dell'oggetto `user` e le aggiungiamo all'oggetto `admin`. L'oggetto `admin` ora contiene le coppie chiave/valore copiate, che risultano in `{ admin: true, name: \"Lydia\", age: 21 }`.",
    id: 60,
  },
  {
    grade: Grades.Junior,
    theme: Themes.OBJECTS,
    question: "Qual è l'output?",
    code: "const person = { name: 'Lydia' };\n\nObject.defineProperty(person, 'age', { value: 21 });\n\nconsole.log(person);\nconsole.log(Object.keys(person));",
    correctAnswer: 2,
    variants: [
      '`{ name: "Lydia", age: 21 }`, `["name", "age"]`',
      '`{ name: "Lydia", age: 21 }`, `["name"]`',
      '`{ name: "Lydia"}`, `["name", "age"]`',
      '`{ name: "Lydia"}`, `["age"]`',
    ],
    explanation:
      'Con il metodo `defineProperty`, possiamo aggiungere nuove proprietà a un oggetto o modificare quelle esistenti. Quando aggiungiamo delle proprietà a un oggetto usando il metodo `defineProperty`, queste per impostazione predefinita sono _non enumerabili_. Il metodo `Object.keys` restituisce tutti i nomi di proprietà _enumerabili_ da un oggetto, in questo caso solo `"name"`.\n\nLe proprietà aggiunte usando il metodo `defineProperty` sono immutabili per impostazione predefinita. Puoi ignorare questo comportamento usando le proprietà `writable`, `configurable` ed `enumerable`. In questo modo, il metodo `defineProperty` ti dà molto più controllo sulle proprietà che stai aggiungendo a un oggetto.',
    id: 61,
  },
  {
    grade: Grades.Junior,
    theme: Themes.DATA_TYPES,
    question: "Qual è l'output?",
    code: "const settings = {\n  username: 'lydiahallie',\n  level: 19,\n  health: 90,\n};\n\nconst data = JSON.stringify(settings, ['level', 'health']);\nconsole.log(data);",
    correctAnswer: 1,
    variants: [
      '`"{"level":19, "health":90}"`',
      '`"{"username": "lydiahallie"}"`',
      '`"["level", "health"]"`',
      '`"{"username": "lydiahallie", "level":19, "health":90}"`',
    ],
    explanation:
      'Il secondo argomento di `JSON.stringify` è _replacer_. Il replacer può essere una funzione o un array e consente di controllare cosa e come i valori devono essere stringati.\n\nSe il replacer è un _array_, solo i nomi delle proprietà inclusi nell\'array verranno aggiunti alla stringa JSON. In questo caso, sono incluse solo le proprietà con i nomi `"level"` e `"health"`, `"username"` è esclusa. `data` quindi ora è uguale a `"{"level":19, "health":90}"`.\n\nSe il replacer è una _funzione_, questa funzione viene chiamata su ogni proprietà nell\'oggetto che stai stringendo. Il valore restituito da questa funzione sarà il valore della proprietà quando viene aggiunto alla stringa JSON. Se il valore è `undefined`, questa proprietà viene esclusa dalla stringa JSON.',
    id: 62,
  },
  {
    grade: Grades.Middle,
    theme: Themes.FUNCTIONS,
    question: "Qual è l'output?",
    code: "let num = 10;\n\nconst increaseNumber = () => num++;\nconst increasePassedNumber = number => number++;\n\nconst num1 = increaseNumber();\nconst num2 = increasePassedNumber(num1);\n\nconsole.log(num1);\nconsole.log(num2);",
    correctAnswer: 1,
    variants: ["`10`, `10`", "`10`, `11`", "`11`, `11`", "`11`, `12`"],
    explanation:
      "L'operatore unario `++` _prima_ restituisce il valore dell'operando, _poi_ incrementa il valore dell'operando. Il valore di `num1` è `10`, poiché la funzione `increaseNumber` restituisce prima il valore di `num`, che è `10`, e solo successivamente incrementa il valore di `num`.\n\n`num2` è `10`, poiché abbiamo passato `num1` a `increasePassedNumber`. `number` è uguale a `10` (il valore di `num1`. Anche in questo caso, l'operatore unario `++` _prima_ restituisce il valore dell'operando, _poi_ lo incrementa. Il valore di `number` è ` 10`, quindi `num2` è uguale a `10`.",
    id: 63,
  },
  {
    grade: Grades.Junior,
    theme: Themes.DATA_TYPES,
    question: "Qual è l'output?",
    code: "const value = { number: 10 };\n\nconst multiply = (x = { ...value }) => {\n  console.log((x.number *= 2));\n};\n\nmultiply();\nmultiply();\nmultiply(value);\nmultiply(value);",
    correctAnswer: 3,
    variants: [
      "`20`, `40`, `80`, `160`",
      "`20`, `40`, `20`, `40`",
      "`20`, `20`, `20`, `40`",
      "`NaN`, `NaN`, `20`, `40`",
    ],
    explanation:
      "In ES6, possiamo inizializzare i parametri con un valore predefinito. Il valore del parametro sarà il valore predefinito se nessun altro valore è stato passato alla funzione o se è stato passato un valore `\"undefined\"`. In questo caso, distribuiamo le proprietà dell'oggetto `value` in un nuovo oggetto, quindi `x` ha il valore predefinito di `{ number: 10 }`.\n\nL'argomento predefinito viene valutato quando viene chiamato! Ogni volta che chiamiamo la funzione, viene creato un _nuovo_ oggetto. Invochiamo la funzione `multiply` le prime due volte senza passare un valore, quindi `x` ha il valore predefinito di `{ number: 10 }`. Quindi logghiamo il valore moltiplicato di quel numero, che è `20`.\n\nLa terza volta che invochiamo la funzione multiply, passiamo un argomento: l'oggetto chiamato `value`. L'operatore `*=` è in realtà un'abbreviazione per `x.number = x.number * 2`: modifichiamo il valore di `x.number` e logghiamo il valore moltiplicato `20`.\n\nLa quarta volta, passiamo di nuovo l'oggetto `value`, in questo caso `x.number` è stato precedentemente modificato in `20`, quindi `x.number *= 2` logga `40`.",
    id: 64,
  },
  {
    grade: Grades.Middle,
    theme: Themes.DATA_TYPES,
    question: "Qual è l'output?",
    code: "[1, 2, 3, 4].reduce((x, y) => console.log(x, y));",
    correctAnswer: 4,
    variants: [
      "`1` `2` and `3` `3` and `6` `4`",
      "`1` `2` and `2` `3` and `3` `4`",
      "`1` `undefined` and `2` `undefined` and `3` `undefined` and `4` `undefined`",
      "`1` `2` and `undefined` `3` and `undefined` `4`",
    ],
    explanation:
      "Il primo argomento che il metodo `reduce` riceve è l'_accumulatore_, in questo caso `x`. Il secondo argomento è il _valore corrente_ `y`. \nCon il metodo reduce, eseguiamo una funzione di callback su ogni elemento dell'array, che alla fine potrebbe risultare in un singolo valore.\n\nIn questo esempio, non stiamo restituendo alcun valore, stiamo semplicemente loggando i valori dell'accumulatore e il valore corrente.\n\nIl valore dell'accumulatore è uguale al valore restituito in precedenza dalla funzione di callback. Se non si passa l'argomento opzionale `initialValue` al metodo `reduce`, l'accumulatore è uguale al primo elemento della prima chiamata.\n\nAlla prima chiamata, l'accumulatore (`x`) è `1` e il valore corrente (`y`) è `2`. Non facciamo un return con la funzione di callback ma logghiamo l'accumulatore e il valore corrente: `1` e `2` vengono loggati.\n\nSe non restituisci un valore da una funzione questa restituisce `undefined`. Alla chiamata successiva, l'accumulatore è `undefined` e il valore corrente è \"3\". `undefined` e `3` vengono loggati.\n\nAlla quarta chiamata, di nuovo non facciamo un return dalla funzione di callback. L'accumulatore è di nuovo `undefined` e il valore corrente è \"4\". `undefined` e `4` vengono loggati.",
    id: 65,
  },
  {
    grade: Grades.Junior,
    theme: Themes.CLASSES,
    question: "Con quale costruttore possiamo estendere la classe `Dog`?",
    code: "class Dog {\n  constructor(name) {\n    this.name = name;\n  }\n};\n\nclass Labrador extends Dog {\n  // 1\n  constructor(name, size) {\n    this.size = size;\n  }\n  // 2\n  constructor(name, size) {\n    super(name);\n    this.size = size;\n  }\n  // 3\n  constructor(size) {\n    super(name);\n    this.size = size;\n  }\n  // 4\n  constructor(name, size) {\n    this.name = name;\n    this.size = size;\n  }\n\n};",
    correctAnswer: 2,
    variants: ["1", "2", "3", "4"],
    explanation:
      "In una classe derivata, non puoi accedere alla chiave `this` prima di chiamare `super`. Se provi a farlo, genererà un ReferenceError: 1 e 4 genererebbero un errore di riferimento.\n\nCon la chiave `super`, chiamiamo il costruttore di quella classe parent con gli argomenti forniti. Il costruttore del parent riceve l'argomento `name`, quindi passiamo `name` a `super`.\n\nLa classe `Labrador` riceve due argomenti, `name` poiché estende `Dog`, e `size` come proprietà extra sulla classe `Labrador`. Entrambi devono essere passati alla funzione di costruzione su `Labrador`, cosa che viene eseguita correttamente usando il costruttore 2.",
    id: 66,
  },
  {
    grade: Grades.Middle,
    theme: Themes.MODULES,
    question: "Qual è l'output?",
    code: "// index.js\nconsole.log('running index.js');\nimport { sum } from './sum.js';\nconsole.log(sum(1, 2));\n\n// sum.js\nconsole.log('running sum.js');\nexport const sum = (a, b) => a + b;",
    correctAnswer: 2,
    variants: [
      "`running index.js`, `running sum.js`, `3`",
      "`running sum.js`, `running index.js`, `3`",
      "`running sum.js`, `3`, `running index.js`",
      "`running index.js`, `undefined`, `running sum.js`",
    ],
    explanation:
      "Con la chiave `import` tutti i moduli importati sono _pre-parsed_. Ciò significa che i moduli importati vengono eseguiti _prima_, il codice nel file che importa il modulo viene eseguito _dopo_.\n\nQuesta è una delle differenze tra `require()` in CommonJS e `import`. Con `require()`, puoi caricare le dipendenze su richiesta mentre il codice è in esecuzione. Se avessimo usato `require` invece di `import`, sulla console avremmo loggato `running index.js`, `running sum.js`, `3`.",
    id: 67,
  },
  {
    grade: Grades.Middle,
    theme: Themes.DATA_TYPES,
    question: "Qual è l'output?",
    code: "console.log(Number(2) === Number(2));\nconsole.log(Boolean(false) === Boolean(false));\nconsole.log(Symbol('foo') === Symbol('foo'));",
    correctAnswer: 1,
    variants: [
      "`true`, `true`, `false`",
      "`false`, `true`, `false`",
      "`true`, `false`, `true`",
      "`true`, `true`, `true`",
    ],
    explanation:
      "Ogni Simbolo è unico. Lo scopo dell'argomento passato a Symbol è di dargli una descrizione. Il valore del Symbol non dipende dall'argomento passato. Mentre testiamo l'uguaglianza, stiamo creando due simboli completamente nuovi: il primo `Symbol('foo')` e il secondo `Symbol('foo')`. Questi due valori sono unici e non uguali tra loro, `Symbol('foo') === Symbol('foo')` quindi restituisce `false`.",
    id: 68,
  },
  {
    grade: Grades.Junior,
    theme: Themes.BASICS,
    question: "Qual è l'output?",
    code: "const name = 'Lydia Hallie';\nconsole.log(name.padStart(13));\nconsole.log(name.padStart(2));",
    correctAnswer: 3,
    variants: [
      '`"Lydia Hallie"`, `"Lydia Hallie"`',
      '`" Lydia Hallie"`, `" Lydia Hallie"` (`"[13x whitespace]Lydia Hallie"`, `"[2x whitespace]Lydia Hallie"`)',
      '`" Lydia Hallie"`, `"Lydia Hallie"` (`"[1x whitespace]Lydia Hallie"`, `"Lydia Hallie"`)',
      '`"Lydia Hallie"`, `"Lyd"`,',
    ],
    explanation:
      "Con il metodo `padStart`, possiamo aggiungere un riempimento all'inizio di una stringa. Il valore passato a questo metodo è la lunghezza _totale_ della stringa insieme al riempimento. La stringa `\"Lydia Hallie\"` ha una lunghezza di `12`. `name.padStart(13)` inserisce quindi 1 spazio all'inizio della stringa, perché 12 + 1 è 13.\n\nSe l'argomento passato al metodo `padStart` è inferiore alla lunghezza dell'array, non verrà aggiunto alcun riempimento.",
    id: 69,
  },
  {
    grade: Grades.Junior,
    theme: Themes.DATA_TYPES,
    question: "Qual è l'output?",
    code: "console.log('🥑' + '💻');",
    correctAnswer: 1,
    variants: [
      '`"🥑💻"`',
      "`257548`",
      "Una stringa contenente i code points",
      "Errore",
    ],
    explanation:
      'Con l\'operatore `+` puoi concatenare stringhe. In questo caso, stiamo concatenando la stringa `"🥑"` con la stringa `"💻"`, ottenendo `"🥑💻"`.',
    id: 70,
  },
  {
    grade: Grades.Middle,
    theme: Themes.ASYNC,
    question:
      "Come possiamo loggare i valori commentati dopo l'istruzione console.log?",
    code: "function* startGame() {\n  const answer = yield 'Do you love JavaScript?';\n  if (answer !== 'Yes') {\n    return \"Oh wow... Guess we're gone here\";\n  }\n  return 'JavaScript loves you back ❤️';\n}\n\nconst game = startGame();\nconsole.log(/* 1 */); // Do you love JavaScript?\nconsole.log(/* 2 */); // JavaScript loves you back ❤️",
    correctAnswer: 3,
    variants: [
      '`game.next("Yes").value` and `game.next().value`',
      '`game.next.value("Yes")` and `game.next.value()`',
      '`game.next().value` and `game.next("Yes").value`',
      '`game.next.value()` and `game.next.value("Yes")`',
    ],
    explanation:
      'Una funzione generator "mette in pausa" la sua esecuzione quando incontra la parola chiave `yield`. Innanzitutto dobbiamo lasciare che la funzione produca la stringa "Ami JavaScript?", che può essere eseguita chiamando `game.next().value`.\n\nOgni riga viene quindi eseguita, finché non trova la prima chiave `yield`. C\'è una parola chiave `yield` sulla prima riga all\'interno della funzione: l\'esecuzione si interrompe con il primo rendimento! _Questo significa che la variabile `answer` non è ancora definita!_\n\nQuando chiamiamo `game.next("Yes").value`, il precedente `yield` viene sostituito con il valore dei parametri passati alla funzione `next()`, in questo caso `"Yes"`. Il valore della variabile `answer` è ora uguale a `"Yes"`. La condizione dell\'istruzione if restituisce `false` e `JavaScript loves you back ❤️` viene registrato.',
    id: 71,
  },
  {
    grade: Grades.Middle,
    theme: Themes.BASICS,
    question: "Qual è l'output?",
    code: "console.log(String.raw`Hello\\nworld`);",
    correctAnswer: 3,
    variants: [
      "`Hello world!`",
      "`Hello` <br />&nbsp; &nbsp; &nbsp;`world`",
      "`Hello\\nworld`",
      "`Hello\\n` <br /> &nbsp; &nbsp; &nbsp;`world`",
    ],
    explanation:
      '`String.raw` restituisce una stringa in cui gli escape (`\\n`, `\\v`, `\\t` ecc.) vengono ignorati! I backslash possono essere un problema poiché potresti finire con qualcosa del tipo:\n\n`` const path = `C:\\Documents\\Projects\\table.html` ``\n\nIl che risulterebbe in:\n\n`"C:DocumentsProjects able.html"`\n\nCon `String.raw`, il compilatore ignorerebbe semplicemente l\'escape e stamperebbe:\n\n`C:\\Documents\\Projects\\table.html`\n\nIn questo caso, è la stringa `Hello\\nworld` che viene loggata.',
    id: 72,
  },
  {
    grade: Grades.Junior,
    theme: Themes.ASYNC,
    question: "Qual è l'output?",
    code: "async function getData() {\n  return await Promise.resolve('I made it!');\n}\n\nconst data = getData();\nconsole.log(data);",
    correctAnswer: 3,
    variants: [
      '`"I made it!"`',
      '`Promise {<resolved>: "I made it!"}`',
      "`Promise {<pending>}`",
      "`undefined`",
    ],
    explanation:
      'Una funzione asincrona restituisce sempre una promise. L\'`await` deve ancora attendere che la promise si risolva: una promise in sospeso viene restituita quando chiamiamo `getData()` per impostare `data` uguale ad essa.\n\nSe volessimo accedere al valore risolto `"I made it"`, potremmo usare il metodo `.then()` su `data`:\n\n`data.then(res => console.log(res))`\n\nQuesto avrebbe loggato `"I made it!"`',
    id: 73,
  },
  {
    grade: Grades.Middle,
    theme: Themes.DATA_TYPES,
    question: "Qual è l'output?",
    code: "function addToList(item, list) {\n  return list.push(item);\n}\n\nconst result = addToList('apple', ['banana']);\nconsole.log(result);",
    correctAnswer: 2,
    variants: ["`['apple', 'banana']`", "`2`", "`true`", "`undefined`"],
    explanation:
      "Il metodo `.push()` restituisce la _lunghezza_ del nuovo array! \nInizialmente, l'array conteneva un solo elemento (la stringa `\"banana\"`) e aveva una lunghezza di `1`. Dopo aver aggiunto la stringa `\"apple\"` allo stesso array, questo contiene due elementi e ha una lunghezza di `2` \n\nAttraverso la funzione `addToList`, il metodo `push` modifica l'array originale. \nPer restituire l'_array_ dalla funzione invece della _lunghezza dell'array_, serve fare un return di `list` dopo aver inserito l'`item`.",
    id: 74,
  },
  {
    grade: Grades.Middle,
    theme: Themes.OBJECTS,
    question: "Qual è l'output?",
    code: "const box = { x: 10, y: 20 };\n\nObject.freeze(box);\n\nconst shape = box;\nshape.x = 100;\n\nconsole.log(shape);",
    correctAnswer: 2,
    variants: [
      "`{ x: 100, y: 20 }`",
      "`{ x: 10, y: 20 }`",
      "`{ x: 100 }`",
      "`ReferenceError`",
    ],
    explanation:
      "`Object.freeze` rende impossibile aggiungere, rimuovere o modificare le proprietà di un oggetto (a meno che il valore della proprietà non sia un altro oggetto).\n\nQuando creiamo la variabile `shape` e la impostiamo come all'oggetto congelato `box`, anche `shape` si riferisce ad un oggetto congelato. \nPuoi controllare se un oggetto è congelato usando `Object.isFrozen`. In questo caso, `Object.isFrozen(shape)` restituisce true, poiché la variabile `shape` ha un riferimento a un oggetto congelato.\n\nPoiché `shape` è congelata, e poiché il valore di `x` non è un oggetto, non possiamo modificare la proprietà `x`. \n`x` è ancora uguale a `10` e `{ x: 10, y: 20 }` viene loggato.",
    id: 75,
  },
  {
    grade: Grades.Junior,
    theme: Themes.DATA_TYPES,
    question: "Qual è l'output?",
    code: "const { name: myName } = { name: 'Lydia' };\n\nconsole.log(name);",
    correctAnswer: 3,
    variants: ['`"Lydia"`', '`"myName"`', "`undefined`", "`ReferenceError`"],
    explanation:
      "Quando spacchettiamo la proprietà `name` dall'oggetto, assegniamo il suo valore `\"Lydia\"` a una variabile con il nome `myName`.\n\nCon `{ name: myName }`, diciamo a JavaScript che vogliamo creare una nuova variabile chiamata `myName` con il valore della proprietà `name`.\n\nPoiché proviamo a loggare `name`, una variabile che non è definita, viene restituito `undefined` nell'assegnazione. Successivamente, il valore di `Lydia` viene memorizzato tramite l'assegnazione di destrutturazione.",
    id: 76,
  },
  {
    grade: Grades.Middle,
    theme: Themes.BASICS,
    question: "Questa è una funzione pura?",
    code: "function sum(a, b) {\n  return a + b;\n}",
    correctAnswer: 1,
    variants: ["Yes", "No"],
    explanation:
      "Una funzione pura è una funzione che restituisce _sempre_ lo stesso risultato, se vengono passati gli stessi argomenti.\n\nLa funzione `sum` restituisce sempre lo stesso risultato. Se le passiamo `1` e `2`, restituirà _sempre_ `3` senza effetti collaterali. Se passiamo `5` e `10`, restituirà _sempre_ `15` e così via. Questa è la definizione di funzione pura.",
    id: 77,
  },
  {
    grade: Grades.Middle,
    theme: Themes.FUNCTIONS,
    question: "Qual è l'output?",
    code: "const add = () => {\n  const cache = {};\n  return num => {\n    if (num in cache) {\n      return `From cache! ${cache[num]}`;\n    } else {\n      const result = num + 10;\n      cache[num] = result;\n      return `Calculated! ${result}`;\n    }\n  };\n};\n\nconst addFunction = add();\nconsole.log(addFunction(10));\nconsole.log(addFunction(10));\nconsole.log(addFunction(5 * 2));",
    correctAnswer: 3,
    variants: [
      "`Calculated! 20` `Calculated! 20` `Calculated! 20`",
      "`Calculated! 20` `From cache! 20` `Calculated! 20`",
      "`Calculated! 20` `From cache! 20` `From cache! 20`",
      "`Calculated! 20` `From cache! 20` `Error`",
    ],
    explanation:
      "La funzione `add` è una funzione _memoizzata_. Con la memorizzazione, possiamo memorizzare nella cache i risultati di una funzione per velocizzarne l'esecuzione. \nIn questo caso, creiamo un oggetto `cache` che memorizza i valori precedentemente restituiti.\n\nSe chiamiamo di nuovo la funzione `addFunction` con lo stesso argomento, prima controlla se ha già ottenuto quel valore nella sua cache, in tal caso, verrà restituito il valore della cache, consentendo di risparmiare tempo di esecuzione. Altrimenti, se non è memorizzato nella cache, calcolerà il valore e lo memorizzerà in seguito.\n\nChiamiamo la funzione `addFunction` tre volte con lo stesso valore: alla prima chiamata, il valore della funzione quando `num` è uguale a `10` non è ancora memorizzato nella cache. \nLa condizione dell'istruzione if `num in cache` restituisce `false`, e il blocco else viene eseguito: `Calculated! 20` viene loggato e il valore del risultato viene aggiunto all'oggetto cache. \n`cache` ora è uguale a `{ 10: 20 }`.\n\nLa seconda volta, l'oggetto `cache` contiene il valore che viene restituito per `10`. La condizione dell'istruzione if `num in cache` restituisce `true` e `'From cache! 20'` viene loggato.\n\nLa terza volta, passiamo `5 * 2` alla funzione che viene valutata a `10`. L'oggetto `cache` contiene il valore che viene restituito `10`. La condizione dell'istruzione if `num in cache` restituisce `true` e `'From cache! 20'` viene registrato.",
    id: 78,
  },
  {
    grade: Grades.Junior,
    theme: Themes.DATA_TYPES,
    question: "Qual è l'output?",
    code: "const myLifeSummedUp = ['☕', '💻', '🍷', '🍫'];\n\nfor (let item in myLifeSummedUp) {\n  console.log(item);\n}\n\nfor (let item of myLifeSummedUp) {\n  console.log(item);\n}",
    correctAnswer: 1,
    variants: [
      '`0` `1` `2` `3` and `"☕"` `"💻"` `"🍷"` `"🍫"`',
      '`"☕"` `"💻"` `"🍷"` `"🍫"` and `"☕"` `"💻"` `"🍷"` `"🍫"`',
      '`"☕"` `"💻"` `"🍷"` `"🍫"` and `0` `1` `2` `3`',
      '`0` `1` `2` `3` and `{0: "☕", 1: "💻", 2: "🍷", 3: "🍫"}`',
    ],
    explanation:
      'Con un ciclo _for-in_, possiamo scorrere su proprietà **enumerabili**. In un array, le proprietà enumerabili sono le "chiavi" degli elementi dell\'array, che sono in realtà i loro indici. Potresti immaginare un array come:\n\n`{0: "☕", 1: "💻", 2: "🍷", 3: "🍫"}`\n\nDove le chiavi sono le proprietà enumerabili. `0` `1` `2` `3` viene quindi loggato.\n\nCon un ciclo _for-of_, possiamo iterare su **iterabili**. Un array è un iterabile. Quando iteriamo sull\'array, la variabile "item" è uguale all\'elemento su cui sta attualmente iterando, `"☕"` `"💻"` `"🍷"` `"🍫"` viene loggato.',
    id: 79,
  },
  {
    grade: Grades.Junior,
    theme: Themes.DATA_TYPES,
    question: "Qual è l'output?",
    code: "const list = [1 + 2, 1 * 2, 1 / 2];\nconsole.log(list);",
    correctAnswer: 3,
    variants: [
      '`["1 + 2", "1 * 2", "1 / 2"]`',
      '`["12", 2, 0.5]`',
      "`[3, 2, 0.5]`",
      "`[1, 1, 1]`",
    ],
    explanation:
      "Gli elementi di un array possono contenere qualsiasi valore. Numeri, stringhe, oggetti, altri array, null, booleani, undefined e altre espressioni come date, funzioni e calcoli.\n\nL'elemento sarà uguale al valore restituito. `1 + 2` restituirà quindi `3`, `1 * 2` restituirà `2` e `1 / 2` restituirà `0.5`.",
    id: 80,
  },
  {
    grade: Grades.Junior,
    theme: Themes.FUNCTIONS,
    question: "Qual è l'output?",
    code: "function sayHi(name) {\n  return `Hi there, ${name}`;\n}\n\nconsole.log(sayHi());",
    correctAnswer: 2,
    variants: [
      "`Hi there,`",
      "`Hi there, undefined`",
      "`Hi there, null`",
      "`ReferenceError`",
    ],
    explanation:
      'Di default, gli argomenti hanno il valore di `undefined`, a meno che un valore non sia stato passato alla funzione. In questo caso, non abbiamo passato un valore per l\'argomento `name`. `name` è uguale a `undefined` che viene loggato.\n\nIn ES6, possiamo sovrascrivere questo valore predefinito `undefined` con dei parametri predefiniti. Per esempio:\n\n`function sayHi(name = "Lydia") { ... }`\n\nIn questo caso, se non abbiamo passato un valore o se abbiamo passato `undefined`, `name` sarà sempre uguale alla stringa `Lydia`',
    id: 81,
  },
  {
    grade: Grades.Middle,
    theme: Themes.FUNCTIONS,
    question: "Qual è l'output?",
    code: "var status = '😎';\n\nsetTimeout(() => {\n  const status = '😍';\n\n  const data = {\n    status: '🥑',\n    getStatus() {\n      return this.status;\n    },\n  };\n\n  console.log(data.getStatus());\n  console.log(data.getStatus.call(this));\n}, 0);",
    correctAnswer: 2,
    variants: [
      '`"🥑"` e `"😍"`',
      '`"🥑"` e `"😎"`',
      '`"😍"` e `"😎"`',
      '`"😎"` e `"😎"`',
    ],
    explanation:
      "Il valore della parola chiave `this` dipende da dove la usi. In un **metodo**, come il metodo `getStatus`, la parola chiave `this` si riferisce all'_oggetto a cui appartiene il metodo_. Nel nostro caso il metodo appartiene all'oggetto `data`, quindi `this` si riferisce all'oggetto `data`. Quando logghiamo `this.status`, stiamo chiedendo la proprietà `status` sull'oggetto `data` che è `\"🥑\"`.\n\nCon il metodo `call` possiamo cambiare l'oggetto a cui fa riferimento la parola chiave `this`. Nelle **funzioni**, la parola chiave `this` si riferisce all'_oggetto a cui appartiene la funzione_. Abbiamo dichiarato la funzione `setTimeout` sull'_oggetto globale_, quindi all'interno della funzione `setTimeout`, la parola chiave `this` si riferisce all'_oggetto globale_. Sull'oggetto globale c'è una variabile chiamata _status_ con il valore di `\"😎\"`. Quando si fa un console.log di `this.status`, otteniamo `\"😎\"`.",
    id: 82,
  },
  {
    grade: Grades.Middle,
    theme: Themes.OBJECTS,
    question: "Qual è l'output?",
    code: "const person = {\n  name: 'Lydia',\n  age: 21,\n};\n\nlet city = person.city;\ncity = 'Amsterdam';\n\nconsole.log(person);",
    correctAnswer: 1,
    variants: [
      '`{ name: "Lydia", age: 21 }`',
      '`{ name: "Lydia", age: 21, city: "Amsterdam" }`',
      '`{ name: "Lydia", age: 21, city: undefined }`',
      '`"Amsterdam"`',
    ],
    explanation:
      "Impostiamo la variabile `city` uguale al valore della proprietà chiamata `city` sull'oggetto `person`. Non c'è alcuna proprietà su questo oggetto chiamato `city`, quindi la variabile `city` ha il valore di `undefined`.\n\nNota che _non_ stiamo facendo riferimento all'oggetto `person`! Impostiamo semplicemente la variabile `city` uguale al valore corrente della proprietà `city` sull'oggetto `person`.\n\nQuindi, impostiamo `city` uguale alla stringa `\"Amsterdam\"`. Questo non cambia l'oggetto `person`: non c'è alcun riferimento a quell'oggetto.\n\nQuando si logga l'oggetto `person`, viene restituito l'oggetto non modificato.",
    id: 83,
  },
  {
    grade: Grades.Middle,
    theme: Themes.FUNCTIONS,
    question: "Qual è l'output?",
    code: 'function checkAge(age) {\n  if (age < 18) {\n    const message = "Sorry, you\'re too young.";\n  } else {\n    const message = "Yay! You\'re old enough!";\n  }\n\n  return message;\n}\n\nconsole.log(checkAge(21));',
    correctAnswer: 3,
    variants: [
      '`"Sorry, you\'re too young."`',
      '`"Yay! You\'re old enough!"`',
      "`ReferenceError`",
      "`undefined`",
    ],
    explanation:
      "Le variabili con la chiave `const` e `let` sono _block-scoped_. Un blocco è qualsiasi cosa si trovi tra parentesi graffe (`{ }`). In questo caso, le parentesi graffe delle istruzioni if/else. Non puoi fare riferimento a una variabile al di fuori del blocco in cui è dichiarata, viene quindi generato un ReferenceError.",
    id: 84,
  },
  {
    grade: Grades.Junior,
    theme: Themes.ASYNC,
    question: "Che tipo di informazioni verrebbero loggate?",
    code: "fetch('https://www.website.com/api/user/1')\n  .then(res => res.json())\n  .then(res => console.log(res));",
    correctAnswer: 3,
    variants: [
      "Il risultato del metodo `fetch`.",
      "Il risultato della seconda invocazione del metodo `fetch`.",
      "Il risultato della callback nel precedente `.then()`.",
      "Sarebbe sempre undefined.",
    ],
    explanation:
      "Il valore di `res` nel secondo `.then` è uguale al valore restituito del precedente `.then`. Puoi continuare a concatenare i `.then` in questo modo, dove il valore viene passato al gestore successivo.",
    id: 85,
  },
  {
    grade: Grades.Junior,
    theme: Themes.BASICS,
    question:
      "Quale opzione è un modo per impostare `hasName` uguale a `true`, se non puoi passare `true` come argomento?",
    code: "function getName(name) {\n  const hasName = //\n}",
    correctAnswer: 1,
    variants: ["`!!name`", "`name`", "`new Boolean(name)`", "`name.length`"],
    explanation:
      "Con `!!name`, determiniamo se il valore di `name` è vero o falso. Se il nome è vero, cosa che vogliamo testare, `!name` restituisce `false`. \n`!false` (che è `!!name`) restituisce `true`.\n\nImpostando `hasName` uguale a `name`, imposti `hasName` uguale a qualsiasi valore passato alla funzione `getName`, non il valore booleano `true`.\n\n`new Boolean(true)` restituisce un oggetto wrapper, non il valore booleano stesso.\n\n`name.length` restituisce la lunghezza dell'argomento passato, non se è `true`.",
    id: 86,
  },
  {
    grade: Grades.Junior,
    theme: Themes.DATA_TYPES,
    question: "Qual è l'output?",
    code: "console.log('I want pizza'[0]);",
    correctAnswer: 2,
    variants: ['`"""`', '`"I"`', "`SyntaxError`", "`undefined`"],
    explanation:
      "Per ottenere un carattere in un indice specifico di una stringa, puoi usare la notazione tra parentesi. Il primo carattere nella stringa ha indice 0 e così via. In questo caso, vogliamo ottenere l'elemento con indice 0, il carattere `\"I'`, che viene loggato.\n\nTieni presente che questo metodo non è supportato in IE7 e versioni precedenti. In tal caso, usa `.charAt()`.",
    id: 87,
  },
  {
    grade: Grades.Junior,
    theme: Themes.FUNCTIONS,
    question: "Qual è l'output?",
    code: "function sum(num1, num2 = num1) {\n  console.log(num1 + num2);\n}\n\nsum(10);",
    correctAnswer: 2,
    variants: ["`NaN`", "`20`", "`ReferenceError`", "`undefined`"],
    explanation:
      "È possibile impostare il valore di un parametro predefinito uguale a un altro parametro della funzione, purché sia stato definito _prima_ del parametro predefinito. Passiamo il valore `10` alla funzione `sum`. Se la funzione `sum` riceve solo 1 argomento, significa che il valore di `num2` non è passato e il valore di `num1` è uguale al valore passato `10` in questo caso. Il valore predefinito di `num2` è il valore di `num1`, che è `10`. `num1 + num2` restituisce `20`.\n\nSe stai cercando di impostare il valore di un parametro predefinito uguale a un parametro che è definito _dopo_ (a destra), il valore del parametro non è stato ancora inizializzato, il che genererà un errore.",
    id: 88,
  },
  {
    grade: Grades.Middle,
    theme: Themes.MODULES,
    question: "Qual è l'output?",
    code: "// module.js\nexport default () => 'Hello world';\nexport const name = 'Lydia';\n\n// index.js\nimport * as data from './module';\n\nconsole.log(data);",
    correctAnswer: 1,
    variants: [
      '`{ default: function default(), name: "Lydia" }`',
      "`{ default: function default() }`",
      '`{ default: "Hello world", name: "Lydia" }`',
      "Global object of `module.js`",
    ],
    explanation:
      "Con la sintassi `import * as name`, importiamo _tutte le esportazioni_ dal file `module.js` nel file `index.js` come nuovo oggetto chiamato `data`. Nel file `module.js` ci sono due esportazioni: l'esportazione predefinita e un'esportazione denominata. L'esportazione predefinita è una funzione che restituisce la stringa `\"Hello World\"`, e l'esportazione denominata è una variabile chiamata `name` che ha il valore della stringa `\"Lydia\"`.\n\nL'oggetto `data` ha una proprietà `default` per l'esportazione predefinita, altre proprietà hanno i nomi delle esportazioni e i loro valori corrispondenti.",
    id: 89,
  },
  {
    grade: Grades.Junior,
    theme: Themes.CLASSES,
    question: "Qual è l'output?",
    code: "class Person {\n  constructor(name) {\n    this.name = name;\n  }\n}\n\nconst member = new Person('John');\nconsole.log(typeof member);",
    correctAnswer: 3,
    variants: ['`"class"`', '`"function"`', '`"object"`', '`"string"`'],
    explanation:
      'Le classi sono come caramelle sintattiche. L\'equivalente della classe `Person` come funzione sarebbe:\n\n``` js\nfunction Person() {\n  this.name = name;\n}\n```\n\nInstanziando un costruttore con `new` si ottiene la creazione di un\'istanza di `Person`, la chiave `typeof` restituisce `"object"`. `typeof member` restituisce `"object"`.',
    id: 90,
  },
  {
    grade: Grades.Middle,
    theme: Themes.DATA_TYPES,
    question: "Qual è l'output?",
    code: "let newList = [1, 2, 3].push(4);\n\nconsole.log(newList.push(5));",
    correctAnswer: 4,
    variants: [
      "`[1, 2, 3, 4, 5]`",
      "`[1, 2, 3, 5]`",
      "`[1, 2, 3, 4]`",
      "`Error`",
    ],
    explanation:
      "Il metodo `.push` restituisce la _nuova lunghezza_ dell'array, non l'array stesso! Impostando `newList` uguale a `[1, 2, 3].push(4)`, settiamo `newList` uguale alla nuova lunghezza dell'array: `4`.\n\nQuindi quando proviamo a usare il metodo `.push` su `newList` poiché `newList` è il valore numerico `4`, non possiamo usare il metodo `.push` e viene generato un TypeError.",
    id: 91,
  },
  {
    grade: Grades.Middle,
    theme: Themes.FUNCTIONS,
    question: "Qual è l'output?",
    code: "function giveLydiaPizza() {\n  return 'Here is pizza!';\n}\n\nconst giveLydiaChocolate = () =>\n  \"Here's chocolate... now go hit the gym already.\";\n\nconsole.log(giveLydiaPizza.prototype);\nconsole.log(giveLydiaChocolate.prototype);",
    correctAnswer: 4,
    variants: [
      "`{ constructor: ...}` `{ constructor: ...}`",
      "`{}` `{ constructor: ...}`",
      "`{ constructor: ...}` `{}`",
      "`{ constructor: ...}` `undefined`",
    ],
    explanation:
      "Le funzioni regolari, come la funzione `giveLydiaPizza`, hanno una proprietà `prototipo`, che è un oggetto (prototype object) con un `costruttore`. Tuttavia, le arrow functions, come la funzione `giveLydiaChocolate`, non hanno una proprietà `prototype`. Viene quindi restituito `undefined` quando si tenta di accedere alla proprietà `prototype` usando `giveLydiaChocolate.prototype`.",
    id: 92,
  },
  {
    grade: Grades.Junior,
    theme: Themes.DATA_TYPES,
    question: "Qual è l'output?",
    code: "const person = {\n  name: 'Lydia',\n  age: 21,\n};\n\nfor (const [x, y] of Object.entries(person)) {\n  console.log(x, y);\n}",
    correctAnswer: 1,
    variants: [
      "`name` `Lydia` e `age` `21`",
      '`["name", "Lydia"]` e `["age", 21]`',
      '`["name", "age"]` e `undefined`',
      "`Error`",
    ],
    explanation:
      '`Object.entries(person)` restituisce un array di array nidificati, contenente le chiavi e gli oggetti:\n\n`[ [ \'name\', \'Lydia\' ], [ \'age\', 21 ] ]`\n\nUsando il ciclo `for-of`, possiamo scorrere ogni elemento nell\'array, i sottoarray in questo caso. Possiamo destrutturare i sottoarray istantaneamente nel ciclo for-of, usando `const [x, y]`. `x` è uguale al primo elemento, `y` è uguale al secondo elemento.\n\nIl primo sottoarray è `[ "name", "Lydia" ]`, con `x` uguale a `"name"`, e `y` uguale a `"Lydia"`, che vengono loggati.\nIl secondo sottoarray è `[ "age", 21 ]`, con `x` uguale a `"age"`, e `y` uguale a `21`, che vengono loggati.',
    id: 93,
  },
  {
    grade: Grades.Middle,
    theme: Themes.DATA_TYPES,
    question: "Qual è l'output?",
    code: 'function getItems(fruitList, ...args, favoriteFruit) {\n  return [...fruitList, ...args, favoriteFruit]\n}\n\ngetItems(["banana", "apple"], "pear", "orange")',
    correctAnswer: 4,
    variants: [
      '`["banana", "apple", "pear", "orange"]`',
      '`[["banana", "apple"], "pear", "orange"]`',
      '`["banana", "apple", ["pear"], "orange"]`',
      "`SyntaxError`",
    ],
    explanation:
      "`...args` è un parametro rest. Il valore del parametro rest è un array contenente tutti gli argomenti, **e può essere solo l'ultimo parametro**! In questo esempio, il parametro rest è in seconda posizione. Questo non è possibile e genererà un errore di sintassi.\n\n``` js\nfunction getItems(fruitList, favoriteFruit, ...args) {\n  return [...fruitList, ...args, favoriteFruit];\n}\n\ngetItems(['banana', 'apple'], 'pear', 'orange');\n```\n\nL'esempio qui sopra invece funziona e restituisce l'array `[ 'banana', 'apple', 'orange', 'pear' ]`",
    id: 94,
  },
  {
    grade: Grades.Middle,
    theme: Themes.TRICKS,
    question: "Qual è l'output?",
    code: "function nums(a, b) {\n  if (a > b) console.log('a is bigger');\n  else console.log('b is bigger');\n  return\n  a + b;\n}\n\nconsole.log(nums(4, 2));\nconsole.log(nums(1, 2));",
    correctAnswer: 2,
    variants: [
      "`a is bigger`, `6` and `b is bigger`, `3`",
      "`a is bigger`, `undefined` and `b is bigger`, `undefined`",
      "`undefined` and `undefined`",
      "`SyntaxError`",
    ],
    explanation:
      "In JavaScript, non _è necessario_ scrivere il punto e virgola (`;`) in modo esplicito poiché il motore JavaScript li aggiunge comunque dopo le istruzioni. \nQuesto procedimento è chiamato **Automatic Semicolon Insertion**. Un'istruzione può ad esempio essere una variabile o parole chiave come `throw`, `return`, `break`, ecc.\n\nQui, abbiamo scritto un'istruzione di `return` e un altro valore `a + b` su una _nuova riga_. Tuttavia, trattandosi di una nuova linea, il motore non sa che in realtà è il valore che volevamo restituire. Invece, ha aggiunto automaticamente un punto e virgola dopo `return`. \n\nPotresti considerare ad esempio:\n\n``` js\nreturn;\na + b;\n```\n\n`a + b` non viene mai raggiunto, poiché la funzione smette di funzionare dopo la parola chiave `return`. \nSe non viene restituito alcun valore, come qui, la funzione restituisce `undefined`. Nota: non c'è un inserimento automatico dopo le istruzioni `if/else`!",
    id: 95,
  },
  {
    grade: Grades.Middle,
    theme: Themes.CLASSES,
    question: "Qual è l'output?",
    code: "class Person {\n  constructor() {\n    this.name = 'Lydia';\n  }\n}\n\nPerson = class AnotherPerson {\n  constructor() {\n    this.name = 'Sarah';\n  }\n};\n\nconst member = new Person();\nconsole.log(member.name);",
    correctAnswer: 2,
    variants: [
      '`"Lydia"`',
      '`"Sarah"`',
      "`Error: cannot redeclare Person`",
      "`SyntaxError`",
    ],
    explanation:
      'Possiamo impostare classi uguali ad altre classi/costruttori di funzioni. In questo caso, impostiamo `Person` uguale a `AnotherPerson`. Il name su questo costruttore è `Sarah`, quindi la proprietà del nome di`Person` sulla nuova istanza `member`  è `"Sarah"`.',
    id: 96,
  },
  {
    grade: Grades.Middle,
    theme: Themes.OBJECTS,
    question: "Qual è l'output?",
    code: "const info = {\n  [Symbol('a')]: 'b',\n};\n\nconsole.log(info);\nconsole.log(Object.keys(info));",
    correctAnswer: 4,
    variants: [
      "`{Symbol('a'): 'b'}` e `[\"{Symbol('a')\"]`",
      "`{}` e `[]`",
      '`{ a: "b" }` e `["a"]`',
      "`{Symbol('a'): 'b'}` e `[]`",
    ],
    explanation:
      'Un simbolo non è _enumerabile_. Il metodo Object.keys restituisce tutte le proprietà _enumerabili_ su un oggetto. Il simbolo non sarà visibile e verrà restituito un array vuoto. Quando si logga l\'intero oggetto, tutte le proprietà saranno visibili, anche quelle non enumerabili.\n\nQuesta è una delle tante qualità di un simbolo: oltre a rappresentare un valore del tutto univoco (che evita collisioni accidentali di nomi sugli oggetti, ad esempio quando si lavora con 2 librerie che vogliono aggiungere proprietà allo stesso oggetto), puoi anche "nascondere" proprietà sugli oggetti in questo modo (anche se non del tutto. Puoi comunque accedere ai simboli usando il metodo `Object.getOwnPropertySymbols()`).',
    id: 97,
  },
  {
    grade: Grades.Middle,
    theme: Themes.DATA_TYPES,
    question: "Qual è l'output?",
    code: 'const getList = ([x, ...y]) => [x, y]\nconst getUser = user => { name: user.name, age: user.age }\n\nconst list = [1, 2, 3, 4]\nconst user = { name: "Lydia", age: 21 }\n\nconsole.log(getList(list))\nconsole.log(getUser(user))',
    correctAnswer: 1,
    variants: [
      "`[1, [2, 3, 4]]` e `SyntaxError`",
      '`[1, [2, 3, 4]]` e `{ name: "Lydia", age: 21 }`',
      '`[1, 2, 3, 4]` e `{ name: "Lydia", age: 21 }`',
      '`Error` e `{ name: "Lydia", age: 21 }`',
    ],
    explanation:
      'La funzione `getList` riceve un array come argomento. Tra le parentesi della funzione `getList`, destrutturiamo subito questo array. Esempio:\n\n`[x, ...y] = [1, 2, 3, 4]`\n\nCon il parametro rest `...y`, mettiamo tutti gli argomenti "rimanenti" in un array. Gli argomenti rimanenti sono `2`, `3` e `4` in questo caso. \nIl valore di `y` è un array, contenente tutti i parametri rimanenti. Il valore di `x` è uguale a `1` in questo caso, quindi quando facciamo un console.log di `[x, y]`, viene loggato `[1, [2, 3, 4]]`.\n\nLa funzione `getUser` riceve un oggetto. Con le arrow functions, non _è necessario_ scrivere parentesi graffe se restituiamo solo un valore. Tuttavia, se vuoi restituire istantaneamente un _oggetto_ da una arrow function, devi scriverlo tra parentesi tonde, altrimenti tutto ciò che si trova tra le due parentesi graffe verrà interpretato come un\'istruzione di blocco. In questo caso il codice tra parentesi non è un codice JavaScript valido, quindi viene generato un `SyntaxError`.\n\nLa seguente funzione avrebbe restituito un oggetto:\n\n`const getUser = user => ({ name: user.name, age: user.age })`',
    id: 98,
  },
  {
    grade: Grades.Middle,
    theme: Themes.FUNCTIONS,
    question: "Qual è l'output?",
    code: "const name = 'Lydia';\n\nconsole.log(name());",
    correctAnswer: 3,
    variants: [
      "`SyntaxError`",
      "`ReferenceError`",
      "`TypeError`",
      "`undefined`",
    ],
    explanation:
      'La variabile `name` contiene il valore di una stringa, che non è una funzione, quindi non può essere invocata.\n\nI TypeErrors vengono generati quando un valore non è del tipo previsto. JavaScript "prevede" che `name` è una funzione poiché stiamo cercando di invocarla. In realtà è una stringa, quindi viene generato un TypeError: name is not a function!\n\nI SyntaxErrors vengono generati quando si scrive qualcosa che non è valido in JavaScript, ad esempio quando si scrive la parola `return` come `rerun`.\nI ReferenceErrors vengono generati quando JavaScript non è in grado di trovare un riferimento a un valore a cui stai tentando di accedere.',
    id: 99,
  },
  {
    grade: Grades.Middle,
    theme: Themes.DATA_TYPES,
    question: "Qual è il valore dell'output?",
    code: "// 🎉✨ This is my 100th question! ✨🎉\n\nconst output = `${[] && 'Im'}possible!\nYou should${'' && `n't`} see a therapist after so much JavaScript lol`;",
    correctAnswer: 2,
    variants: [
      "`possible! You should see a therapist after so much JavaScript lol`",
      "`Impossible! You should see a therapist after so much JavaScript lol`",
      "`possible! You shouldn't see a therapist after so much JavaScript lol`",
      "`Impossible! You shouldn't see a therapist after so much JavaScript lol`",
    ],
    explanation:
      "`[]` è un valore vero. Con l'operatore `&&`, verrà restituito il valore di destra se il valore di sinistra è un valore reale. In questo caso, il valore di sinistra `[]` è un valore vero, quindi `\"Im'` viene restituito.\n\n`\"\"` è un valore falso. Se il valore di sinistra è falso, non viene restituito nulla. `n't` quindi non viene restituito.",
    id: 100,
  },
  {
    grade: Grades.Middle,
    theme: Themes.BASICS,
    question: "Qual è il valore dell'output?",
    code: "const one = false || {} || null;\nconst two = null || false || '';\nconst three = [] || 0 || true;\n\nconsole.log(one, two, three);",
    correctAnswer: 3,
    variants: [
      "`false` `null` `[]`",
      '`null` `""` `true`',
      '`{}` `""` `[]`',
      "`null` `null` `true`",
    ],
    explanation:
      'Con l\'operatore `||` possiamo restituire il primo operando veritiero. Se tutti i valori sono falsi, viene restituito l\'ultimo operando.\n\n`(false || {} || null)`: l\'oggetto vuoto `{}` è un valore veritiero. Questo è il primo (e unico) valore veritiero, che viene restituito. `one` è uguale a `{}`.\n\n`(null || false || "")`: tutti gli operandi sono valori falsi. Ciò significa che viene restituito l\'ultimo operando, `""`. `two` è uguale a `""`.\n\n`([] || 0 || "")`: l\'array vuoto`[]` è un valore veritiero. Questo è il primo valore veritiero, che viene restituito. `three` è uguale a `[]`.',
    id: 101,
  },
  {
    grade: Grades.Middle,
    theme: Themes.ASYNC,
    question: "Qual è il valore dell'output?",
    code: "const myPromise = () => Promise.resolve('I have resolved!');\n\nfunction firstFunction() {\n  myPromise().then(res => console.log(res));\n  console.log('second');\n}\n\nasync function secondFunction() {\n  console.log(await myPromise());\n  console.log('second');\n}\n\nfirstFunction();\nsecondFunction();",
    correctAnswer: 4,
    variants: [
      "`I have resolved!`, `second` e `I have resolved!`, `second`",
      "`second`, `I have resolved!` e `second`, `I have resolved!`",
      "`I have resolved!`, `second` e `second`, `I have resolved!`",
      "`second`, `I have resolved!` e `I have resolved!`, `second`",
    ],
    explanation:
      "Con una promise, in pratica diciamo _Voglio eseguire questa funzione, ma per ora la metto da parte mentre è in esecuzione poiché ciò potrebbe richiedere del tempo. Solo quando un determinato valore viene risolto (o rifiutato) e quando lo stack di chiamate è vuoto, voglio utilizzare questo valore._\n\nPossiamo ottenere questo valore sia con `.then` che con la chiave `await` in una funzione `async`. Sebbene possiamo ottenere il valore di una promise sia con `.then` che con `await`, funzionano in modo leggermente diverso.\n\nNella `first Function`, abbiamo (più o meno) messo da parte la funzione myPromise mentre era in esecuzione, ma abbiamo continuato a eseguire l'altro codice, che in questo caso è `console.log('second')`. Quindi, la funzione è stata risolta con la stringa `I have resolved`, che è stata quindi loggata dopo aver visto che lo stack di chiamate era vuoto.\n\nCon await in `secondFunction`, mettiamo letteralmente in pausa l'esecuzione di una funzione asincrona fino a quando il valore non è stato risolto prima di passare alla riga successiva.\n\nCiò significa che ha aspettato che `myPromise` si risolvesse con il valore `I have resolved`, e solo allora, siamo passati alla riga successiva e `second` è stato loggato.",
    id: 102,
  },
  {
    grade: Grades.Junior,
    theme: Themes.DATA_TYPES,
    question: "Qual è il valore dell'output?",
    code: "const set = new Set();\n\nset.add(1);\nset.add('Lydia');\nset.add({ name: 'Lydia' });\n\nfor (let item of set) {\n  console.log(item + 2);\n}",
    correctAnswer: 3,
    variants: [
      "`3`, `NaN`, `NaN`",
      "`3`, `7`, `NaN`",
      "`3`, `Lydia2`, `[object Object]2`",
      '`"12"`, `Lydia2`, `[object Object]2`',
    ],
    explanation:
      'L\'operatore `+` non viene utilizzato solo per aggiungere valori numerici, ma possiamo anche usarlo per concatenare stringhe. Ogni volta che il motore JavaScript vede che uno o più valori non sono un numero, forza il numero in una stringa.\n\nIl primo è `1`, che è un valore numerico. `1 + 2` restituisce il numero 3.\n\nTuttavia, la seconda è una stringa `"Lydia"`. `"Lydia"` è una stringa e `2` è un numero: `2` viene forzato in una stringa. `"Lydia"` e `"2"` vengono concatenati, il che risulta nella stringa `"Lydia2"`.\n\n`{ name: "Lydia" }` è un oggetto. Né un numero né un oggetto sono una stringa, quindi li rende stringhe entrambi. Ogni volta che stringhiamo un oggetto regolare, diventa `"[object Object]"`. `"[object Object]"` concatenato con `2` diventa `"[object Object]"`.',
    id: 103,
  },
  {
    grade: Grades.Junior,
    theme: Themes.ASYNC,
    question: "Qual è il suo valore?",
    code: "Promise.resolve(5);",
    correctAnswer: 3,
    variants: [
      "`5`",
      "`Promise {<pending>: 5}`",
      "`Promise {<fulfilled>: 5}`",
      "`Error`",
    ],
    explanation:
      "Possiamo passare a `Promise.resolve` qualsiasi tipo di valore desideriamo, sia una promise che una non-promise. Il metodo stesso restituisce una promise con il valore risolto (`<fulfilled>`). Se si passa una funzione regolare, sarà una promise risolta con un valore regolare. Se mandi una promise, sarà una promise risolta con il valore risolto di quella promise passata.\n\nIn questo caso, abbiamo appena passato il valore numerico `5`. Restituisce una promise risolta con il valore `5`.",
    id: 104,
  },
  {
    grade: Grades.Middle,
    theme: Themes.OBJECTS,
    question: "Qual è il suo valore?",
    code: "function compareMembers(person1, person2 = person) {\n  if (person1 !== person2) {\n    console.log('Not the same!');\n  } else {\n    console.log('They are the same!');\n  }\n}\n\nconst person = { name: 'Lydia' };\n\ncompareMembers(person);",
    correctAnswer: 2,
    variants: [
      "`Not the same!`",
      "`They are the same!`",
      "`ReferenceError`",
      "`SyntaxError`",
    ],
    explanation:
      "Gli oggetti vengono passati per riferimento. Quando controlliamo gli oggetti per strict equality (`===`), stiamo confrontando i loro riferimenti.\n\nAbbiamo impostato il valore predefinito per `person2` uguale all'oggetto `person` e abbiamo passato l'oggetto `person` come valore per `person1`.\n\nCiò significa che entrambi i valori hanno un riferimento allo stesso punto in memoria, quindi sono uguali.\n\nIl blocco di codice nell'istruzione `else` viene eseguito e `They are the same!` viene loggato.",
    id: 105,
  },
  {
    grade: Grades.Junior,
    theme: Themes.OBJECTS,
    question: "Qual è il suo valore?",
    code: "const colorConfig = {\n  red: true,\n  blue: false,\n  green: true,\n  black: true,\n  yellow: false,\n};\n\nconst colors = ['pink', 'red', 'blue'];\n\nconsole.log(colorConfig.colors[1]);",
    correctAnswer: 4,
    variants: ["`true`", "`false`", "`undefined`", "`TypeError`"],
    explanation:
      "In JavaScript, abbiamo due modi per accedere alle proprietà di un oggetto: le bracket notation o le dot notation. In questo esempio, utilizziamo la notazione con il punto (`colorConfig.colors`) invece della notazione tra parentesi (`colorConfig[\"colors\"]`).\n\nCon la notazione del punto, JavaScript tenta di trovare la proprietà sull'oggetto con quel nome esatto. In questo esempio, JavaScript tenta di trovare una proprietà chiamata `colors` sull'oggetto `colorConfig`. Non esiste una proprietà chiamata `colors`, quindi restituisce `undefined`. Quando proviamo ad accedere al valore del primo elemento usando `[1]`, non possiamo farlo su un valore che è `undefined`, quindi genera un `TypeError`: `Cannot read property '1' of undefined`.\n\nJavaScript interpreta (o decomprime) le istruzioni. Quando usiamo la notazione tra parentesi, vede la prima parentesi aperta `[` e continua finché non trova la parentesi chiusa `]`. Solo allora valuterà la dichiarazione. Se avessimo usato `colorConfig[colors[1]]`, avrebbe restituito il valore della proprietà `red` sull'oggetto `colorConfig`.",
    id: 106,
  },
  {
    grade: Grades.Junior,
    theme: Themes.DATA_TYPES,
    question: "Qual è il suo valore?",
    code: "console.log('❤️' === '❤️');",
    correctAnswer: 1,
    variants: ["`true`", "`false`"],
    explanation:
      "Le emoji sono unicode. L'unicode per l'emoji del cuore è `\"U+2764 U+FE0F\"`. Questi sono sempre gli stessi per gli stessi emoji, stiamo confrontando due stringhe uguali tra loro, e quindi restituisce true.",
    id: 107,
  },
  {
    grade: Grades.Junior,
    theme: Themes.DATA_TYPES,
    question: "Quale di questi metodi modifica l'array originale?",
    code: "const emojis = ['✨', '🥑', '😍'];\n\nemojis.map(x => x + '✨');\nemojis.filter(x => x !== '🥑');\nemojis.find(x => x !== '🥑');\nemojis.reduce((acc, cur) => acc + '✨');\nemojis.slice(1, 2, '✨');\nemojis.splice(1, 2, '✨');",
    correctAnswer: 4,
    variants: [
      "`All of them`",
      "`map` `reduce` `slice` `splice`",
      "`map` `slice` `splice`",
      "`splice`",
    ],
    explanation:
      "Con il metodo `splice` modifichiamo l'array originale cancellando, sostituendo o aggiungendo elementi. In questo caso, abbiamo rimosso 2 elementi dall'indice 1 (abbiamo rimosso `'🥑'` e `'😍'`) e aggiunto invece l'emoji ✨.\n\n`map`, `filter` e `slice` restituiscono un nuovo array, `find` restituisce un elemento e `reduce` restituisce un valore ridotto.",
    id: 108,
  },
  {
    grade: Grades.Junior,
    theme: Themes.OBJECTS,
    question: "Qual è l'output?",
    code: "const food = ['🍕', '🍫', '🥑', '🍔'];\nconst info = { favoriteFood: food[0] };\n\ninfo.favoriteFood = '🍝';\n\nconsole.log(food);",
    correctAnswer: 1,
    variants: [
      "`['🍕', '🍫', '🥑', '🍔']`",
      "`['🍝', '🍫', '🥑', '🍔']`",
      "`['🍝', '🍕', '🍫', '🥑', '🍔']`",
      "`ReferenceError`",
    ],
    explanation:
      "Impostiamo il valore della proprietà `favoriteFood` sull'oggetto `info` uguale alla stringa con l'emoji della pizza, `'🍕'`. Una stringa è un tipo di dati primitivo. In JavaScript, i tipi di dati primitivi non interagiscono per riferimento.\n\nIn JavaScript, i tipi di dati primitivi (tutto ciò che non è un oggetto) interagiscono per _value_. In questo caso, impostiamo il valore della proprietà `favoriteFood` sull'oggetto `info` uguale al valore del primo elemento nell'array `food`, in questo caso la stringa con l'emoji della pizza (`'🍕'`). Una stringa è un tipo di dati primitivo e interagisce per valore (vedi il mio [blogpost](https://www.theavocoder.com/complete-javascript/2018/12/21/by-value-vs-by-reference) se sei interessato a saperne di più).\n\nQuindi, cambiamo il valore della proprietà `favoriteFood` sull'oggetto `info`. L'array `food` non è cambiato, poiché il valore di `favoriteFood` era semplicemente una _copia_ del valore del primo elemento nell'array e non ha un riferimento allo stesso punto in memoria dell'elemento su ` food[0]`. Quando logghiamo food, è ancora l'array originale, `['🍕', '🍫', '🥑', '🍔']`.",
    id: 109,
  },
  {
    grade: Grades.Junior,
    theme: Themes.DATA_TYPES,
    question: "Cosa fa questo metodo?",
    code: "JSON.parse();",
    correctAnswer: 1,
    variants: [
      "converte JSON in un valore JavaScript",
      "converte un oggetto JavaScript in JSON",
      "converte qualsiasi valore JavaScript in JSON",
      "converte JSON in un oggetto solo JavaScript",
    ],
    explanation:
      "Con il metodo `JSON.parse()`, possiamo analizzare la stringa JSON come un valore JavaScript.\n\n``` js\n// Stringhiamo un numero in un JSON valido, quindi analizziamo la stringa JSON come valore JavaScript:\nconst jsonNumber = JSON.stringify(4); // '4'\nJSON.parse(jsonNumber); // 4\n\n// Stringhiamo un array in un JSON valido, quindi analizziamo la stringa JSON come valore JavaScript:\nconst jsonArray = JSON.stringify([1, 2, 3]); // '[1, 2, 3]'\nJSON.parse(jsonArray); // [1, 2, 3]\n\n// Stringhiamo un object in un JSON valido, quindi analizziamo la stringa JSON come valore JavaScript:\nconst jsonArray = JSON.stringify({ name: 'Lydia' }); // '{\"name\":\"Lydia\"}'\nJSON.parse(jsonArray); // { name: 'Lydia' }\n```",
    id: 110,
  },
  {
    grade: Grades.Junior,
    theme: Themes.BASICS,
    question: "Qual è l'output?",
    code: "let name = 'Lydia';\n\nfunction getName() {\n  console.log(name);\n  let name = 'Sarah';\n}\n\ngetName();",
    correctAnswer: 4,
    variants: ["Lydia", "Sarah", "`undefined`", "`ReferenceError`"],
    explanation:
      "Ogni funzione ha il proprio _contesto di esecuzione_ (o _ambito_). La funzione `getName` cerca prima all'interno del proprio contesto (scope) per vedere se contiene la variabile `name` a cui stiamo cercando di accedere. In questo caso, la funzione `getName` contiene la propria variabile `name` perché dichiariamo la variabile `name` con la chiave `let`, e con il valore di `'Sarah'`.\n\nLe variabili con la chiave `let` (e `const`) vengono sollevate, ma a differenza di `var`, non vengono _inizializzate_. Non sono quindi accessibili prima della riga in cui le dichiariamo (inizializziamo). Questa è chiamata \"temporal dead zone\". Quando proviamo ad accedere alle variabili prima che vengano dichiarate, JavaScript genera un `ReferenceError`.\n\nSe non avessimo dichiarato la variabile `name` all'interno della funzione `getName`, JavaScript avrebbe esaminato la _scope chain_. Lo scope esterno ha una variabile chiamata `name` con il valore di `Lydia`. In tal caso, avrebbe loggato \"Lydia\".\n\n``` js\nlet name = 'Lydia';\n\nfunction getName() {\n  console.log(name);\n}\n\ngetName(); // Lydia\n```",
    id: 111,
  },
  {
    grade: Grades.Middle,
    theme: Themes.ASYNC,
    question: "Qual è l'output?",
    code: "function* generatorOne() {\n  yield ['a', 'b', 'c'];\n}\n\nfunction* generatorTwo() {\n  yield* ['a', 'b', 'c'];\n}\n\nconst one = generatorOne();\nconst two = generatorTwo();\n\nconsole.log(one.next().value);\nconsole.log(two.next().value);",
    correctAnswer: 3,
    variants: [
      "`a` e `a`",
      "`a` e `undefined`",
      "`['a', 'b', 'c']` e `a`",
      "`a` e `['a', 'b', 'c']`",
    ],
    explanation:
      "Con la parola chiave `yield`, otteniamo valori in una funzione generatore. Con la chiave `yield*`, possiamo produrre valori da un'altra funzione del generatore, o da un oggetto iterabile (per esempio un array).\n\nIn `generatorOne`, produciamo l'intero array `['a', 'b', 'c']` usando la parola chiave `yield`. Il valore della proprietà `value` sull'oggetto restituito dal metodo `next` su `one` (`one.next().value`) è uguale all'intero array `['a', 'b', 'c']`.\n\n``` js\nconsole.log(one.next().value); // ['a', 'b', 'c']\nconsole.log(one.next().value); // undefined\n```\n\nIn `generatorTwo`, utilizziamo la parola chiave `yield*`. Ciò significa che il primo valore ottenuto è `two`, ed è uguale al primo valore ottenuto nell'iteratore. L'iteratore è l'array `['a', 'b', 'c']`. Il primo valore ottenuto è `a`, quindi la prima volta che chiamiamo `two.next().value`, viene restituito `a`.\n\n``` js\nconsole.log(two.next().value); // 'a'\nconsole.log(two.next().value); // 'b'\nconsole.log(two.next().value); // 'c'\nconsole.log(two.next().value); // undefined\n```",
    id: 112,
  },
  {
    grade: Grades.Junior,
    theme: Themes.BASICS,
    question: "Qual è l'output?",
    code: "console.log(`${(x => x)('I love')} to program`);",
    correctAnswer: 1,
    variants: [
      "`I love to program`",
      "`undefined to program`",
      "`${(x => x)('I love') to program`",
      "`TypeError`",
    ],
    explanation:
      "Le espressioni all'interno dei template literals vengono valutate per prime. Ciò significa che la stringa conterrà il valore restituito dell'espressione, in questo caso la funzione immediatamente invocata `(x => x)('I love')`. Passiamo il valore `'I love'` come argomento alla funzione freccia `x => x`. `x` è uguale a `'I love'`, che viene restituito. Ciò si traduce in `I love to program`.",
    id: 113,
  },
  {
    grade: Grades.Middle,
    theme: Themes.FUNCTIONS,
    question: "Cosa accadrà?",
    code: "let config = {\n  alert: setInterval(() => {\n    console.log('Alert!');\n  }, 1000),\n};\n\nconfig = null;",
    correctAnswer: 3,
    variants: [
      "La callback `setInterval` non verrà invocata",
      "La callback `setInterval` viene invocata una volta",
      "La callback `setInterval` verrà comunque chiamata ogni secondo",
      "Non abbiamo mai invocato `config.alert()`, config è `null`",
    ],
    explanation:
      "Normalmente quando impostiamo oggetti uguali a `null`, quegli oggetti vengono _garbage collected_ poiché non c'è più alcun riferimento a quell'oggetto. Tuttavia, poiché la funzione di callback all'interno di `setInterval` è una funzione freccia (quindi legata all'oggetto `config`), la funzione di callback mantiene ancora un riferimento all'oggetto `config`.\nFinché c'è un riferimento, l'oggetto non verrà raccolto.\nPoiché si tratta di un intervallo, impostare `config` su `null` o `delete`-ing `config.alert` non raccoglierà l'intervallo, quindi l'intervallo verrà comunque chiamato.\nDovrebbe essere cancellato con `clearInterval(config.alert)` per rimuoverlo dalla memoria.\nDal momento che non è stato cancellato, la funzione di callback `setInterval` verrà comunque invocata ogni 1000 ms (1 s).",
    id: 114,
  },
  {
    grade: Grades.Junior,
    theme: Themes.DATA_TYPES,
    question: "Quali metodi restituiranno il valore `'Hello world!'`?",
    code: "const myMap = new Map();\nconst myFunc = () => 'greeting';\n\nmyMap.set(myFunc, 'Hello world!');\n\n//1\nmyMap.get('greeting');\n//2\nmyMap.get(myFunc);\n//3\nmyMap.get(() => 'greeting');",
    correctAnswer: 2,
    variants: ["1", "2", "2 e 3", "Tutti"],
    explanation:
      "Quando si aggiunge una coppia chiave/valore usando il metodo `set`, la chiave sarà il valore del primo argomento passato alla funzione `set`, e il valore sarà il secondo argomento. La chiave è _function_ `() => 'greeting'` in questo caso, e il valore `'Hello world'`. `myMap` ora è `{ () => 'greeting' => 'Hello world!' }`.\n\n1 è sbagliato, poiché la chiave non è `'greeting'` ma `() => 'greeting'`.\n3 è sbagliato, poiché stiamo creando una nuova funzione passandola come parametro al metodo `get`. L'oggetto interagisce per _reference_. Le funzioni sono oggetti, che è il motivo per cui due funzioni non sono mai rigorosamente uguali, anche se identiche: hanno un riferimento a un punto diverso della memoria.",
    id: 115,
  },
  {
    grade: Grades.Middle,
    theme: Themes.FUNCTIONS,
    question: "Qual è l'output?",
    code: "const person = {\n  name: 'Lydia',\n  age: 21,\n};\n\nconst changeAge = (x = { ...person }) => (x.age += 1);\nconst changeAgeAndName = (x = { ...person }) => {\n  x.age += 1;\n  x.name = 'Sarah';\n};\n\nchangeAge(person);\nchangeAgeAndName();\n\nconsole.log(person);",
    correctAnswer: 3,
    variants: [
      '`{name: "Sarah", age: 22}`',
      '`{name: "Sarah", age: 23}`',
      '`{name: "Lydia", age: 22}`',
      '`{name: "Lydia", age: 23}`',
    ],
    explanation:
      'Entrambe le funzioni `changeAge` e `changeAgeAndName` hanno un parametro predefinito, ovvero un oggetto _appena_ creato `{ ...person }`. Questo oggetto ha copie di tutte le chiavi/valori nell\'oggetto `person`.\n\nPer prima cosa, invochiamo la funzione `changeAge` e passiamo l\'oggetto `person` come argomento. Questa funzione aumenta il valore della proprietà `age` di 1. `person` ora è `{ name: "Lydia", age: 22 }`.\n\nQuindi, invochiamo la funzione `changeAgeAndName`, tuttavia non passiamo un parametro. Invece, il valore di `x` è uguale a un _nuovo_ oggetto: `{ ...person }`. Poiché si tratta di un nuovo oggetto, non influisce sui valori delle proprietà sull\'oggetto `person`. `person` è ancora uguale a `{ name: "Lydia", age: 22 }`.',
    id: 116,
  },
  {
    grade: Grades.Junior,
    theme: Themes.FUNCTIONS,
    question: "Quale delle seguenti opzioni restituirà `6`?",
    code: "function sumValues(x, y, z) {\n  return x + y + z;\n}",
    correctAnswer: 3,
    variants: [
      "`sumValues([...1, 2, 3])`",
      "`sumValues([...[1, 2, 3]])`",
      "`sumValues(...[1, 2, 3])`",
      "`sumValues([1, 2, 3])`",
    ],
    explanation:
      "Con l'operatore spread `...`, possiamo _distribuire_ gli iterabili come singoli elementi. La funzione `sumValues` riceve tre argomenti: `x`, `y` e `z`. `...[1, 2, 3]` risulterà in `1, 2, 3`, che passiamo alla funzione `sumValues`.",
    id: 117,
  },
  {
    grade: Grades.Junior,
    theme: Themes.BASICS,
    question: "Qual è l'output?",
    code: "let num = 1;\nconst list = ['🥳', '🤠', '🥰', '🤪'];\n\nconsole.log(list[(num += 1)]);",
    correctAnswer: 2,
    variants: ["`🤠`", "`🥰`", "`SyntaxError`", "`ReferenceError`"],
    explanation:
      "Con l'operando `+=`, stiamo incrementando il valore di `num` di `1`. `num` aveva il valore iniziale `1`, quindi `1 + 1` è `2`. L'elemento sul secondo indice nell'array `list` è 🥰, `console.log(list[2])` stampa 🥰.",
    id: 118,
  },
  {
    grade: Grades.Junior,
    theme: Themes.ECMASCRIPT,
    question: "Qual è l'output?",
    code: "const person = {\n  firstName: 'Lydia',\n  lastName: 'Hallie',\n  pet: {\n    name: 'Mara',\n    breed: 'Dutch Tulip Hound',\n  },\n  getFullName() {\n    return `${this.firstName} ${this.lastName}`;\n  },\n};\n\nconsole.log(person.pet?.name);\nconsole.log(person.pet?.family?.name);\nconsole.log(person.getFullName?.());\nconsole.log(member.getLastName?.());",
    correctAnswer: 2,
    variants: [
      "`undefined` `undefined` `undefined` `undefined`",
      "`Mara` `undefined` `Lydia Hallie` `ReferenceError`",
      "`Mara` `null` `Lydia Hallie` `null`",
      "`null` `ReferenceError` `null` `ReferenceError`",
    ],
    explanation:
      "Con l'operatore di concatenamento opzionale `?.`, non è più necessario verificare esplicitamente se i valori annidati più profondi sono validi o meno. Se stiamo cercando di accedere a una proprietà su un valore `undefined` o `null` (_nullish_), l'espressione va in cortocircuito e restituisce `undefined`.\n\n`person.pet?.name`: `person` ha una proprietà denominata `pet`: `person.pet` non è nullo. Ha una proprietà chiamata `name` e restituisce `Mara`.\n`person.pet?.family?.name`: `person` ha una proprietà denominata `pet`: `person.pet` non è nullo. `pet` _non_ ha una proprietà chiamata `family`, `person.pet.family` è nullo. L'espressione restituisce `undefined`.\n`person.getFullName?.()`: `person` ha una proprietà denominata `getFullName`: `person.getFullName()` non è nullo e può essere invocato, il che restituisce `Lydia Hallie`.\n`member.getLastName?.()`: la variabile `member` non esiste quindi viene generato un `ReferenceError`!",
    id: 119,
  },
  {
    grade: Grades.Junior,
    theme: Themes.BASICS,
    question: "Qual è l'output?",
    code: "const groceries = ['banana', 'apple', 'peanuts'];\n\nif (groceries.indexOf('banana')) {\n  console.log('We have to buy bananas!');\n} else {\n  console.log(`We don't have to buy bananas!`);\n}",
    correctAnswer: 2,
    variants: [
      "We have to buy bananas!",
      "We don't have to buy bananas",
      "`undefined`",
      "`1`",
    ],
    explanation:
      'Abbiamo passato la condizione `groceries.indexOf("banana")` all\'istruzione if. `groceries.indexOf("banana")` restituisce `0`, che è un valore falso. Poiché la condizione nell\'istruzione if è falsa, il codice nel blocco `else` viene eseguito e `We don\'t have to buy bananas!` viene registrato.',
    id: 120,
  },
  {
    grade: Grades.Junior,
    theme: Themes.OBJECTS,
    question: "Qual è l'output?",
    code: "const config = {\n  languages: [],\n  set language(lang) {\n    return this.languages.push(lang);\n  },\n};\n\nconsole.log(config.language);",
    correctAnswer: 4,
    variants: [
      "`function language(lang) { this.languages.push(lang }`",
      "`0`",
      "`[]`",
      "`undefined`",
    ],
    explanation:
      "Il metodo `language` è un `setter`. I setter non detengono un valore effettivo, il loro scopo è _modificare_ le proprietà. Quando si chiama un metodo `setter`, viene restituito `undefined`.",
    id: 121,
  },
  {
    grade: Grades.Middle,
    theme: Themes.DATA_TYPES,
    question: "Qual è l'output?",
    code: "const name = 'Lydia Hallie';\n\nconsole.log(!typeof name === 'object');\nconsole.log(!typeof name === 'string');",
    correctAnswer: 3,
    variants: [
      "`false` `true`",
      "`true` `false`",
      "`false` `false`",
      "`true` `true`",
    ],
    explanation:
      '`typeof name` restituisce `"string"`. La stringa `"string"` è un valore veritiero, quindi `!typeof name` restituisce il valore booleano `false`. `false === "object"` e `false === "string"` restituiscono entrambi `false`.\n\n(Se volessimo verificare se il tipo era (non)uguale a un certo tipo, avremmo dovuto scrivere `!==` invece di `!typeof`)',
    id: 122,
  },
  {
    grade: Grades.Middle,
    theme: Themes.FUNCTIONS,
    question: "Qual è l'output?",
    code: "const add = x => y => z => {\n  console.log(x, y, z);\n  return x + y + z;\n};\n\nadd(4)(5)(6);",
    correctAnswer: 1,
    variants: [
      "`4` `5` `6`",
      "`6` `5` `4`",
      "`4` `function` `function`",
      "`undefined` `undefined` `6`",
    ],
    explanation:
      "La funzione `add` restituisce una arrow function, che restituisce una arrow function, che restituisce arrow function (mi segui ancora?). \nLa prima funzione riceve un argomento `x` con il valore di `4`. Invochiamo la seconda funzione, che riceve un argomento `y` con il valore `5`. Quindi invochiamo la terza funzione, che riceve un argomento `z` con il valore `6`. Quando si tenta di accedere ai valori `x`, `y` e `z` all'interno dell'ultima arrow function, il motore JS risale la catena dell'ambito per trovare i valori per `x` e `y`. Questo restituisce `4` `5` `6`.",
    id: 123,
  },
  {
    grade: Grades.Middle,
    theme: Themes.ASYNC,
    question: "Qual è l'output?",
    code: "async function* range(start, end) {\n  for (let i = start; i <= end; i++) {\n    yield Promise.resolve(i);\n  }\n}\n\n(async () => {\n  const gen = range(1, 3);\n  for await (const item of gen) {\n    console.log(item);\n  }\n})();",
    correctAnswer: 3,
    variants: [
      "`Promise {1}` `Promise {2}` `Promise {3}`",
      "`Promise {<pending>}` `Promise {<pending>}` `Promise {<pending>}`",
      "`1` `2` `3`",
      "`undefined` `undefined` `undefined`",
    ],
    explanation:
      "La funzione `range` restituisce un oggetto asincrono con promises per ogni elemento nell'intervallo che passiamo: `Promise{1}`, `Promise{2}`, `Promise{3}`. Impostiamo la variabile `gen` uguale all'oggetto asincrono, dopodiché lo eseguiamo in loop usando un ciclo `for await ... of`. Impostiamo la variabile `item` uguale ai valori Promise restituiti: prima `Promise{1}`, poi `Promise{2}`, quindi `Promise{3}`. Poiché stiamo _attendendo_ il valore di `item`, la promise risolta, vengono restituiti i _valori_ risolti delle promises: `1`, `2` e quindi `3`.",
    id: 124,
  },
  {
    grade: Grades.Junior,
    theme: Themes.DATA_TYPES,
    question: "Qual è l'output?",
    code: "const myFunc = ({ x, y, z }) => {\n  console.log(x, y, z);\n};\n\nmyFunc(1, 2, 3);",
    correctAnswer: 4,
    variants: [
      "`1` `2` `3`",
      "`{1: 1}` `{2: 2}` `{3: 3}`",
      "`{ 1: undefined }` `undefined` `undefined`",
      "`undefined` `undefined` `undefined`",
    ],
    explanation:
      "`myFunc` si aspetta un oggetto con le proprietà `x`, `y` e `z` come argomento. Poiché stiamo passando solo tre valori numerici separati (1, 2, 3) invece di un oggetto con le proprietà `x`, `y` e `z` ({x: 1, y: 2, z: 3}), `x`, `y` e `z` hanno il loro valore predefinito di `undefined`.",
    id: 125,
  },
  {
    grade: Grades.Junior,
    theme: Themes.MISC,
    question: "Qual è l'output?",
    code: "function getFine(speed, amount) {\n  const formattedSpeed = new Intl.NumberFormat('en-US', {\n    style: 'unit',\n    unit: 'mile-per-hour'\n  }).format(speed);\n\n  const formattedAmount = new Intl.NumberFormat('en-US', {\n    style: 'currency',\n    currency: 'USD'\n  }).format(amount);\n\n  return `The driver drove ${formattedSpeed} and has to pay ${formattedAmount}`;\n}\n\nconsole.log(getFine(130, 300))",
    correctAnswer: 2,
    variants: [
      "The driver drove 130 and has to pay 300",
      "The driver drove 130 mph and has to pay \\$300.00",
      "The driver drove undefined and has to pay undefined",
      "The driver drove 130.00 and has to pay 300.00",
    ],
    explanation:
      "Con il metodo `Intl.NumberFormat`, possiamo formattare i valori numerici in qualsiasi locale. Formattiamo il valore numerico `130` nella locale `en-US` come `unit` in `mile-per-hour`, che risulta in `130 mph`. Il valore numerico `300` nella locale `en-US` come `currency` in `USD` risulta in `$300.00`.",
    id: 126,
  },
  {
    grade: Grades.Junior,
    theme: Themes.DATA_TYPES,
    question: "Qual è l'output?",
    code: "const spookyItems = ['👻', '🎃', '🕸'];\n({ item: spookyItems[3] } = { item: '💀' });\n\nconsole.log(spookyItems);",
    correctAnswer: 2,
    variants: [
      '`["👻", "🎃", "🕸"]`',
      '`["👻", "🎃", "🕸", "💀"]`',
      '`["👻", "🎃", "🕸", { item: "💀" }]`',
      '`["👻", "🎃", "🕸", "[object Object]"]`',
    ],
    explanation:
      'Destrutturando gli oggetti, possiamo decomprimere i valori dall\'oggetto di destra e assegnare il valore decompresso al valore dello stesso nome di proprietà sull\'oggetto di sinistra. In questo caso, stiamo assegnando il valore "💀" a `spookyItems[3]`. Ciò significa che stiamo modificando l\'array `spookyItems`, stiamo aggiungendo il "💀" ad esso. Quando facciamo console.log di `spookyItems`, `["👻", "🎃", "🕸", "💀"]` viene loggato.',
    id: 127,
  },
  {
    grade: Grades.Junior,
    theme: Themes.DATA_TYPES,
    question: "Qual è l'output?",
    code: "const name = 'Lydia Hallie';\nconst age = 21;\n\nconsole.log(Number.isNaN(name));\nconsole.log(Number.isNaN(age));\n\nconsole.log(isNaN(name));\nconsole.log(isNaN(age));",
    correctAnswer: 3,
    variants: [
      "`true` `false` `true` `false`",
      "`true` `false` `false` `false`",
      "`false` `false` `true` `false`",
      "`false` `true` `false` `true`",
    ],
    explanation:
      "Con il metodo `Number.isNaN`, puoi controllare se il valore passato è un _valore numerico_ e uguale a `NaN`. `name` non è un valore numerico, quindi `Number.isNaN(name)` restituisce `false`. `age` è un valore numerico, ma non è uguale a `NaN`, quindi `Numero.isNaN(age)` restituisce `false`.\n\nCon il metodo `isNaN`, puoi verificare se il valore che passi non è un numero. `name` non è un numero, quindi `isNaN(name)` restituisce true. `age` è un numero, quindi `isNaN(age)` restituisce `false`.",
    id: 128,
  },
  {
    grade: Grades.Junior,
    theme: Themes.BASICS,
    question: "Qual è l'output?",
    code: "const randomValue = 21;\n\nfunction getInfo() {\n  console.log(typeof randomValue);\n  const randomValue = 'Lydia Hallie';\n}\n\ngetInfo();",
    correctAnswer: 4,
    variants: ['`"number"`', '`"string"`', "`undefined`", "`ReferenceError`"],
    explanation:
      "Le variabili dichiarate con la chiave `const` non sono referenziabili prima della loro inizializzazione: questa viene chiamata _temporal dead zone_. Nella funzione `getInfo`, la variabile `randomValue` ha lo scopo nell'ambito funzionale di `getInfo`. Nella riga in cui vogliamo registrare il valore di `typeof randomValue`, la variabile `randomValue` non è ancora inizializzata: viene lanciato un `ReferenceError`! Il motore non è andato giù per la catena dell'ambito poiché abbiamo dichiarato la variabile `randomValue` nella funzione `getInfo`.",
    id: 129,
  },
  {
    grade: Grades.Middle,
    theme: Themes.ERRORS,
    question: "Qual è l'output?",
    code: "const myPromise = Promise.resolve('Woah some cool data');\n\n(async () => {\n  try {\n    console.log(await myPromise);\n  } catch {\n    throw new Error(`Oops didn't work`);\n  } finally {\n    console.log('Oh finally!');\n  }\n})();",
    correctAnswer: 3,
    variants: [
      "`Woah some cool data`",
      "`Oh finally!`",
      "`Woah some cool data` `Oh finally!`",
      "`Oops didn't work` `Oh finally!`",
    ],
    explanation:
      'Nel blocco `try`, stiamo loggando il valore atteso della variabile `myPromise`: `"Woah some cool data"`. Poiché non sono stati generati errori nel blocco `try`, il codice nel blocco `catch` non viene eseguito. Il codice nel blocco `finally` viene eseguito _sempre_, `"Oh finally!"` viene loggato.',
    id: 130,
  },
  {
    grade: Grades.Junior,
    theme: Themes.ECMASCRIPT,
    question: "Qual è l'output?",
    code: "const emojis = ['🥑', ['✨', '✨', ['🍕', '🍕']]];\n\nconsole.log(emojis.flat(1));",
    correctAnswer: 2,
    variants: [
      "`['🥑', ['✨', '✨', ['🍕', '🍕']]]`",
      "`['🥑', '✨', '✨', ['🍕', '🍕']]`",
      "`['🥑', ['✨', '✨', '🍕', '🍕']]`",
      "`['🥑', '✨', '✨', '🍕', '🍕']`",
    ],
    explanation:
      "Con il metodo `flat`, possiamo creare un nuovo array appiattito. La profondità dell'array appiattito dipende dal valore che passiamo. In questo caso, abbiamo passato il valore `1` (cosa che non dovevamo fare, questo è il valore predefinito), il che significa che solo gli array sulla prima profondità verranno concatenati. `['🥑']` e `['✨', '✨', ['🍕', '🍕']]` in questo caso. Concatenando questi due array si ottengono `['🥑', '✨', '✨', ['🍕', '🍕']]`.",
    id: 131,
  },
  {
    grade: Grades.Middle,
    theme: Themes.CLASSES,
    question: "Qual è l'output?",
    code: "class Counter {\n  constructor() {\n    this.count = 0;\n  }\n\n  increment() {\n    this.count++;\n  }\n}\n\nconst counterOne = new Counter();\ncounterOne.increment();\ncounterOne.increment();\n\nconst counterTwo = counterOne;\ncounterTwo.increment();\n\nconsole.log(counterOne.count);",
    correctAnswer: 4,
    variants: ["`0`", "`1`", "`2`", "`3`"],
    explanation:
      "`counterOne` è un'istanza della classe `Counter`. La classe counter contiene una proprietà `count` sul suo costruttore e un metodo `increment`. Per prima cosa, abbiamo invocato il metodo `increment` due volte chiamando `counterOne.increment()`. Attualmente, `counterOne.count` è `2`.\n\n![Image](https://i.imgur.com/KxLlTm9.png)\n\nQuindi, creiamo una nuova variabile `counterTwo` e la impostiamo uguale a `counterOne`. Poiché gli oggetti interagiscono per riferimento, stiamo semplicemente creando un nuovo riferimento allo stesso punto della memoria a cui punta `counterOne`. Poiché ha lo stesso punto in memoria, qualsiasi modifica apportata all'oggetto a cui fa riferimento `counterTwo`, si applica anche a `counterOne`. Attualmente, `counterTwo.count` è `2`.\n\nInvochiamo `counterTwo.increment()`, che imposta `count` su `3`. Quindi, logghiamo il conteggio su `counterOne`, che stampa `3`.\n\n![Image](https://i.imgur.com/BNBHXmc.png)",
    id: 132,
  },
  {
    grade: Grades.Middle,
    theme: Themes.ASYNC,
    question: "Qual è l'output?",
    code: "const myPromise = Promise.resolve(Promise.resolve('Promise'));\n\nfunction funcOne() {\n  setTimeout(() => console.log('Timeout 1!'), 0);\n  myPromise.then(res => res).then(res => console.log(`${res} 1!`));\n  console.log('Last line 1!');\n}\n\nasync function funcTwo() {\n  const res = await myPromise;\n  console.log(`${res} 2!`)\n  setTimeout(() => console.log('Timeout 2!'), 0);\n  console.log('Last line 2!');\n}\n\nfuncOne();\nfuncTwo();",
    correctAnswer: 3,
    variants: [
      "`Promise 1! Last line 1! Promise 2! Last line 2! Timeout 1! Timeout 2!`",
      "`Last line 1! Timeout 1! Promise 1! Last line 2! Promise2! Timeout 2! `",
      "`Last line 1! Promise 2! Last line 2! Promise 1! Timeout 1! Timeout 2!`",
      "`Timeout 1! Promise 1! Last line 1! Promise 2! Timeout 2! Last line 2!`",
    ],
    explanation:
      "Innanzitutto, invochiamo `funcOne`. Sulla prima riga di `funcOne`, chiamiamo la funzione _asincrona_ `setTimeout`, da cui la callback viene inviato all'API Web. (vedi l'articolo sul ciclo degli eventi [qui](https://dev.to/lydiahallie/javascript-visualized-event-loop-3dif))\n\nQuindi chiamiamo la promise `myPromise`, che è un'operazione _asincrona_.\n\nSia la promise che il timeout sono operazioni asincrone, la funzione continua a funzionare mentre è impegnata a completare la promise e a gestire la callback `setTimeout`. Ciò significa che `Last line 1!` viene registrato per primo, poiché questa non è un'operazione asincrona.\n\nPoiché la callstack non è ancora vuota, la funzione `setTimeout` e la promise in `funcOne` non possono ancora essere aggiunte al callstack.\n\nIn `funcTwo`, la variabile `res` ottiene `Promise` perché `Promise.resolve(Promise.resolve('Promise'))` è equivalente a `Promise.resolve('Promise')` poiché risolvere una promise risolve il suo valore. L'\"attesa\" in questa riga interrompe l'esecuzione della funzione fino a quando non riceve la risoluzione della promise e quindi continua a funzionare in modo sincrono fino al completamento, quindi `Promise 2!` e poi `Last line 2!` vengono registrati e `setTimeout` viene inviato all'API Web.\n\nQuindi lo stack di chiamate è vuoto. Le promise sono _microattività_, quindi vengono risolte per prime quando lo stack di chiamate è vuoto, quindi `Promise 1!` viene registrato.\n\nOra, da quando `funcTwo` è uscito dallo stack delle chiamate, lo stack delle chiamate è vuoto. Le callback in attesa nella coda (`() => console.log(\"Timeout 1!\")` da `funcOne`, e `() => console.log(\"Timeout 2!\")` da `funcTwo`) vengono aggiunti allo stack di chiamate uno per uno. Il primo callback registra `Timeout 1!` e viene eliminato dallo stack. Quindi, il secondo callback registra `Timeout 2!` e viene eliminato dallo stack.",
    id: 133,
  },
  {
    grade: Grades.Middle,
    theme: Themes.MODULES,
    question: "Come possiamo invocare `sum` in `sum.js` da `index.js?`",
    code: "// sum.js\nexport default function sum(x) {\n  return x + x;\n}\n\n// index.js\nimport * as sum from './sum';",
    correctAnswer: 3,
    variants: [
      "`sum(4)`",
      "`sum.sum(4)`",
      "`sum.default(4)`",
      "I valori predefiniti non vengono importati con `*`, solo esportazioni nominali",
    ],
    explanation:
      "Con l'asterisco `*`, importiamo tutti i valori esportati da quel file, sia predefinito che nominale. Se avessimo il seguente file:\n\n``` js\n// info.js\nexport const name = 'Lydia';\nexport const age = 21;\nexport default 'I love JavaScript';\n\n// index.js\nimport * as info from './info';\nconsole.log(info);\n```\n\nVerrebbe loggato quanto segue:\n\n``` js\n{\n  default: \"I love JavaScript\",\n  name: \"Lydia\",\n  age: 21\n}\n```\n\nPer l'esempio `sum`, significa che il valore importato `sum` è simile a quanto segue:\n\n``` js\n{ default: function sum(x) { return x + x } }\n```\n\nPossiamo invocare questa funzione, chiamando `sum.default`",
    id: 134,
  },
  {
    grade: Grades.Junior,
    theme: Themes.MISC,
    question: "Qual è l'output?",
    code: "const handler = {\n  set: () => console.log('Added a new property!'),\n  get: () => console.log('Accessed a property!'),\n};\n\nconst person = new Proxy({}, handler);\n\nperson.name = 'Lydia';\nperson.name;",
    correctAnswer: 3,
    variants: [
      "`Added a new property!`",
      "`Accessed a property!`",
      "`Added a new property!` `Accessed a property!`",
      "Nulla viene loggato",
    ],
    explanation:
      "Con un oggetto Proxy, possiamo aggiungere un comportamento personalizzato a un oggetto che gli passiamo come secondo argomento. In questo caso, passiamo all'oggetto `handler` che conteneva due proprietà: `set` e `get`. `set` viene invocato ogni volta che _settiamo_ valori di proprietà, `get` viene invocato ogni volta che _otteniamo_ (accediamo) valori di proprietà.\n\nIl primo argomento è un oggetto vuoto `{}`, che è il valore di `person`. A questo oggetto viene aggiunto il comportamento personalizzato specificato nell'oggetto `handler`. Se aggiungiamo una proprietà all'oggetto `person`, `set` verrà invocato. Se accediamo a una proprietà sull'oggetto `person`, `get` viene invocato.\n\nInnanzitutto, abbiamo aggiunto una nuova proprietà `name` all'oggetto proxy (`person.name = \"Lydia\"`). `set` viene invocato e registra `\"Added a new property!\"`.\n\nQuindi, accediamo a un valore di proprietà sull'oggetto proxy, la proprietà `get` sull'oggetto handler è stata invocata. `\"Accessed a property!\"` viene registrato.",
    id: 135,
  },
  {
    grade: Grades.Junior,
    theme: Themes.OBJECTS,
    question: "Quale delle seguenti opzioni modificherà l'oggetto `persona`?",
    code: "const person = { name: 'Lydia Hallie' };\n\nObject.seal(person);",
    correctAnswer: 1,
    variants: [
      '`person.name = "Evan Bacon"`',
      "`person.age = 21`",
      "`delete person.name`",
      "`Object.assign(person, { age: 21 })`",
    ],
    explanation:
      "Con `Object.seal` possiamo impedire che nuove proprietà vengano _aggiunte_ o che proprietà esistenti vengano _rimosse_.\n\nTuttavia, puoi comunque modificare il valore delle proprietà esistenti.",
    id: 136,
  },
  {
    grade: Grades.Junior,
    theme: Themes.OBJECTS,
    question: "Quale delle seguenti opzioni modificherà l'oggetto `person`?",
    code: "const person = {\n  name: 'Lydia Hallie',\n  address: {\n    street: '100 Main St',\n  },\n};\n\nObject.freeze(person);",
    correctAnswer: 3,
    variants: [
      '`person.name = "Evan Bacon"`',
      "`delete person.address`",
      '`person.address.street = "101 Main St"`',
      '`person.pet = { name: "Mara" }`',
    ],
    explanation:
      "Il metodo `Object.freeze` _congela_ un oggetto. Nessuna proprietà può essere aggiunta, modificata o rimossa.\n\nTuttavia, blocca solo _poco profondamente_ l'oggetto, il che significa che solo le proprietà _direct_ sull'oggetto sono bloccate. Se la proprietà è un altro oggetto, come `address` in questo caso, le proprietà su quell'oggetto non vengono bloccate e possono essere modificate.",
    id: 137,
  },
  {
    grade: Grades.Middle,
    theme: Themes.FUNCTIONS,
    question: "Qual è l'output?",
    code: "const add = x => x + x;\n\nfunction myFunc(num = 2, value = add(num)) {\n  console.log(num, value);\n}\n\nmyFunc();\nmyFunc(3);",
    correctAnswer: 1,
    variants: [
      "`2` `4` and `3` `6`",
      "`2` `NaN` and `3` `NaN`",
      "`2` `Error` and `3` `6`",
      "`2` `4` and `3` `Error`",
    ],
    explanation:
      "Per prima cosa, abbiamo invocato `myFunc()` senza passare alcun argomento. Dal momento che non abbiamo passato argomenti, `num` e `value` hanno i loro valori predefiniti: num è `2` e `value` il valore restituito dalla funzione `add`. Alla funzione `add`, passiamo `num` come argomento, che aveva il valore di `2`. `add` restituisce `4`, che è il valore di `value`.\n\nQuindi, abbiamo invocato `myFunc(3)` e passato il valore `3` come valore per l'argomento `num`. Non abbiamo passato un argomento per `value`. \nPoiché non abbiamo passato un valore per l'argomento `value`, ha ottenuto il valore predefinito: il valore restituito dalla funzione `add`. Ad `add` passiamo `num`, che ha il valore di `3`. `add` restituisce `6`, che è il valore di `value`.",
    id: 138,
  },
  {
    grade: Grades.Junior,
    theme: Themes.ECMASCRIPT,
    question: "Qual è l'output?",
    code: "class Counter {\n  #number = 10\n\n  increment() {\n    this.#number++\n  }\n\n  getNum() {\n    return this.#number\n  }\n}\n\nconst counter = new Counter()\ncounter.increment()\n\nconsole.log(counter.#number)",
    correctAnswer: 4,
    variants: ["`10`", "`11`", "`undefined`", "`SyntaxError`"],
    explanation:
      "In ES2020, possiamo aggiungere variabili private nelle classi usando `#`. Non possiamo accedere a queste variabili al di fuori della classe. Quando proviamo a registrare `counter.#number`, viene generato un SyntaxError: non possiamo accedervi al di fuori della classe `Counter`!",
    id: 139,
  },
  {
    grade: Grades.Junior,
    theme: Themes.ASYNC,
    question: "Cosa manca?",
    code: "const teams = [\n  { name: 'Team 1', members: ['Paul', 'Lisa'] },\n  { name: 'Team 2', members: ['Laura', 'Tim'] },\n];\n\nfunction* getMembers(members) {\n  for (let i = 0; i < members.length; i++) {\n    yield members[i];\n  }\n}\n\nfunction* getTeams(teams) {\n  for (let i = 0; i < teams.length; i++) {\n    // ✨ SOMETHING IS MISSING HERE ✨\n  }\n}\n\nconst obj = getTeams(teams);\nobj.next(); // { value: \"Paul\", done: false }\nobj.next(); // { value: \"Lisa\", done: false }",
    correctAnswer: 2,
    variants: [
      "`yield getMembers(teams[i].members)`",
      "`yield* getMembers(teams[i].members)`",
      "`return getMembers(teams[i].members)`",
      "`return yield getMembers(teams[i].members)`",
    ],
    explanation:
      "Per scorrere i `members` in ogni elemento dell'array `teams`, dobbiamo passare `teams[i].members` alla funzione `getMembers`. La funzione restituisce un oggetto. Per scorrere ogni elemento in questo oggetto generatore, dobbiamo usare `yield*`.\n\nSe avessimo scritto `yield`, `return yield` o `return`, l'intera funzione del generatore sarebbe stata restituita la prima volta che abbiamo chiamato il metodo `next`.",
    id: 140,
  },
  {
    grade: Grades.Junior,
    theme: Themes.DATA_TYPES,
    question: "Qual è l'output?",
    code: "const person = {\n  name: 'Lydia Hallie',\n  hobbies: ['coding'],\n};\n\nfunction addHobby(hobby, hobbies = person.hobbies) {\n  hobbies.push(hobby);\n  return hobbies;\n}\n\naddHobby('running', []);\naddHobby('dancing');\naddHobby('baking', person.hobbies);\n\nconsole.log(person.hobbies);",
    correctAnswer: 3,
    variants: [
      '`["coding"]`',
      '`["coding", "dancing"]`',
      '`["coding", "dancing", "baking"]`',
      '`["coding", "running", "dancing", "baking"]`',
    ],
    explanation:
      'La funzione `addHobby` riceve due argomenti, `hobby` e `hobby` con il valore predefinito dell\'array `hobbies` sull\'oggetto `person`.\n\nPer prima cosa, invochiamo la funzione `addHobby` e passiamo `"running"` come valore per `hobby` e un array vuoto come valore per `hobby`. Poiché passiamo un array vuoto come valore per `hobby`, `"running"` viene aggiunto a questo array vuoto.\n\nQuindi, invochiamo la funzione `addHobby` e passiamo a `"dancing"` come valore per `hobby`. Non abbiamo passato un valore per `hobbies`, quindi ottiene il valore predefinito, la proprietà `hobbies` sull\'oggetto `person`. Spostiamo l\'hobby `dancing` nell\'array `person.hobbies`.\n\nInfine, invochiamo la funzione `addHobby` e passiamo `"baking"` come valore per `hobby`, e l\'array `person.hobbies` come valore per `hobby`. Spostiamo l\'hobby `baking` nell\'array `person.hobbies`.\n\nDopo aver fatto un push di `dancing` e `baking`, il valore di `person.hobbies` è `["coding", "dancing", "baking"]`',
    id: 141,
  },
  {
    grade: Grades.Junior,
    theme: Themes.CLASSES,
    question: "Qual è l'output?",
    code: 'class Bird {\n  constructor() {\n    console.log("I\'m a bird. 🦢");\n  }\n}\n\nclass Flamingo extends Bird {\n  constructor() {\n    console.log("I\'m pink. 🌸");\n    super();\n  }\n}\n\nconst pet = new Flamingo();',
    correctAnswer: 2,
    variants: [
      "`I'm pink. 🌸`",
      "`I'm pink. 🌸` `I'm a bird. 🦢`",
      "`I'm a bird. 🦢` `I'm pink. 🌸`",
      "Niente, non abbiamo chiamato alcun metodo",
    ],
    explanation:
      'Creiamo la variabile `pet` che è un\'istanza della classe `Flamingo`. Quando istanziamo questa istanza, il `constructor` su `Flamingo` viene chiamato. Per prima cosa, `"I\'m pink. 🌸"` viene loggato, dopodiché chiamiamo `super()`. \n\n`super()` chiama il costruttore della classe genitore, `Bird`. Il costruttore in `Bird` viene chiamato e registra `"I\'m a bird. 🦢"`.',
    id: 142,
  },
  {
    grade: Grades.Junior,
    theme: Themes.DATA_TYPES,
    question: "Quale delle opzioni genera un errore?",
    code: "const emojis = ['🎄', '🎅🏼', '🎁', '⭐'];\n\n/* 1 */ emojis.push('🦌');\n/* 2 */ emojis.splice(0, 2);\n/* 3 */ emojis = [...emojis, '🥂'];\n/* 4 */ emojis.length = 0;",
    correctAnswer: 4,
    variants: ["1", "1 and 2", "3 and 4", "3"],
    explanation:
      "La chiave `const` significa che non possiamo _ridichiarare_ il valore di quella variabile, è di _sola lettura_. Tuttavia, il valore stesso non è immutabile. Le proprietà dell'array `emojis` possono essere modificate, ad esempio facendo un push di nuovi valori, collegandoli o impostando la lunghezza dell'array su 0.",
    id: 143,
  },
  {
    grade: Grades.Middle,
    theme: Themes.DATA_TYPES,
    question:
      'Cosa dobbiamo aggiungere all\'oggetto `person` per ottenere `["Lydia Hallie", 21]` come output di `[...person]`?',
    code: 'const person = {\n  name: "Lydia Hallie",\n  age: 21\n}\n\n[...person] // ["Lydia Hallie", 21]',
    correctAnswer: 3,
    variants: [
      "Nulla, gli oggetti sono iterabili di default",
      "`*[Symbol.iterator]() { for (let x in this) yield* this[x] }`",
      "`*[Symbol.iterator]() { yield* Object.values(this) }`",
      "`*[Symbol.iterator]() { for (let x in this) yield this }`",
    ],
    explanation:
      "Gli oggetti non sono iterabili per impostazione predefinita. Un iterabile è un iterabile se è presente il protocollo iteratore. \nPossiamo aggiungerlo manualmente aggiungendo il simbolo dell'iteratore `[Symbol.iterator]`, che deve restituire un oggetto generatore, ad esempio trasformandolo in una funzione del generatore `*[Symbol.iterator]() {}`. Questa funzione di generazione deve fornire gli `Object.values` dell'oggetto `person` se vogliamo che restituisca l'array `[\"Lydia Hallie\", 21]`: `yield* Object.values(this)`.",
    id: 144,
  },
  {
    grade: Grades.Junior,
    theme: Themes.BASICS,
    question: "Qual è l'output?",
    code: "let count = 0;\nconst nums = [0, 1, 2, 3];\n\nnums.forEach(num => {\n\tif (num) count += 1\n})\n\nconsole.log(count)",
    correctAnswer: 3,
    variants: ["1", "2", "3", "4"],
    explanation:
      "La condizione `if` all'interno del ciclo `forEach` controlla se il valore di `num` è veritiero o falso. Poiché il primo numero nell'array `nums` è `0`, ovvero un valore falso, il blocco di codice dell'istruzione `if` non verrà eseguito. `count` viene incrementato solo per gli altri 3 numeri nell'array `nums`, `1`, `2` e `3`. Poiché `count` viene incrementato di `1` 3 volte, il valore di `count` è `3`.",
    id: 145,
  },
  {
    grade: Grades.Middle,
    theme: Themes.ECMASCRIPT,
    question: "Qual è l'output?",
    code: "function getFruit(fruits) {\n\tconsole.log(fruits?.[1]?.[1])\n}\n\ngetFruit([['🍊', '🍌'], ['🍍']])\ngetFruit()\ngetFruit([['🍍'], ['🍊', '🍌']])",
    correctAnswer: 4,
    variants: [
      "`null`, `undefined`, 🍌",
      "`[]`, `null`, 🍌",
      "`[]`, `[]`, 🍌",
      "`undefined`, `undefined`, 🍌",
    ],
    explanation:
      "Il `?` ci consente di accedere opzionalmente a proprietà nidificate più profonde all'interno degli oggetti. Stiamo cercando di registrare l'elemento sull'indice `1` all'interno del sottoarray che si trova sull'indice `1` dell'array `fruits`. Se il sottoarray sull'indice `1` nell'array `fruits` non esiste, restituirà semplicemente `undefined`. Se il sottoarray sull'indice `1` nell'array `fruits` esiste, ma questo sottoarray non ha un elemento nel suo indice `1`, restituirà comunque `undefined`.\n\nInnanzitutto, stiamo cercando di registrare il secondo elemento nel sottoarray `['🍍']` di `[['🍊', '🍌'], ['🍍']]`. Questo sottoarray contiene solo un elemento, il che significa che non c'è alcun elemento nell'indice `1`, e restituisce `undefined`.\n\nQuindi, stiamo invocando la funzione `getFruits` senza passare un valore come argomento, il che significa che `fruits` ha un valore di `undefined` per impostazione predefinita. Poiché stiamo concatenando condizionatamente l'elemento sull'indice `1` di `fruits`, restituisce `undefined` poiché questo elemento sull'indice `1` non esiste.\n\nInfine, stiamo cercando di registrare il secondo elemento nel sottoarray `['🍊', '🍌']` di `['🍍'], ['🍊', '🍌']`. L'elemento nell'indice `1` all'interno di questo sottoarray è `🍌`, che viene registrato.",
    id: 146,
  },
  {
    grade: Grades.Middle,
    theme: Themes.CLASSES,
    question: "Qual è l'output?",
    code: "class Calc {\n\tconstructor() {\n\t\tthis.count = 0 \n\t}\n\n\tincrease() {\n\t\tthis.count ++\n\t}\n}\n\nconst calc = new Calc()\nnew Calc().increase()\n\nconsole.log(calc.count)",
    correctAnswer: 1,
    variants: ["`0`", "`1`", "`undefined`", "`ReferenceError`"],
    explanation:
      "Impostiamo la variabile `calc` uguale a una nuova istanza della classe `Calc`. Quindi, istanziamo una nuova `Calc` e invochiamo il metodo `increase` su questa istanza. Poiché la proprietà count è all'interno del costruttore della classe `Calc`, la proprietà count non è condivisa sul prototipo di `Calc`. Ciò significa che il valore di count non è stato aggiornato per l'istanza a cui punta il calc, count è ancora `0`.",
    id: 147,
  },
  {
    grade: Grades.Middle,
    theme: Themes.OBJECTS,
    question: "Qual è l'output?",
    code: 'const user = {\n\temail: "e@mail.com",\n\tpassword: "12345"\n}\n\nconst updateUser = ({ email, password }) => {\n\tif (email) {\n\t\tObject.assign(user, { email })\n\t}\n\n\tif (password) {\n\t\tuser.password = password\n\t}\n\n\treturn user\n}\n\nconst updatedUser = updateUser({ email: "new@email.com" })\n\nconsole.log(updatedUser === user)',
    correctAnswer: 2,
    variants: ["`false`", "`true`", "`TypeError`", "`ReferenceError`"],
    explanation:
      "La funzione `updateUser` aggiorna i valori delle proprietà `email` e `password` sull'utente se i loro valori vengono passati alla funzione, dopodiché la funzione restituisce l'oggetto `user`. Il valore restituito dalla funzione `updateUser` è l'oggetto `user`, il che significa che il valore di `updateUser` è un riferimento allo stesso oggetto `user` a cui punta `user`. `updatedUser === user` è uguale a `true`.",
    id: 148,
  },
  {
    grade: Grades.Junior,
    theme: Themes.DATA_TYPES,
    question: "Qual è l'output?",
    code: "const fruit = ['🍌', '🍊', '🍎']\n\nfruit.slice(0, 1)\nfruit.splice(0, 1)\nfruit.unshift('🍇')\n\nconsole.log(fruit)",
    correctAnswer: 3,
    variants: [
      "`['🍌', '🍊', '🍎']`",
      "`['🍊', '🍎']`",
      "`['🍇', '🍊', '🍎']`",
      "`['🍇', '🍌', '🍊', '🍎']`",
    ],
    explanation:
      "Per prima cosa, invochiamo il metodo `slice` sull'array fruit. Il metodo slice non modifica l'array originale, ma restituisce il valore che ha tagliato fuori dall'array: l'emoji banana.\nQuindi, invochiamo il metodo `splice` sull'array fruit. Il metodo splice modifica l'array originale, il che significa che l'array fruit ora è composto da `['🍊', '🍎']`.\nInfine, invochiamo il metodo `unshift` sull'array `fruit`, che modifica l'array originale aggiungendo il valore fornito, '🍇' in questo caso, come primo elemento nell'array. L'array fruit ora è composto da `['🍇', '🍊', '🍎']`.",
    id: 149,
  },
  {
    grade: Grades.Junior,
    theme: Themes.DATA_TYPES,
    question: "Qual è l'output?",
    code: "const animals = {};\nlet dog = { emoji: '🐶' }\nlet cat = { emoji: '🐈' }\n\nanimals[dog] = { ...dog, name: \"Mara\" }\nanimals[cat] = { ...cat, name: \"Sara\" }\n\nconsole.log(animals[dog])",
    correctAnswer: 2,
    variants: [
      '`{ emoji: "🐶", name: "Mara" }`',
      '`{ emoji: "🐈", name: "Sara" }`',
      "`undefined`",
      "`ReferenceError`",
    ],
    explanation:
      'Le chiavi degli oggetti vengono convertite in stringhe.\n\nPoiché il valore di `dog` è un oggetto, `animals[dog]` significa in realtà che stiamo creando una nuova proprietà chiamata `"object Object"` uguale al nuovo oggetto. \n`animals["object Object"]` è ora uguale a `{ emoji: "🐶", name: "Mara"}`.\n\nAnche `cat` è un oggetto, il che significa che `animals[cat]` in realtà stiamo sovrascrivendo il valore di `animals["object Object"]` con le nuove proprietà cat.\n\nLoggando `animals[dog]`, o effettivamente `animals["object Object"]`, poiché la conversione dell\'oggetto `dog` in una stringa risulta `"object Object"`, restituisce  `{ emoji: "🐈", name: "Sara" }`.',
    id: 150,
  },
  {
    grade: Grades.Junior,
    theme: Themes.OBJECTS,
    question: "Qual è l'output?",
    code: 'const user = {\n\temail: "my@email.com",\n\tupdateEmail: email => {\n\t\tthis.email = email\n\t}\n}\n\nuser.updateEmail("new@email.com")\nconsole.log(user.email)',
    correctAnswer: 1,
    variants: [
      "`my@email.com`",
      "`new@email.com`",
      "`undefined`",
      "`ReferenceError`",
    ],
    explanation:
      "La funzione `updateEmail` è una arrow function e non è legata all'oggetto `user`. Ciò significa che la parola chiave `this` non si riferisce all'oggetto `user`, ma in questo caso si riferisce allo scope globale. Il valore di `email` all'interno dell'oggetto `user` non viene aggiornato. Quando si stampa il valore di `user.email`, viene restituito il valore originale ovvero `my@email.com`.",
    id: 151,
  },
  {
    grade: Grades.Junior,
    theme: Themes.ASYNC,
    question: "Qual è l'output?",
    code: "const promise1 = Promise.resolve('First')\nconst promise2 = Promise.resolve('Second')\nconst promise3 = Promise.reject('Third')\nconst promise4 = Promise.resolve('Fourth')\n\nconst runPromises = async () => {\n\tconst res1 = await Promise.all([promise1, promise2])\n\tconst res2  = await Promise.all([promise3, promise4])\n\treturn [res1, res2]\n}\n\nrunPromises()\n\t.then(res => console.log(res))\n\t.catch(err => console.log(err))",
    correctAnswer: 4,
    variants: [
      "`[['First', 'Second'], ['Fourth']]`",
      "`[['First', 'Second'], ['Third', 'Fourth']]`",
      "`[['First', 'Second']]`",
      "`'Third'`",
    ],
    explanation:
      'Il metodo `Promise.all` esegue le promise passate in parallelo. Se una promise fallisce, il metodo `Promise.all` effettua un _rejects_ con il valore della promise rifiutata. In questo caso, `promise3` ha rifiutato con il valore `"Third"`. Stiamo rilevando il valore rifiutato nel metodo `catch` concatenato sulla chiamata `runPromises` per rilevare eventuali errori all\'interno della funzione `runPromises`. Solo `"Third"` viene registrato, poiché `promise3` viene rifiutato con questo valore.',
    id: 152,
  },
  {
    grade: Grades.Junior,
    theme: Themes.OBJECTS,
    question:
      'Quale dovrebbe essere il valore di `method` per loggare ` {nome: "Lydia", età: 22} `?',
    code: 'const keys = ["name", "age"]\nconst values = ["Lydia", 22]\n\nconst method = /* ?? */\nObject[method](keys.map((_, i) => {\n\treturn [keys[i], values[i]]\n})) // { name: "Lydia", age: 22 }',
    correctAnswer: 3,
    variants: ["`entries`", "`values`", "`fromEntries`", "`forEach`"],
    explanation:
      "Il metodo `fromEntries` trasforma un array 2d in un oggetto. Il primo elemento in ogni sottoarray sarà la chiave e il secondo elemento in ogni sottoarray sarà il valore. In questo caso, stiamo mappando sull'array `keys`, che restituisce un array il cui primo elemento è l'elemento nell'array di chiavi sull'indice corrente e il secondo elemento è l'elemento dell'array di valori sull'indice corrente.\n\nQuesto crea una matrice di sottoarray contenenti le chiavi e i valori corretti, che risulta in `{ nome: \"Lydia\", età: 22 }`",
    id: 153,
  },
  {
    grade: Grades.Junior,
    theme: Themes.MISC,
    question: "Qual è l'output?",
    code: 'const createMember = ({ email, address = {}}) => {\n\tconst validEmail = /.+\\@.+\\..+/.test(email)\n\tif (!validEmail) throw new Error("Valid email pls")\n\n\treturn {\n\t\temail,\n\t\taddress: address ? address : null\n\t}\n}\n\nconst member = createMember({ email: "my@email.com" })\nconsole.log(member)',
    correctAnswer: 3,
    variants: [
      '`{ email: "my@email.com", address: null }`',
      '`{ email: "my@email.com" }`',
      '`{ email: "my@email.com", address: {} }`',
      '`{ email: "my@email.com", address: undefined }`',
    ],
    explanation:
      "Il valore predefinito di `address` è un oggetto vuoto `{}`. Quando abbiamo impostato la variabile `member` uguale all'oggetto restituito dalla funzione `createMember`, non abbiamo passato un valore per `address`, il che significa che il valore di `address` è l'oggetto vuoto predefinito `{}`. Un oggetto vuoto è un valore veritiero, il che significa che la condizione `address ? address : null` restituisce `true`. Il valore di `address` è l'oggetto vuoto `{}`.",
    id: 154,
  },
  {
    grade: Grades.Junior,
    theme: Themes.DATA_TYPES,
    question: "Qual è l'output?",
    code: 'let randomValue = { name: "Lydia" }\nrandomValue = 23\n\nif (!typeof randomValue === "string") {\n\tconsole.log("It\'s not a string!")\n} else {\n\tconsole.log("Yay it\'s a string!")\n}',
    correctAnswer: 2,
    variants: [
      "`It's not a string!`",
      "`Yay it's a string!`",
      "`TypeError`",
      "`undefined`",
    ],
    explanation:
      'La condizione all\'interno dell\'istruzione `if` controlla se il valore di `!typeof randomValue` è uguale a `"string"`. L\'operatore `!` converte il valore in un valore booleano. Se il valore è vero, il valore restituito sarà `false`, se il valore è falso, il valore restituito sarà `true`. In questo caso, il valore restituito di `typeof randomValue` è il vero valore `"number"`, il che significa che il valore di `!typeof randomValue` è il valore booleano `false`.\n\n`!typeof randomValue === "string"` restituisce sempre false, poiché stiamo effettivamente controllando `false === "string"`. Poiché la condizione ha restituito `false`, il blocco di codice dell\'istruzione `else` viene eseguito e `Yay it\'s a string!` viene registrato.',
    id: 155,
  },
];
export default questions;
