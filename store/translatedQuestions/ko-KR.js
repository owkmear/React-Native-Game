import { Grades, Themes } from "../../model";

const questions = [
  {
    grade: Grades.Junior,
    theme: Themes.DATA_TYPES,
    question: "무엇이 출력 될까요?",
    code: "function sayHi() {\n  console.log(name);\n  console.log(age);\n  var name = 'Lydia';\n  let age = 21;\n}\n\nsayHi();",
    correctAnswer: 4,
    variants: [
      "`Lydia` 그리고 `undefined`",
      "`Lydia` 그리고 `ReferenceError`",
      "`ReferenceError` 그리고 `21`",
      "`undefined` 그리고 `ReferenceError`",
    ],
    explanation:
      '함수 안에서, 우선 `var` 키워드를 사용해 `name` 변수를 선언해요. 이것은 변수를 정의한 줄에 실제로 도달할 때까지, 기본값 `undefined`으로 호이스팅 되는 것(생성단계에 메모리 공간이 설정)을 의미해요. `name` 변수를 출력하려는 줄에서 아직 변수를 정의하지 않았기 때문에, `undefined` 값을 유지해요.\n\n`var`와는 다르게 `let` 키워드(그리고 `const`)를 가진 변수는 호이스팅 되지만, _초기화_ 되지 않아요. 변수를 선언(초기화)하는 줄 전에는 접근할 수 없어요. 이건 "일시적 사각지대"라고 불려요. 변수가 선언되기 전 변수에 접근하려고 하면, JavaScript는 `ReferenceError`를 던져요.',
    id: 1,
  },
  {
    grade: Grades.Middle,
    theme: Themes.ASYNC,
    question: "무엇이 출력 될까요?",
    code: "for (var i = 0; i < 3; i++) {\n  setTimeout(() => console.log(i), 1);\n}\n\nfor (let i = 0; i < 3; i++) {\n  setTimeout(() => console.log(i), 1);\n}",
    correctAnswer: 3,
    variants: [
      "`0 1 2` 그리고 `0 1 2`",
      "`0 1 2` 그리고 `3 3 3`",
      "`3 3 3` 그리고 `0 1 2`",
    ],
    explanation:
      "JavaScript의 이벤트 큐 때문에, `setTimeout`의 콜백 함수는 루프가 실행된 _후에_ 호출돼요. 첫 번째의 루프의 변수 `i`는 `var` 키워드를 사용해 선언되어 전역 값이 돼요. 루프 동안, 단항 연산자 `++`를 사용해 매번 `i`의 값을 `1`씩 증가시켰어요. `setTimeout`콜백 함수가 호출되기까지, 첫 번째 예시에서의 `i`는 `3`이에요.\n\n두 번째 루프에서, 변수 `i`는 `let` 키워드를 사용해 선언되었어요: `let`(그리고 `const`) 키워드로 선언된 변수는 블록-스코프예요(블록은 `{ }` 사이의 모든 것). 각각을 반복하는 동안, `i`는 새로운 값을 갖게 되고, 각각의 값은 루프 스코프 안에 있어요.",
    id: 2,
  },
  {
    grade: Grades.Junior,
    theme: Themes.OBJECTS,
    question: "무엇이 출력 될까요?",
    code: "const shape = {\n  radius: 10,\n  diameter() {\n    return this.radius * 2;\n  },\n  perimeter: () => 2 * Math.PI * this.radius,\n};\n\nconsole.log(shape.diameter());\nconsole.log(shape.perimeter());",
    correctAnswer: 2,
    variants: [
      "`20` 그리고 `62.83185307179586`",
      "`20` 그리고 `NaN`",
      "`20` 그리고 `63`",
      "`NaN` 그리고 `63`",
    ],
    explanation:
      "`diameter`의 값은 일반 함수지만, `perimeter`의 값은 화살표 함수라는 점을 유의하세요.\n\n화살표 함수에서 `this` 키워드는 일반 함수와는 다르게 현재 주변 스코프를 참조해요! 이것은 `perimeter`를 부를 때 shape 객체가 아닌 그것을 둘러싼 스코프(예를 들면 window)를 참조하는 것을 의미해요.\n\n그 객체에는 `radius`라는 값은 없기 때문에 `undefined`를 반환해요.",
    id: 3,
  },
  {
    grade: Grades.Middle,
    theme: Themes.DATA_TYPES,
    question: "무엇이 출력 될까요?",
    code: "+true;\n!'Lydia';",
    correctAnswer: 1,
    variants: [
      "`1` 그리고 `false`",
      "`false` 그리고 `NaN`",
      "`false` 그리고 `false`",
    ],
    explanation:
      "단항 더하기는 피연산자를 숫자로 변환하려 해요. `true`는 `1`이고, `false`는 `0`이에요.\n\n문자열 `'Lydia'`는 참 같은 값이에요. 사실 우리가 물어본 건 \"참 같은 이 값은 거짓인가?\"예요. 이건 `false`를 반환해요.",
    id: 4,
  },
  {
    grade: Grades.Junior,
    theme: Themes.OBJECTS,
    question: "답은 어느 것일까요?",
    code: "const bird = {\n  size: 'small',\n};\n\nconst mouse = {\n  name: 'Mickey',\n  small: true,\n};",
    correctAnswer: 1,
    variants: [
      "`mouse.bird.size` 는 유효하지 않아요",
      "`mouse[bird.size]` 는 유효하지 않아요",
      "`mouse[bird['size']]` 는 유효하지 않아요",
      "이 모든 것은 유효해요.",
    ],
    explanation:
      "JavaScript에서 모든 객체의 키는 문자열이에요(심볼이 아닌 한). 객체의 키를 문자열 _형_ 으로 입력하지 않더라도, 항상 내부적으로 문자열로 변환돼요.\n\nJavaScript는 문장을 해석(또는 분)해요. 대괄호 표기를 사용하면 첫 번째 열린 대괄호 `[`를 보고 닫힌 대괄호 `]`를 찾을 때까지 진행해요. 다 찾은 후에만 문장을 평가할 거예요.\n\n`mouse[bird.size]`: 먼저 `'small'`인 `bird.size`를 평가해요. `mouse['small']` 은 `true`를 반환해요.\n\n그러나 이것은 점 표기법에서 발생하지 않아요. `mouse`가 `bird`라고 불리는 키를 가지고 있지 않기 때문에, `mouse.bird`는 `undefined`임을 의미해요. 그다음에, 점 표기법을 사용해 `size`를 물어봐요: `mouse.bird.size`. `mouse.bird`는 `undefined`이기 때문에, 사실 우리가 물어보는 건 `undefined.size`에요. 이건 유효하지 않아요, 그리고 `Cannot read property 'size' of undefined`와 비슷한 오류를 던질 거예요.",
    id: 5,
  },
  {
    grade: Grades.Junior,
    theme: Themes.OBJECTS,
    question: "무엇이 출력 될까요?",
    code: "let c = { greeting: 'Hey!' };\nlet d;\n\nd = c;\nc.greeting = 'Hello';\nconsole.log(d.greeting);",
    correctAnswer: 1,
    variants: [
      "`Hello`",
      "`Hey!`",
      "`undefined`",
      "`ReferenceError`",
      "`TypeError`",
    ],
    explanation:
      "JavaScript에서 모든 객체는 서로를 동일하게 설정하면 _참조_로 상호작용해요.\n\n우선, 변수 `c`는 객체에 대한 값을 갖고 있어요. 그 후 `c`가 객체에 가지고 있는 것과 동일한 참조를 `d`에 할당해요.\n\n![Image](https://i.imgur.com/ko5k0fs.png)\n\n하나의 객체를 변경하면, 모든 객체가 변해요.",
    id: 6,
  },
  {
    grade: Grades.Middle,
    theme: Themes.DATA_TYPES,
    question: "무엇이 출력 될까요?",
    code: "let a = 3;\nlet b = new Number(3);\nlet c = 3;\n\nconsole.log(a == b);\nconsole.log(a === b);\nconsole.log(b === c);",
    correctAnswer: 3,
    variants: [
      "`true` `false` `true`",
      "`false` `false` `true`",
      "`true` `false` `false`",
      "`false` `true` `true`",
    ],
    explanation:
      "`new Number()`는, 내장 함수 생성자예요. 숫자처럼 보이지만, 사실 숫자가 아니에요: 많은 추가 특성이 있고 그것은 객체예요.\n\n`==`연산자를 사용할 때는, 같은 _값_ 을 가졌는지 여부만 확인해요. 모두`3`의 값을 가지고 있음으로 `true`를 반환해요.\n\n그러나, `===`연산자를 사용할 때는, 값 _그리고_ 형 둘 다 같아야 해요. 이건 아니에요: `new Number()`는 숫자가 아니에요. **객체**에요. 그래서 둘 다 `false`를 반환해요.",
    id: 7,
  },
  {
    grade: Grades.Middle,
    theme: Themes.CLASSES,
    question: "무엇이 출력 될까요?",
    code: "class Chameleon {\n  static colorChange(newColor) {\n    this.newColor = newColor;\n    return this.newColor;\n  }\n\n  constructor({ newColor = 'green' } = {}) {\n    this.newColor = newColor;\n  }\n}\n\nconst freddie = new Chameleon({ newColor: 'purple' });\nconsole.log(freddie.colorChange('orange'));",
    correctAnswer: 4,
    variants: ["`orange`", "`purple`", "`green`", "`TypeError`"],
    explanation:
      "`colorChange`함수는 정적이에요. 정적 메소드는 그것이 만들어지는 생성자에서만 살아있도록 설계되어, 어떤 자식들도 상속받을 수 없어요. `freddie`는 자식이기 때문에, 이 함수는 상속되지 않아 `freddie`인스턴스에서는 이용할 수 없어요: `TypeError`가 던져져요.",
    id: 8,
  },
  {
    grade: Grades.Junior,
    theme: Themes.OBJECTS,
    question: "무엇이 출력 될까요?",
    code: "let greeting;\ngreetign = {}; // Typo!\nconsole.log(greetign);",
    correctAnswer: 1,
    variants: [
      "`{}`",
      "`ReferenceError: greetign is not defined`",
      "`undefined`",
    ],
    explanation:
      '방금 전역 객체에 빈 객체를 만들었기 때문에, 객체는 출력돼요. `greeting`을 `greettign`으로 잘못 입력했을 때, JS 인터프리터는 `global.greettign = {}` (또는 브라우저의 `window.greetign = {}`)라고 간주해요.\n\n이것을 피하려면, `"use strict"`를 사용해요. 이렇게 하면 변수를 어떤 것과 동일하게 설정하기 전에 변수를 선언했는지 확인할 수 있어요.',
    id: 9,
  },
  {
    grade: Grades.Junior,
    theme: Themes.FUNCTIONS,
    question: "이렇게 하면 무슨 일이 생길까요?",
    code: "function bark() {\n  console.log('Woof!');\n}\n\nbark.animal = 'dog';",
    correctAnswer: 1,
    variants: [
      "별일 없어요, 이건 완전히 괜찮아요!",
      "`SyntaxError` 이 방법으로 함수에 속성을 추가할 수 없어요.",
      '`"Woof"`이 출력돼요.',
      "`ReferenceError`",
    ],
    explanation:
      "JavaScript에서는 가능한데, 함수는 객체이기 때문이에요! (원시형 이외는 모두 객체)\n\n함수는 특별한 종류의 객체예요. 당신이 쓴 코드는 실제 함수가 아니에요. 함수는 속성을 가진 객체예요. 이 속성은 호출이 가능해요.",
    id: 10,
  },
  {
    grade: Grades.Junior,
    theme: Themes.CLASSES,
    question: "무엇이 출력 될까요?",
    code: "function Person(firstName, lastName) {\n  this.firstName = firstName;\n  this.lastName = lastName;\n}\n\nconst member = new Person('Lydia', 'Hallie');\nPerson.getFullName = function () {\n  return `${this.firstName} ${this.lastName}`;\n};\n\nconsole.log(member.getFullName());",
    correctAnswer: 1,
    variants: [
      "`TypeError`",
      "`SyntaxError`",
      "`Lydia Hallie`",
      "`undefined` `undefined`",
    ],
    explanation:
      "JavaScript에서, 함수는 객체이고 그렇기 때문에 메소드 `getFullName`은 생성자 함수 객체 자체에 추가돼요. 이런 이유로, 우리는 `Person.getFullName()`을 부를 수 있지만 `member.getFullName()`은 `TypeError`를 던져요.\n\n모든 객체 인스턴스에서 메소드를 사용할 수 있게 하려면, 메소드를 프로토타입 속성에 추가하세요.\n\n```js\nPerson.prototype.getFullName = function () {\n  return `${this.firstName} ${this.lastName}`;\n};\n```",
    id: 11,
  },
  {
    grade: Grades.Junior,
    theme: Themes.CLASSES,
    question: "무엇이 출력 될까요?",
    code: "function Person(firstName, lastName) {\n  this.firstName = firstName;\n  this.lastName = lastName;\n}\n\nconst lydia = new Person('Lydia', 'Hallie');\nconst sarah = Person('Sarah', 'Smith');\n\nconsole.log(lydia);\nconsole.log(sarah);",
    correctAnswer: 1,
    variants: [
      '`Person {firstName: "Lydia", lastName: "Hallie"}` 그리고 `undefined`',
      '`Person {firstName: "Lydia", lastName: "Hallie"}` 그리고 `Person {firstName: "Sarah", lastName: "Smith"}`',
      '`Person {firstName: "Lydia", lastName: "Hallie"}` 그리고 `{}`',
    ],
    explanation:
      "`sarah`에게 `new` 키워드를 사용하지 않았어요. `new`를 사용한 경우, `this`는 우리가 만든 새로운 빈 객체를 참조해요. 그러나, `new`를 추가하지 않으면 **전역 변수**를 참조해요!\n\n`this.firstName`은 `\"Sarah\"`이고, `this.lastName`은 `\"Smith\"`라고 말했었어요. (그렇지만)실제로는, `global.firstName = 'Sarah'` 그리고 `global.lastName = 'Smith'`를 정의한 거예요. `sarah` 자체는 `undefined`로 남아있어요, 그렇기 때문에 `Person`함수의 값을 반환하지 않아요.",
    id: 12,
  },
  {
    grade: Grades.Junior,
    theme: Themes.EVENTS,
    question: "이벤트 전달의 3단계는 무엇일까요?",
    code: null,
    correctAnswer: 4,
    variants: [
      "Target > Capturing > Bubbling",
      "Bubbling > Target > Capturing",
      "Target > Bubbling > Capturing",
      "Capturing > Target > Bubbling",
    ],
    explanation:
      "**capturing** 단계 동안에, 이벤트는 조상 요소를 거쳐 target 요소까지 내려가요. 그런 다음 **target** 요소에 도달하고, **bubbling**이 시작돼요.\n\n![Image](https://i.imgur.com/N18oRgd.png)",
    id: 13,
  },
  {
    grade: Grades.Junior,
    theme: Themes.CLASSES,
    question: "모든 객체는 프로토 타입을 가져요.",
    code: null,
    correctAnswer: 2,
    variants: ["true", "false"],
    explanation:
      "**기본 객체**를 제외한, 모든 객체는 프로토타입을 가져요. 기본 객체는 사용자가 만든 객체이거나 `new` 키워드를 사용해 만들어진 객체예요. 기본 객체는 `.toString`과 같은 몇 개의 메소드와 속성에 접근할 수 있어요. 이것이 내장 JavaScript 메소드를 사용할 수 있는 이유죠! 이러한 모든 메소드는 프로토타입에서 사용할 수 있어요. JavaScript가 당신의 객체를 바로 찾을 수 없더라도, 당신이 접근할 수 있도록 프로토타입 체인으로 내려가 찾을 거예요.",
    id: 14,
  },
  {
    grade: Grades.Junior,
    theme: Themes.DATA_TYPES,
    question: "무엇이 출력 될까요?",
    code: "function sum(a, b) {\n  return a + b;\n}\n\nsum(1, '2');",
    correctAnswer: 3,
    variants: ["`NaN`", "`TypeError`", "`'12'`", "`3`"],
    explanation:
      'JavaScript는 **동적으로 유형화된 언어**에요: 특정 변수가 어떤 유형인지 명시하지 않아요. 변수는 당신이 모르는 사이에 자동으로 다른 유형으로 변환될 수 있는데, 이걸 _암묵적 형 변환_ 이라고 불러요. **Coercion**은 하나의 유형을 다른 유형으로 변환해요.\n\n이 예제에서, JavaScript는 함수가 이해하고 값을 반환하도록 숫자 `1`을 문자열로 변환해요. 숫자 유형 (`1`)과 문자열 유형 (`\'2\'`)을 추가하는 동안, 숫자는 문자열로 취급돼요. `"Hello" + "World"`처럼 문자열을 연결해요, 따라서 여기서 일어나는 일은 `"1" + "2"`는 `"12"`에요.',
    id: 15,
  },
  {
    grade: Grades.Junior,
    theme: Themes.BASICS,
    question: "무엇이 출력 될까요?",
    code: "let number = 0;\nconsole.log(number++);\nconsole.log(++number);\nconsole.log(number);",
    correctAnswer: 3,
    variants: ["`1` `1` `2`", "`1` `2` `2`", "`0` `2` `2`", "`0` `1` `2`"],
    explanation:
      "**접미사** 단항 연산자 `++`:\n\n1. 값 반환 (`0`을 반환해요)\n2. 값 증가 (지금 number는 `1`이에요)\n\n**접두사** 단항 연산자 `++`:\n\n1. 값 증가 (지금 number는 `2`이에요)\n2. 값 반환 (`2`를 반환해요)\n\n`0 2 2`를 반환해요.",
    id: 16,
  },
  {
    grade: Grades.Junior,
    theme: Themes.FUNCTIONS,
    question: "무엇이 출력 될까요?",
    code: "function getPersonInfo(one, two, three) {\n  console.log(one);\n  console.log(two);\n  console.log(three);\n}\n\nconst person = 'Lydia';\nconst age = 21;\n\ngetPersonInfo`${person} is ${age} years old`;",
    correctAnswer: 2,
    variants: [
      '`"Lydia"` `21` `["", " is ", " years old"]`',
      '`["", " is ", " years old"]` `"Lydia"` `21`',
      '`"Lydia"` `["", " is ", " years old"]` `21`',
    ],
    explanation:
      "태그가 지정된 템플릿 리터럴을 사용한다면, 첫 번째 인수의 값은 항상 문자열 값의 배열이에요. 나머지 인수는 표현식을 통과한 값을 가져요.",
    id: 17,
  },
  {
    grade: Grades.Junior,
    theme: Themes.OBJECTS,
    question: "무엇이 출력 될까요?",
    code: "function checkAge(data) {\n  if (data === { age: 18 }) {\n    console.log('You are an adult!');\n  } else if (data == { age: 18 }) {\n    console.log('You are still an adult.');\n  } else {\n    console.log(`Hmm.. You don't have an age I guess`);\n  }\n}\n\ncheckAge({ age: 18 });",
    correctAnswer: 3,
    variants: [
      "`You are an adult!`",
      "`You are still an adult.`",
      "`Hmm.. You don't have an age I guess`",
    ],
    explanation:
      "동등성을 테스트할 때, 원시형은 _값_ 으로 비교되고, 객체는 _참조_ 로 비교돼요. JavaScript는 객체가 메모리 내의 같은 장소를 참조하고 있는지를 확인해요.\n\n비교하고 있는 두 개의 객체는 그것이 없어요: 파라미터로 전달된 객체와 동등성을 확인하기 위해 사용한 객체는 메모리 내의 다른 장소를 참조해요.\n\n`{ age: 18 } === { age: 18 }` 그리고 `{ age: 18 } == { age: 18 }` 두 개 다 `false`를 반환하는 이유예요.",
    id: 18,
  },
  {
    grade: Grades.Junior,
    theme: Themes.FUNCTIONS,
    question: "무엇이 출력 될까요?",
    code: "function getAge(...args) {\n  console.log(typeof args);\n}\n\ngetAge(21);",
    correctAnswer: 3,
    variants: ['`"number"`', '`"array"`', '`"object"`', '`"NaN"`'],
    explanation:
      'rest 파라미터 (`...args`)는 남아있는 모든 인수을 하나의 배열로 "집합" 해요. 배열은 객체이니까 `typeof args`는 `"object"`를 반환해요.',
    id: 19,
  },
  {
    grade: Grades.Junior,
    theme: Themes.BASICS,
    question: "무엇이 출력 될까요?",
    code: "function getAge() {\n  'use strict';\n  age = 21;\n  console.log(age);\n}\n\ngetAge();",
    correctAnswer: 3,
    variants: ["`21`", "`undefined`", "`ReferenceError`", "`TypeError`"],
    explanation:
      '`"use strict"`을 사용하면, 실수로 전역 변수를 선언하지 않게 해줘요. `age`라는 변수를 선언한 적이 전혀 없고, `"use strict"`을 사용하고 있으니, reference error를 던지게 될 거예요. 만약 `"use strict"`을 사용하지 않았다면 동작할 거예요, `age` 속성이 전역 객체에 추가된 것이기 때문이죠.',
    id: 20,
  },
  {
    grade: Grades.Junior,
    theme: Themes.BASICS,
    question: "`sum`의 값은 무엇일까요?",
    code: "const sum = eval('10*10+5');",
    correctAnswer: 1,
    variants: ["`105`", '`"105"`', "`TypeError`", '`"10*10+5"`'],
    explanation:
      "`eval` 문자열로 통과된 코드를 평가해요. 만약 그것이 이 경우처럼 표현 식이라면, 표현 식을 평가해요. 표현식은 `10 * 10 + 5`이에요. 이것은 숫자 `105`를 반환해요.",
    id: 21,
  },
  {
    grade: Grades.Junior,
    theme: Themes.STORAGE,
    question: "cool_secret에 몇 시간이나 접근이 가능할까요?",
    code: "sessionStorage.setItem('cool_secret', 123);",
    correctAnswer: 2,
    variants: [
      "영원히, 데이터는 사라지지 않아요.",
      "사용자가 탭을 닫을 때.",
      "사용자가 탭뿐만 아니라, 브라우저 전체를 닫을 때.",
      "사용자가 자신의 컴퓨터를 종료시켰을 때.",
    ],
    explanation:
      "`sessionStorage`에 저장된 데이터는 _탭_ 을 닫은 후에 삭제돼요.\n\n만약 `localStorage`를 사용했다면, 예를 들어 `localStorage.clear()`를 호출하지 않는 한, 데이터는 영원할 거예요.",
    id: 22,
  },
  {
    grade: Grades.Junior,
    theme: Themes.BASICS,
    question: "무엇이 출력 될까요?",
    code: "var num = 8;\nvar num = 10;\n\nconsole.log(num);",
    correctAnswer: 2,
    variants: ["`8`", "`10`", "`SyntaxError`", "`ReferenceError`"],
    explanation:
      "`var` 키워드를 사용하면, 같은 이름으로 복수의 변수를 선언할 수 있어요. 변수는 최신의 값을 가져요.\n\n블록 스코프의 `let` 또는 `const`에서는 할 수 없어요.",
    id: 23,
  },
  {
    grade: Grades.Junior,
    theme: Themes.DATA_TYPES,
    question: "무엇이 출력 될까요?",
    code: "const obj = { 1: 'a', 2: 'b', 3: 'c' };\nconst set = new Set([1, 2, 3, 4, 5]);\n\nobj.hasOwnProperty('1');\nobj.hasOwnProperty(1);\nset.has('1');\nset.has(1);",
    correctAnswer: 3,
    variants: [
      "`false` `true` `false` `true`",
      "`false` `true` `true` `true`",
      "`true` `true` `false` `true`",
      "`true` `true` `true` `true`",
    ],
    explanation:
      "모든 객체의 키는(심볼 제외) 문자열로 직접 입력하지 않았다고 해도 내부적으로는 문자열이에요. 이것이 `obj.hasOwnProperty('1')`도 true를 반환하는 이유예요.\n\nset에서는 동작하지 않아요. set에는 `'1'`이 없어요: `set.has('1')`은 `false`를 반환해요. 숫자 유형인 `1`을 가지고 있어, `set.has(1)`는 `true`를 반환해요.",
    id: 24,
  },
  {
    grade: Grades.Junior,
    theme: Themes.OBJECTS,
    question: "무엇이 출력 될까요?",
    code: "const obj = { a: 'one', b: 'two', a: 'three' };\nconsole.log(obj);",
    correctAnswer: 3,
    variants: [
      '`{ a: "one", b: "two" }`',
      '`{ b: "two", a: "three" }`',
      '`{ a: "three", b: "two" }`',
      "`SyntaxError`",
    ],
    explanation:
      "같은 이름의 키를 두 개 갖고 있다면, 키는 대체 될 거예요. 여전히 첫 번째 위치에 있지만, 마지막으로 지정된 값을 가져요.",
    id: 25,
  },
  {
    grade: Grades.Junior,
    theme: Themes.OBJECTS,
    question:
      'JavaScript의 전역 실행 컨텍스트는 두가지를 만들어요: 전역객체와 "this" 키워드에요.',
    code: null,
    correctAnswer: 1,
    variants: ["true", "false", "경우에 따라 달라요"],
    explanation:
      "기본적인 실행 콘텍스트는 전역 실행 문장이에요: 당신의 코드 모든 곳에서 접근할 수 있어요.",
    id: 26,
  },
  {
    grade: Grades.Junior,
    theme: Themes.BASICS,
    question: "무엇이 출력 될까요?",
    code: "for (let i = 1; i < 5; i++) {\n  if (i === 3) continue;\n  console.log(i);\n}",
    correctAnswer: 3,
    variants: ["`1` `2`", "`1` `2` `3`", "`1` `2` `4`", "`1` `3` `4`"],
    explanation:
      "`continue` 표현 식은 특정 조건이 `true`를 반환하면 반복 처리를 건너뛰어요.",
    id: 27,
  },
  {
    grade: Grades.Junior,
    theme: Themes.CLASSES,
    question: "무엇이 출력 될까요?",
    code: "String.prototype.giveLydiaPizza = () => {\n  return 'Just give Lydia pizza already!';\n};\n\nconst name = 'Lydia';\n\nname.giveLydiaPizza();",
    correctAnswer: 1,
    variants: [
      '`"Just give Lydia pizza already!"`',
      "`TypeError: not a function`",
      "`SyntaxError`",
      "`undefined`",
    ],
    explanation:
      "`String`은 내장 생성자로 속성을 추가할 수 있어요. 그냥 문자열 프로토타입에 메소드를 추가한거예요. 원시형 문자열은 문자열 프로토타입 함수가 생성한 문자열 객체로 자동 변환돼요. 그래서, 모든 문자열(문자열 객체)은 그 메소드에 접근할 수 있어요!",
    id: 28,
  },
  {
    grade: Grades.Middle,
    theme: Themes.DATA_TYPES,
    question: "무엇이 출력 될까요?",
    code: "const a = {};\nconst b = { key: 'b' };\nconst c = { key: 'c' };\n\na[b] = 123;\na[c] = 456;\n\nconsole.log(a[b]);",
    correctAnswer: 2,
    variants: ["`123`", "`456`", "`undefined`", "`ReferenceError`"],
    explanation:
      '객체 키는 자동으로 문자열로 변환돼요. 객체 `a`에 키는 객체(b), 값은 `123`으로 설정하려고 해요.\n\n그러나, 객체를 문자열화 하면 `"[object Object]"`가 돼요. 그래서 여기서 말하고자 하는 건 `a["object Object"] = 123`이라는 거예요. 그 후, 같은 일을 다시 시도해요. `c`는 암묵적으로 문자열화 한 다른 객체에요. 그래서 `a["object Object"] = 456`이 돼요.\n\n그 후, `a[b]`를 출력하면 실제로는 `a["object Object"]`예요. 그냥 `456`을 설정했기 때문에, `456`을 반환해요.',
    id: 29,
  },
  {
    grade: Grades.Junior,
    theme: Themes.ASYNC,
    question: "무엇이 출력 될까요?",
    code: "const foo = () => console.log('First');\nconst bar = () => setTimeout(() => console.log('Second'));\nconst baz = () => console.log('Third');\n\nbar();\nfoo();\nbaz();",
    correctAnswer: 2,
    variants: [
      "`First` `Second` `Third`",
      "`First` `Third` `Second`",
      "`Second` `First` `Third`",
      "`Second` `Third` `First`",
    ],
    explanation:
      '처음에 `setTimeout`함수를 호출했어요. 그러나 그것은 마지막에 출력돼요.\n\n브라우저에는 런타임 엔진뿐만 아니라 `WebAPI`라고 불리는 것도 존재해요. `WebAPI`는 `setTimeout`함수를 최초에 부여하는데, DOM을 예로 들 수 있어요.\n\n_callback_ 이 WebAPI에 푸시된 후, `setTimeout`함수 자체(callback이 아니에요!)는 stack에 사라졌어요.\n\n![Image](https://i.imgur.com/X5wsHOg.png)\n\n지금, `foo` 는 호출되었고, `"First"`는 출력되었어요.\n\n![Image](https://i.imgur.com/Pvc0dGq.png)\n\n`foo`는 stack에 사라지고, `baz`가 호출되었어요. `"Third"`가 출력되었어요.\n\n![Image](https://i.imgur.com/WhA2bCP.png)\n\nWebAPI는 준비가 될 때마다 stack에 항목을 추가할 수 없어요. 대신에, _queue_ 라고 불리는 것에 callback 함수를 푸시해요.\n\n![Image](https://i.imgur.com/NSnDZmU.png)\n\n여기서 event loop가 작동하기 시작해요. **event loop**는 stack과 task queue를 봐요. stack이 비어있다면, queue에 첫 번째의 것을 가져다가 stack 위로 푸시해요.\n\n![Image](https://i.imgur.com/uyiScAI.png)\n\n`bar`가 호출되었고, `"Second"`가 출력되었으며, stack에서 사라졌어요.',
    id: 30,
  },
  {
    grade: Grades.Junior,
    theme: Themes.EVENTS,
    question: "버튼을 클릭했을때 event.target은 무엇일까요?",
    code: null,
    correctAnswer: 3,
    variants: [
      "외부의 `div`",
      "내부의 `div`",
      "`button`",
      "중첩된 모든 요소의 배열",
    ],
    explanation:
      "가장 깊이 중첩된 요소가 이벤트를 발생시킬 이벤트 대상이예요. `event.stopPropagation`을 통해서 버블링을 중단할 수 있어요.",
    id: 31,
  },
  {
    grade: Grades.Junior,
    theme: Themes.EVENTS,
    question: "p태그를 클릭하면 출력된 로그는 무엇일까요?",
    code: null,
    correctAnswer: 1,
    variants: ["`p` `div`", "`div` `p`", "`p`", "`div`"],
    explanation:
      "`p`를 클릭하면, 2개의 로그를 볼 수 있어요: `p` 그리고 `div`. 이벤트의 전파 중에는 3단계가 있어요: 캡처링, 타겟, 버블링. 기본적으로, 이벤트 핸들러는 버블링 단계에서 시작돼요. (`useCapture`를 `true`로 설정하지 않는 한). 가장 깊게 중첩된 요소에서 바깥쪽으로 가요.",
    id: 32,
  },
  {
    grade: Grades.Junior,
    theme: Themes.FUNCTIONS,
    question: "무엇이 출력 될까요?",
    code: "const person = { name: 'Lydia' };\n\nfunction sayHi(age) {\n  console.log(`${this.name} is ${age}`);\n}\n\nsayHi.call(person, 21);\nsayHi.bind(person, 21);",
    correctAnswer: 4,
    variants: [
      "`undefined is 21` `Lydia is 21`",
      "`function` `function`",
      "`Lydia is 21` `Lydia is 21`",
      "`Lydia is 21` `function`",
    ],
    explanation:
      "두 개 모두, `this` 키워드를 참조하고자 하는 객체로 보낼 수 있어요. 그렇지만, `.call`은 _즉시 실행돼요_!\n\n`.bind.`는 함수의 _복사본_ 을 반환하지만, 바인딩된 콘텍스트죠! 즉시 실행되지 않아요.",
    id: 33,
  },
  {
    grade: Grades.Junior,
    theme: Themes.FUNCTIONS,
    question: "무엇이 출력 될까요?",
    code: "function sayHi() {\n  return (() => 0)();\n}\n\nconsole.log(typeof sayHi());",
    correctAnswer: 2,
    variants: ['`"object"`', '`"number"`', '`"function"`', '`"undefined"`'],
    explanation:
      '`sayHi`함수는 즉시 호출 함수 표현식(IIFE)으로서 반환된 값을 반환해요. 이 함수는 `0`을 반환하고, 형은 `"number"`이에요.\n\n참고: 내장된 형은 7개만 있어요: `null`, `undefined`, `boolean`, `number`, `string`, `object` 그리고 `symbol`. 함수는 객체이기 때문에 `"function"`은 형이 아니라 `"object"`형이에요.',
    id: 34,
  },
  {
    grade: Grades.Middle,
    theme: Themes.BASICS,
    question: "이 값 중 어느 것이 거짓 같은 값일까요?",
    code: "0;\nnew Number(0);\n('');\n(' ');\nnew Boolean(false);\nundefined;",
    correctAnswer: 1,
    variants: [
      "`0`, `''`, `undefined`",
      "`0`, `new Number(0)`, `''`, `new Boolean(false)`, `undefined`",
      "`0`, `''`, `new Boolean(false)`, `undefined`",
      "모든 값은 거짓",
    ],
    explanation:
      "8개의 거짓 같은 값이 있어요:\n\n- `undefined`\n- `null`\n- `NaN`\n- `false`\n- `''` (빈 문자열)\n- `0`\n- `-0`\n- `-0n` (BigInt(0))\n\n`new Number` 그리고 `new Boolean`과 같은 생성자 함수는 참 같은 값이에요.",
    id: 35,
  },
  {
    grade: Grades.Junior,
    theme: Themes.DATA_TYPES,
    question: "무엇이 출력 될까요?",
    code: "console.log(typeof typeof 1);",
    correctAnswer: 2,
    variants: ['`"number"`', '`"string"`', '`"object"`', '`"undefined"`'],
    explanation:
      '`typeof 1` 은 `"number"`를 반환해요.\n`typeof "number"`은 `"string"`을 반환해요.',
    id: 36,
  },
  {
    grade: Grades.Junior,
    theme: Themes.BASICS,
    question: "무엇이 출력 될까요?",
    code: "const numbers = [1, 2, 3];\nnumbers[10] = 11;\nconsole.log(numbers);",
    correctAnswer: 3,
    variants: [
      "`[1, 2, 3, 7 x null, 11]`",
      "`[1, 2, 3, 11]`",
      "`[1, 2, 3, 7 x empty, 11]`",
      "`SyntaxError`",
    ],
    explanation:
      '배열의 길이를 초과한 값을 배열의 요소로 설정하고자 할 때, JavaScript는 "empty slots"라고 불리는 것을 생성해요. 이것은 사실 `undefined`의 값을 가지고 있지만, 다음과 같은 것을 보게 될 거예요:\n\n`[1, 2, 3, 7 x empty, 11]`\n\n실행 위치에 따라 달라요 (브라우저, node 등마다 달라요.)',
    id: 37,
  },
  {
    grade: Grades.Middle,
    theme: Themes.FUNCTIONS,
    question: "무엇이 출력 될까요?",
    code: "(() => {\n  let x, y;\n  try {\n    throw new Error();\n  } catch (x) {\n    (x = 1), (y = 2);\n    console.log(x);\n  }\n  console.log(x);\n  console.log(y);\n})();",
    correctAnswer: 1,
    variants: [
      "`1` `undefined` `2`",
      "`undefined` `undefined` `undefined`",
      "`1` `1` `2`",
      "`1` `undefined` `undefined`",
    ],
    explanation:
      "`catch`블록은 인수`x`를 받아요. 이것은 인수를 전달할 때 변수로서의 `x`와는 달라요. 이 `x` 변수는 블록-스코프예요.\n\n후에, 블록-스코프 변수는 `1`로 설정하고, 변수 `y`의 값을 설정해요. 여기서, 블록-스코프의 변수 `x`를 출력하는데, 이것은 `1`이에요.\n\n`catch` 블록 밖에서, `x`는 여전히 `undefined`이고 `y`는 `2`이에요. `catch` 블록 밖에서 `console.log(x)`를 출력하면, `undefined`를 반환하고. 그리고 `y`는 `2`를 반환해요.",
    id: 38,
  },
  {
    grade: Grades.Junior,
    theme: Themes.DATA_TYPES,
    question: "JavaScript의 모든 것은...",
    code: null,
    correctAnswer: 1,
    variants: [
      "primitive 또는 object",
      "function 또는 object",
      "함정 문제! objects만",
      "number 또는 object",
    ],
    explanation:
      "JavaScript는 원시형과 객체만 가지고 있어요.\n\n원시형은 `boolean`, `null`, `undefined`, `bigint`, `number`, `string` 그리고 `symbol`이 있어요.\n\n원시형과 객체를 구별하는 법은 원시형에는 속성이나 메소드가 없어요. 그렇지만 `'foo'.toUpperCase()`는 `'FOO'`로 평가되어, 결과적으로 `TypeError`가 되지 않아요. 문자열과 같은 원시형이 속성 또는 메소드에 접근하려고 할 때, JavaScript는 래퍼 클래스 중 하나인 `String`을 사용하여 암묵적으로 감싸고, 표현 식이 평가된 후 즉시 래퍼를 폐기하기 때문이에요. `null` 그리고 `undefined`를 제외한 모든 원시형은 이러한 행동을 합니다.",
    id: 39,
  },
  {
    grade: Grades.Junior,
    theme: Themes.BASICS,
    question: "무엇이 출력 될까요?",
    code: "[\n  [0, 1],\n  [2, 3],\n].reduce(\n  (acc, cur) => {\n    return acc.concat(cur);\n  },\n  [1, 2]\n);",
    correctAnswer: 3,
    variants: [
      "`[0, 1, 2, 3, 1, 2]`",
      "`[6, 1, 2]`",
      "`[1, 2, 0, 1, 2, 3]`",
      "`[1, 2, 6]`",
    ],
    explanation:
      "`[1, 2]`은 초기값이에요. 이것은 시작하는 최초의 값이고, `acc`의 제일 처음 값이에요. 처음 라운드 동안에 `acc`는 `[1,2]`이며, `cur`은 `[0, 1]`이에요. 그것을 연결하면 결과적으로 `[1, 2, 0, 1]`이 돼요.\n\n그 후, `[1, 2, 0, 1]`은 `acc`이고, `[2, 3]`은 `cur`이에요. 그것을 연결하면 `[1, 2, 0, 1, 2, 3]`을 얻게 돼요.",
    id: 40,
  },
  {
    grade: Grades.Junior,
    theme: Themes.BASICS,
    question: "무엇이 출력 될까요?",
    code: "!!null;\n!!'';\n!!1;",
    correctAnswer: 2,
    variants: [
      "`false` `true` `false`",
      "`false` `false` `true`",
      "`false` `true` `true`",
      "`true` `true` `false`",
    ],
    explanation:
      '`null`은 거짓 같은 값이에요. `!null`은 `true`를 반환해요. `!true`는 `false`를 반환해요.\n\n`""` 은 거짓 같은 값이에요. `!""`은 `true`를 반환해요. `!true`는 `false`를 반환해요.\n\n`1`은 참 같은 값이에요. `!1`은 `false`를 반환해요. `!false`는 `true`를 반환해요.',
    id: 41,
  },
  {
    grade: Grades.Junior,
    theme: Themes.FUNCTIONS,
    question: "`setInterval` 메소드는 브라우저에게 무엇을 반환 할까요?",
    code: "setInterval(() => console.log('Hi'), 1000);",
    correctAnswer: 1,
    variants: ["유니크한 id", "지정된 밀리초", "통과된 함수", "`undefined`"],
    explanation:
      "이것은 유니크한 id를 반환해요. 이 id는 `clearInterval()` 함수의 간격을 없애기 위해 사용될 수 있어요.",
    id: 42,
  },
  {
    grade: Grades.Junior,
    theme: Themes.DATA_TYPES,
    question: "이것은 무엇을 반환할까요?",
    code: "[...'Lydia'];",
    correctAnswer: 1,
    variants: [
      '`["L", "y", "d", "i", "a"]`',
      '`["Lydia"]`',
      '`[[], "Lydia"]`',
      '`[["L", "y", "d", "i", "a"]]`',
    ],
    explanation:
      "문자열은 반복 가능한 객체예요. spread 연산자는 반복 가능한 객체의 모든 문자를 하나의 요소로 매핑해요.",
    id: 43,
  },
  {
    grade: Grades.Junior,
    theme: Themes.ASYNC,
    question: "무엇이 출력 될까요?",
    code: "function* generator(i) {\n  yield i;\n  yield i * 2;\n}\n\nconst gen = generator(10);\n\nconsole.log(gen.next().value);\nconsole.log(gen.next().value);",
    correctAnswer: 3,
    variants: [
      "`[0, 10], [10, 20]`",
      "`20, 20`",
      "`10, 20`",
      "`0, 10` 그리고 `10, 20`",
    ],
    explanation:
      '일반 함수는 호출 한 뒤 중간에 멈출 수 없어요. 하지만, 제너레이터 함수는 중간에 "멈췄다가", 나중에 중단된 부분부터 계속할 수 있어요. 제너레이터 함수는 `yield` 키워드를 만날 때마다, yield 뒤에 명시된 값을 넘겨줘요. 제너레이터 함수에서는 값을 _반환_ 하지 않고, 값을 _넘겨진다_ 는 것을 유의하세요.\n\n우선, 제너레이터 함수에서 `i`를 `10`으로 초기화해요. `next()` 메소드를 사용해 제너레이터 함수를 호출해요. 처음에 제너레이터 함수를 호출하면, `i`은 `10`이에요. 첫 번째 `yield` 키워드를 만났어요: 그것은 `i`의 값을 넘겨줘요. 이제 제너레이터는 "멈추고", `10`을 출력해요.\n\n그 후, `next()` 메소드를 사용해 함수를 다시 호출해요. 이전에 멈춘 부분에서부터 다시 시작하고, `i`는 여전히 `10`이에요. 이제, 다음 `yield` 키워드를 만나 `i * 2`를 넘겨줘요. `i`는 `10`이므로, `10 * 2`, 즉 `20`을 반환해요. 결과는 `10, 20`이에요.',
    id: 44,
  },
  {
    grade: Grades.Junior,
    theme: Themes.FUNCTIONS,
    question: "이것은 무엇을 반환할까요?",
    code: "const firstPromise = new Promise((res, rej) => {\n  setTimeout(res, 500, 'one');\n});\n\nconst secondPromise = new Promise((res, rej) => {\n  setTimeout(res, 100, 'two');\n});\n\nPromise.race([firstPromise, secondPromise]).then((res) => console.log(res));",
    correctAnswer: 2,
    variants: ['`"one"`', '`"two"`', '`"two" "one"`', '`"one" "two"`'],
    explanation:
      "복수의 프로미스를 `Promise.race` 메소드에 넘겨주면, _최초_ 의 프로미스를 해결/거부해요. `setTimeout` 메소드에 타이머를 전달해요: 첫 번째 프로미스(`firstPromise`)에는 500ms, 두 번째 프로미스(`secondPromise`)에는 100ms. 이것은 `'two'`의 값을 가진 `secondPromise`를 최초로 해결한다는 것을 의미해요. 이제 `res`는 `'two'`의 값을 갖고 출력돼요.",
    id: 45,
  },
  {
    grade: Grades.Junior,
    theme: Themes.OBJECTS,
    question: "무엇이 출력 될까요?",
    code: "let person = { name: 'Lydia' };\nconst members = [person];\nperson = null;\n\nconsole.log(members);",
    correctAnswer: 4,
    variants: ["`null`", "`[null]`", "`[{}]`", '`[{ name: "Lydia" }]`'],
    explanation:
      "우선, 변수 `person`의 값을 `name` 속성을 가진 객체로 선언해요.\n\n![Image](https://i.imgur.com/TML1MbS.png)\n\n그 후, `members`라는 변수를 선언해요. 배열의 첫 번째 요소에 `person` 변수의 값을 대입해요. 서로를 같게 설정하면 _참조_로 상호작용해요. 어떤 변수에서 다른 변수로 참조를 할당하면, 그 참조의 _복사본_ 을 만들어요. (그들은 _같은_ 참조를 가지고 있지 않다는 것을 유의하세요!)\n\n![Image](https://i.imgur.com/FSG5K3F.png)\n\n그리고, 변수 `person`을 `null`로 설정해요.\n\n![Image](https://i.imgur.com/sYjcsMT.png)\n\n`person` 변수의 값만 변경할 수 있고, 배열의 첫 번째 요소는 객체에 대한 다른 (복사된) 참조를 가지고 있기 때문에 변경할 수 없어요. `members`의 첫 번째 요소는 여전히 원본 객체에 대한 참조를 유지하고 있어요. `members` 배열을 출력할 때, 첫 번째 요소는 여전히 객체의 값을 갖고 있어 로그가 출력돼요.",
    id: 46,
  },
  {
    grade: Grades.Junior,
    theme: Themes.DATA_TYPES,
    question: "무엇이 출력 될까요?",
    code: "const person = {\n  name: 'Lydia',\n  age: 21,\n};\n\nfor (const item in person) {\n  console.log(item);\n}",
    correctAnswer: 2,
    variants: [
      '`{ name: "Lydia" }, { age: 21 }`',
      '`"name", "age"`',
      '`"Lydia", 21`',
      '`["name", "Lydia"], ["age", 21]`',
    ],
    explanation:
      "`for-in` 루프를 사용하면, 객체의 키를 통해서 반복할 수 있는데, 이 경우에서는 `name` 그리고 `age`에요. 내부적으로, 객체의 키는 문자열이에요 (심볼이 아니라면 말이죠). 모든 루프에서, `item`의 값은 반복 중인 현재의 키 값으로 동일하게 설정해요. 우선, `item`은 `name`으로 출력돼요. 그 후, `item`은 `age`로 출력돼요.",
    id: 47,
  },
  {
    grade: Grades.Junior,
    theme: Themes.BASICS,
    question: "무엇이 출력 될까요?",
    code: "console.log(3 + 4 + '5');",
    correctAnswer: 2,
    variants: ['`"345"`', '`"75"`', "`12`", '`"12"`'],
    explanation:
      '연산자 결합성은 왼쪽에서 오른쪽 또는 오른쪽에서 왼쪽으로 컴파일러가 표현 식을 평가하는 순서가 돼요. 이것은 연산자가 _같은_ 우선순위를 가진 경우에만 해당돼요. 한 유형의 연산자만 있어요: `+`. 게다가, 결합성은 왼쪽에서 오른쪽이에요.\n\n처음으로 `3 + 4`가 평가돼요. 결과는 숫자 `7`이에요.\n\n`7 + \'5\'`의 결과는 강제성 때문에 `"75"`가 돼요. JavaScript는 숫자 `7`을 문자열로 변환하고, (관련된 자세한 설명은) 질문 15를 보세요. `+` 연산자를 사용해서 두 개의 문자열을 연결할 수 있어요. `"7" + "5"`의 결과는 `"75"`이에요.',
    id: 48,
  },
  {
    grade: Grades.Junior,
    theme: Themes.DATA_TYPES,
    question: "`num`의 값은 무엇일까요?",
    code: "const num = parseInt('7*6', 10);",
    correctAnswer: 3,
    variants: ["`42`", '`"42"`', "`7`", "`NaN`"],
    explanation:
      '문자열의 첫 번째 숫자만 반환돼요. _진법_ 에 근거해(파싱하고자 하는 숫자의 기준을 명시하기 위한 두 번째 인수: 기본 10진수, 6진수, 8진수, 2진수 등), `parseInt`는 문자열 내의 문자가 타당한지 여부를 확인해요. 진수에 유효한 숫자가 아닌 문자를 만나면, 파싱을 멈추고, 다음 문자를 무시해요.\n\n`*`은 유효한 숫자가 아니에요. `"7"`만 십진수의 `7`로 파싱 돼요. 이제 `num`은 `7`의 값을 가져요.',
    id: 49,
  },
  {
    grade: Grades.Junior,
    theme: Themes.DATA_TYPES,
    question: "무엇이 출력 될까요?",
    code: "[1, 2, 3].map((num) => {\n  if (typeof num === 'number') return;\n  return num * 2;\n});",
    correctAnswer: 3,
    variants: [
      "`[]`",
      "`[null, null, null]`",
      "`[undefined, undefined, undefined]`",
      "`[ 3 x empty ]`",
    ],
    explanation:
      '배열을 매핑할 때, `num`의 값은 헌재 순환하고 있는 요소예요. 이 경우 요소는 숫자이기 때문에, if 문의 조건 `typeof num === "number"`는 `true`를 반환해요. map 함수는 새로운 배열을 만들고 함수에서 반환된 값을 삽입해요.\n\n그러나, 우리는 값을 반환하지 않아요. 함수는 값을 반환하지 않을 때 `undefined`를 반환해요. 배열에서의 모든 요소에 대해 함수 블록이 호출되므로, 각 요소에 대해 `undefined`를 반환해요.',
    id: 50,
  },
  {
    grade: Grades.Junior,
    theme: Themes.OBJECTS,
    question: "무엇이 출력 될까요?",
    code: "function getInfo(member, year) {\n  member.name = 'Lydia';\n  year = '1998';\n}\n\nconst person = { name: 'Sarah' };\nconst birthYear = '1997';\n\ngetInfo(person, birthYear);\n\nconsole.log(person, birthYear);",
    correctAnswer: 1,
    variants: [
      '`{ name: "Lydia" }, "1997"`',
      '`{ name: "Sarah" }, "1998"`',
      '`{ name: "Lydia" }, "1998"`',
      '`{ name: "Sarah" }, "1997"`',
    ],
    explanation:
      '인수는 값이 객체가 아니면 _값_ 으로 전달되고, 그렇지 않으면(값이 객체면) _참조_ 로 전달돼요. `birthYear`는 객체가 아니라 문자열이기 때문에 값으로 전달돼요. 값으로 전달하면 값의 _복사본_ 이 만들어져요(질문 46을 보세요).\n\n변수 `birthYear`는 `"1997"`값에 대한 참조를 가져요. 인수 `year` 또한 `"1997"`에 대한 참조를 가지지만, `birthYear`가 가진 참조 값과는 달라요. `year`에 `"1998"`을 대입하여 `year`의 값을 업데이트할 때, `year`의 값만 업데이트해요. `birthYear`는 여전히 `"1997"`이에요.\n\n`person`의 값은 객체예요. 인수 `member`는 _같은_ 객체의 (복사된) 참조를 가져요. 참조를 가진 `member`객체의 속성을 변경하면, 두 개 모두 같은 객체의 참조를 가지고 있기 때문에, `person`도 변경돼요. 이제 `person`\'의 `name` 속성의 값은 `"Lydia"`예요.',
    id: 51,
  },
  {
    grade: Grades.Junior,
    theme: Themes.ERRORS,
    question: "무엇이 출력 될까요?",
    code: "function greeting() {\n  throw 'Hello world!';\n}\n\nfunction sayHi() {\n  try {\n    const data = greeting();\n    console.log('It worked!', data);\n  } catch (e) {\n    console.log('Oh no an error:', e);\n  }\n}\n\nsayHi();",
    correctAnswer: 4,
    variants: [
      '`"It worked! Hello world!"`',
      '`"Oh no an error: undefined"`',
      "`SyntaxError: can only throw Error objects`",
      '`"Oh no an error: Hello world!"`',
    ],
    explanation:
      "`throw`문을 사용해, 사용자 지정 오류를 만들 수 있어요. 이 표현 식을 사용해, 예외를 던질 수 있어요. 예외는 <b>문자열</b>, <b>숫자</b>, <b>불린</b> 또는 <b>객체</b>가 될 수 있어요. 이 경우, 예외는 `'Hello world'` 문자열이에요.\n\n`catch` 문을 사용해, `try` 블록에서 예외를 던진 경우 무엇을 할지 명시할 수 있어요. 예외가 던져졌어요: 문자열 `'Hello world'`. 이제 `e`는 문자열이고, 그것을 출력해요. 결과는 `'Oh an error: Hello world'`예요.",
    id: 52,
  },
  {
    grade: Grades.Junior,
    theme: Themes.FUNCTIONS,
    question: "무엇이 출력 될까요?",
    code: "function Car() {\n  this.make = 'Lamborghini';\n  return { make: 'Maserati' };\n}\n\nconst myCar = new Car();\nconsole.log(myCar.make);",
    correctAnswer: 2,
    variants: [
      '`"Lamborghini"`',
      '`"Maserati"`',
      "`ReferenceError`",
      "`TypeError`",
    ],
    explanation:
      '속성을 반환할 때, 속성값은 생성자에 설정한 값이 아닌, _반환된_ 값과 같아요. `"Maserati"` 문자열을 반환하기 때문에, `myCar.make`는 `"Maserati"`예요.',
    id: 53,
  },
  {
    grade: Grades.Senior,
    theme: Themes.OBJECTS,
    question: "무엇이 출력 될까요?",
    code: "(() => {\n  let x = (y = 10);\n})();\n\nconsole.log(typeof x);\nconsole.log(typeof y);",
    correctAnswer: 1,
    variants: [
      '`"undefined", "number"`',
      '`"number", "number"`',
      '`"object", "number"`',
      '`"number", "undefined"`',
    ],
    explanation:
      '`let x = y = 10;`은 다음의 단축형이에요:\n\n``` js\ny = 10;\nlet x = y;\n```\n\n`y`에 `10`을 대입하면, 전역 객체에 속성 `y`를 추가해요(브라우저에서는 `window`, Node에서는 `global`). 브라우저에서, `window.y`는 이제 `10`이에요.\n\n그 후, 변수 `x`를 `10`인 `y`를 값으로 선언해요. `let`키워드로 선언된 변수는 _블록 스코프_ 로, 선언된 블록 내에서만 정의돼요: 이 경우에선 즉시 호출 함수예요(IIFE). `typeof`연산자를 사용할 때, 피연산자 `x`는 정의되지 않았어요: 우리는 선언된 블록 밖에서 접근하려 했어요. 이것은 `x`가 정의되지 않았음을 의미해요. 값을 할당하지 않거나 선언하지 않은 변수는 `"undefined"` 형이에요. `console.log(typeof x)`는 `"undefined"`를 반환해요.\n\n그러나, `y`를 `10`으로 설정할 때 전역 변수 `y`를 만들었어요. 이 값은 코드 내 어디에서나 접근할 수 있어요. `y`는 정의되어있고, `"number"`형의 값을 유지해요. `console.log(typeof y)`는 `"number"`을 반환해요.',
    id: 54,
  },
  {
    grade: Grades.Middle,
    theme: Themes.CLASSES,
    question: "무엇이 출력 될까요?",
    code: "class Dog {\n  constructor(name) {\n    this.name = name;\n  }\n}\n\nDog.prototype.bark = function () {\n  console.log(`Woof I am ${this.name}`);\n};\n\nconst pet = new Dog('Mara');\n\npet.bark();\n\ndelete Dog.prototype.bark;\n\npet.bark();",
    correctAnswer: 1,
    variants: [
      '`"Woof I am Mara"`, `TypeError`',
      '`"Woof I am Mara"`, `"Woof I am Mara"`',
      '`"Woof I am Mara"`, `undefined`',
      "`TypeError`, `TypeError`",
    ],
    explanation:
      "프로토타입에서도 `delete`키워드를 사용해 객체의 속성을 삭제할 수 있어요. 프로토타입에서 속성을 삭제하면, 프로토타입 체인에서 더는 사용할 수 없어요. 이 경우, `bark` 함수는 `delete Dog.prototype.bark` 후에는 프로토타입에서 더는 사용할 수 없게 되었어요, 그러나 우리는 여전히 그것에 접근하려고 해요.\n\n함수가 아닌 것을 호출하려고 할 때, `TypeError`가 던져져요. 이 경우 `pet.bark`는 `undefined`이기 때문에, `TypeError: pet.bark is not a function`예요.",
    id: 55,
  },
  {
    grade: Grades.Junior,
    theme: Themes.DATA_TYPES,
    question: "무엇이 출력 될까요?",
    code: "const set = new Set([1, 1, 2, 3, 4]);\n\nconsole.log(set);",
    correctAnswer: 4,
    variants: [
      "`[1, 1, 2, 3, 4]`",
      "`[1, 2, 3, 4]`",
      "`{1, 1, 2, 3, 4}`",
      "`{1, 2, 3, 4}`",
    ],
    explanation:
      "`Set`은 _unique_ 값의 집합 객체예요: 값은 set 내에서 단 한 번만 발생해요.\n\n중복 값 `1`을 가진 반복 가능한 `[1, 1, 2, 3, 4]`을 전달하기 때문에, 그 중 하나는 삭제돼요. 이것은 결과적으로 `{1, 2, 3, 4}`돼요.",
    id: 56,
  },
  {
    grade: Grades.Middle,
    theme: Themes.MODULES,
    question: "무엇이 출력 될까요?",
    code: "// counter.js\nlet counter = 10;\nexport default counter;",
    correctAnswer: 3,
    variants: ["`10`", "`11`", "`Error`", "`NaN`"],
    explanation:
      "import 된 모듈은 _read-only_ 예요 : import 된 모듈은 수정할 수 없어요. export 한 모듈에서만 값을 변경할 수 있어요.\n\n`myCounter`의 값을 증가시키려고 할 때, 오류를 던져요: `myCounter`는 read-only이고 수정할 수 없어요.",
    id: 57,
  },
  {
    grade: Grades.Junior,
    theme: Themes.OBJECTS,
    question: "무엇이 출력 될까요?",
    code: 'const name = "Lydia";\nage = 21;\n\nconsole.log(delete name);\nconsole.log(delete age);',
    correctAnswer: 1,
    variants: [
      "`false`, `true`",
      '`"Lydia"`, `21`',
      "`true`, `true`",
      "`undefined`, `undefined`",
    ],
    explanation:
      "`delete`연산자는 불린 값을 반환해요: 성공적으로 삭제를 한 경우 `true`를, 그렇지 않다면 `false`를 반환해요. 그러나, `var`, `const` 또는 `let` 키워드로 선언된 변수은 `delete`연산자를 사용해서 삭제될 수 없어요.\n\n`name` 변수는 `const`키워드로 선언되었기 때문에, 삭제에 실패해요: `false`가 반환돼요. `age`를 `21`로 설정할 때, 사실은 `age`라는 속성을 전역 객체에 추가한 거죠. 이 방법으로 객체, 전역 객체의 속성을 성공적으로 삭제할 수 있어요, 그래서 `delete age`는 `true`를 반환해요.",
    id: 58,
  },
  {
    grade: Grades.Junior,
    theme: Themes.BASICS,
    question: "무엇이 출력 될까요?",
    code: "const numbers = [1, 2, 3, 4, 5];\nconst [y] = numbers;\n\nconsole.log(y);",
    correctAnswer: 3,
    variants: ["`[[1, 2, 3, 4, 5]]`", "`[1, 2, 3, 4, 5]`", "`1`", "`[1]`"],
    explanation:
      "구조 분해 할당을 통해 객체의 배열 또는 속성으로부터 변수를 해체할 수 있어요. 예를 들어:\n\n``` js\n[a, b] = [1, 2];\n```\n\n![Image](https://i.imgur.com/ADFpVop.png)\n\n`a`의 값은 이제 `1`이고, `b`의 값은 이제 `2`예요. 사실 이 질문에서 한 건 다음과 같아요:\n\n``` js\n[y] = [1, 2, 3, 4, 5];\n```\n\n![Image](https://i.imgur.com/NzGkMNk.png)\n\n이것은 `y`의 값은 숫자 `1`인 배열의 첫 번째 값과 같다는 것을 의미해요. `y`를 출력하면 `1`이 반환돼요.",
    id: 59,
  },
  {
    grade: Grades.Junior,
    theme: Themes.DATA_TYPES,
    question: "무엇이 출력 될까요?",
    code: "const user = { name: 'Lydia', age: 21 };\nconst admin = { admin: true, ...user };\n\nconsole.log(admin);",
    correctAnswer: 2,
    variants: [
      '`{ admin: true, user: { name: "Lydia", age: 21 } }`',
      '`{ admin: true, name: "Lydia", age: 21 }`',
      '`{ admin: true, user: ["Lydia", 21] }`',
      "`{ admin: true }`",
    ],
    explanation:
      'spread 연산자 `...` 를 사용해 객체를 결합할 수 있어요. 이것은 한 객체의 키/값 쌍을 복사본으로 만들어, 다른 객체에 추가해요. 이 경우, `user` 객체의 복사본을 만들어, `admin` 객체에 추가해요. `admin` 객체는 이제 복사된 키/값 쌍이 들어있고, 결과는 `{ admin: true, name: "Lydia", age: 21 }` 예요.',
    id: 60,
  },
  {
    grade: Grades.Junior,
    theme: Themes.OBJECTS,
    question: "무엇이 출력 될까요?",
    code: "const person = { name: 'Lydia' };\n\nObject.defineProperty(person, 'age', { value: 21 });\n\nconsole.log(person);\nconsole.log(Object.keys(person));",
    correctAnswer: 2,
    variants: [
      '`{ name: "Lydia", age: 21 }`, `["name", "age"]`',
      '`{ name: "Lydia", age: 21 }`, `["name"]`',
      '`{ name: "Lydia"}`, `["name", "age"]`',
      '`{ name: "Lydia"}`, `["age"]`',
    ],
    explanation:
      '`defineProperty`메소드를 사용해, 객체에 새로운 속성을 추가하거나 기존 속성을 수정할 수 있어요. `defineProperty` 메소드를 사용해 객체의 속성을 추가할 때, 객체의 속성은 기본적으로 _비 열거자_ 예요. `Object.keys`메소드는 모든 _열거자_ 객체의 속성 이름을 반환하는데, 이 경우는 `"name"` 뿐이에요.\n\n`defineProperty`를 사용해 추가된 속성은 기본적으로 변경할 수 없어요. `writable`, `configurable` 그리고 `enumerable` 속성을 사용해 덮어쓸 수 있어요. `defineProperty`메소드를 사용하는 방법은 객체에 추가하는 속성을 훨씬 더 많이 제어할 수 있어요.',
    id: 61,
  },
  {
    grade: Grades.Junior,
    theme: Themes.DATA_TYPES,
    question: "무엇이 출력 될까요?",
    code: "const settings = {\n  username: 'lydiahallie',\n  level: 19,\n  health: 90,\n};\n\nconst data = JSON.stringify(settings, ['level', 'health']);\nconsole.log(data);",
    correctAnswer: 1,
    variants: [
      '`"{"level":19, "health":90}"`',
      '`"{"username": "lydiahallie"}"`',
      '`"["level", "health"]"`',
      '`"{"username": "lydiahallie", "level":19, "health":90}"`',
    ],
    explanation:
      '`JSON.stringify` 두 번째 인수는 _replacer_ 예요. replacer는 함수 또는 배열일 수 있고, 문자열로 변환 할 대상과 방법을 제어할 수 있게 해줘요.\n\nreplacer가 _배열_ 이라면, 배열에 포함된 속성의 이름만 JSON 문자열에 추가될 거에요. 이 경우, 이름을 가진 `"level"` 그리고 `"health"`속성만 포함되고, `"username"`은 제외 돼요. `data` 은 이제 `"{"level":19, "health":90}"`에요.\n\nreplacer가 _함수_ 라면, 문자열로 변환 할 객체의 모든 속성에 호출돼요. 이 함수로부터 반환된 값은 JSON 문자열에 추가될 때 속성의 값이 될 거예요. 만약 값이 `undefined`라면, 이 속성은 JSON 문자열에서 제외돼요.',
    id: 62,
  },
  {
    grade: Grades.Middle,
    theme: Themes.FUNCTIONS,
    question: "무엇이 출력 될까요?",
    code: "let num = 10;\n\nconst increaseNumber = () => num++;\nconst increasePassedNumber = number => number++;\n\nconst num1 = increaseNumber();\nconst num2 = increasePassedNumber(num1);\n\nconsole.log(num1);\nconsole.log(num2);",
    correctAnswer: 1,
    variants: ["`10`, `10`", "`10`, `11`", "`11`, `11`", "`11`, `12`"],
    explanation:
      "단항 연산자 `++`는 _우선_ 피연산자의 값을 _반환하고_, _그 후_ 피연산자의 값을 _증가시켜요_. `increaseNumber` 함수가 처음으로 반환 한 `num`의 값은 `10` 이기 때문에, `num1`의 값은 `10`이고, 그 후엔 `num`의 값만 증가해요.\n\n`num1`을 `increasePassedNumber`로 전달했기 때문에, `num2`는 `10`이에요. `number`는 `10`이에요(`num1`의 값. 다시, 단항 연산자가 `++`는 _우선_ 피연산자의 값을 _반환하고_, _그 후_ 피연산자의 값을 _증가해요_. `number`의 값은 `10`이에요 즉, `num2`는 `10`이죠.",
    id: 63,
  },
  {
    grade: Grades.Junior,
    theme: Themes.DATA_TYPES,
    question: "무엇이 출력 될까요?",
    code: "const value = { number: 10 };\n\nconst multiply = (x = { ...value }) => {\n  console.log((x.number *= 2));\n};\n\nmultiply();\nmultiply();\nmultiply(value);\nmultiply(value);",
    correctAnswer: 3,
    variants: [
      "`20`, `40`, `80`, `160`",
      "`20`, `40`, `20`, `40`",
      "`20`, `20`, `20`, `40`",
      "`NaN`, `NaN`, `20`, `40`",
    ],
    explanation:
      'ES6에서, 기본값으로 파라미터를 초기화할 수 있어요. 함수에 값이 없이 전달되거나, 파라미터의 값이 `"undefined"`라면, 파라미터의 값은 기본값이 될 거예요. 이 경우, `value` 객체의 속성을 새로운 객체 안에 전개했어요. 따라서 `x`는 `{ number: 10 }`을 기본값으로 가져요.\n\n기본 인수는 _호출 시점_ 에 평가돼요! 함수를 부를 때마다, _새로운_ 객체를 만들어요. 처음 두 번은 값을 전달하지 않고, `multiply` 함수를 호출해요: `x`는 `{ number: 10 }`의 기본값을 가져요. 그다음 해당 숫자를 곱한 값인 `20`을 출력해요.\n\n세 번째로 곱셈을 호출할 때, 인수를 전달해요: 그 객체는 `value`라고 불려요. `*=` 연산자는 사실 `x.number = x.number * 2`의 줄임말이에요: `x.number`의 값을 변경하고, 곱셈한 값 `20`을 출력해요\n\n네 번째엔, `value` 객체를 다시 한번 전달해요. `x.number`는 이전에 `20`으로 바뀌었기 때문에, `x.number *= 2`는 `40`을 출력해요.',
    id: 64,
  },
  {
    grade: Grades.Middle,
    theme: Themes.DATA_TYPES,
    question: "무엇이 출력 될까요?",
    code: "[1, 2, 3, 4].reduce((x, y) => console.log(x, y));",
    correctAnswer: 4,
    variants: [
      "`1` `2` 그리고 `3` `3` 그리고 `6` `4`",
      "`1` `2` 그리고 `2` `3` 그리고 `3` `4`",
      "`1` `undefined` 그리고 `2` `undefined` 그리고 `3` `undefined` 그리고 `4` `undefined`",
      "`1` `2` 그리고 `undefined` `3` 그리고 `undefined` `4`",
    ],
    explanation:
      "`reduce` 메소드가 받은 첫 번째 인수는 _누산기_ 예요, 이 경우엔 `x`죠. 두 번째 인수 `y`는 _현재 값_ 이에요. reduce 메소드에서, 배열에 있는 모든 요소에 콜백 함수를 실행하므로 궁극적으로는 하나의 값을 얻어요.\n\n이 예제에서는, 값을 반환하지 않고, 단지 누적된 값과 현재 값을 출력해요.\n\n누산기의 값은 콜백 함수가 이전에 반환한 값이에요. 만약 추가적인 `초기값` 인수를 `reduce` 메소드에 전달하지 않았다면, 누산기는 첫번째 부른 첫 번째 요소와 동일해요.\n\n첫 번째로 부를 땐, 누산기 (`x`)는 `1` 이에요, 그리고 현재 값인 (`y`)는 `2`예요. 콜백 함수로부터 반환되지 않았고, 누산기와 현재 값을 출력해요: `1` 그리고 `2`가 출력돼요.\n\n함수에서 값을 반환하지 않았다면, `undefined`를 반환해요. 다음번에 부를 때, 누산기는 `undefined`고, 그리고 현재 값은 `3`이에요. `undefined` 그리고 `3`이 출력돼요.\n\n네 번째 부를 땐, 또 콜백 함수에서 반환받지 않았어요. 누산기는 다시 `undefined`고, 현재 값은 `4`예요. `undefined` 그리고 `4`가 출력돼요.",
    id: 65,
  },
  {
    grade: Grades.Junior,
    theme: Themes.CLASSES,
    question:
      "`Dog` 클래스를 성공적으로 확장할 수 있는 생성자는 어느 것일까요?",
    code: "class Dog {\n  constructor(name) {\n    this.name = name;\n  }\n};\n\nclass Labrador extends Dog {\n  // 1\n  constructor(name, size) {\n    this.size = size;\n  }\n  // 2\n  constructor(name, size) {\n    super(name);\n    this.size = size;\n  }\n  // 3\n  constructor(size) {\n    super(name);\n    this.size = size;\n  }\n  // 4\n  constructor(name, size) {\n    this.name = name;\n    this.size = size;\n  }\n\n};",
    correctAnswer: 2,
    variants: ["1", "2", "3", "4"],
    explanation:
      "파생 클래스에서, `super`를 부르기 전에는 `this` 키워드에 접근할 수 없어요. 그렇게 하려고 한다면, ReferenceError를 던질 거에요: 1과 4는 reference error를 던져요\n\n`super` 키워드를 가지고, 부모 클래스 생성자에 주어진 인수를 부를 수 있어요. 부모 생성자는 `name` 인수를 받아요, 그래서 `name`을 `super`로 전달해야 해요.\n\n`Labrador` 클래스는 2개의 인수를 받는데, `Dog`로 부터 확장된 `name`과 `Labrador` 클래스의 추가 속성인 `size`예요. 그 두 개는 `Labrador` 생성자 함수에 전달되어야 하는데, 올바르게 사용된 건 2번째 생성자예요.",
    id: 66,
  },
  {
    grade: Grades.Middle,
    theme: Themes.MODULES,
    question: "무엇이 출력 될까요?",
    code: "// index.js\nconsole.log('running index.js');\nimport { sum } from './sum.js';\nconsole.log(sum(1, 2));\n\n// sum.js\nconsole.log('running sum.js');\nexport const sum = (a, b) => a + b;",
    correctAnswer: 2,
    variants: [
      "`running index.js`, `running sum.js`, `3`",
      "`running sum.js`, `running index.js`, `3`",
      "`running sum.js`, `3`, `running index.js`",
      "`running index.js`, `undefined`, `running sum.js`",
    ],
    explanation:
      "`import` 키워드를 사용하면, 모든 import된 modules은 _우선-파싱_ 되어요. import된 모듈은 _처음에_ 실행되는 것을 의미하고, import한 파일 안에 있는 코드는 _나중에_ 실행돼요.\n\n이것은 CommonJSd의 `require()`와 `import`의 차이예요! `require()`을 사용하면, 런타임 중 코드에서 필요한 시점에 의존성 모듈을 로드 할 수 있어요. 만약 `import` 대신에 `require`을 사용하면, `running index.js`, `running sum.js`, `3`으로 콘솔에 출력될 거에요.",
    id: 67,
  },
  {
    grade: Grades.Middle,
    theme: Themes.DATA_TYPES,
    question: "무엇이 출력 될까요?",
    code: "console.log(Number(2) === Number(2));\nconsole.log(Boolean(false) === Boolean(false));\nconsole.log(Symbol('foo') === Symbol('foo'));",
    correctAnswer: 1,
    variants: [
      "`true`, `true`, `false`",
      "`false`, `true`, `false`",
      "`true`, `false`, `true`",
      "`true`, `true`, `true`",
    ],
    explanation:
      "모든 심볼은 완전히 유니크해요. 심볼에 전달된 인수의 목적은 심볼에 설명을 제공하는 거에요. 심볼의 값은 전달된 인수에 따라 달라지지 않아요. 동등성을 테스트할 때, 완전히 새로운 두 개의 심볼을 만들어요: 첫번째 `Symbol('foo')`와 두번째 `Symbol('foo')`. 이 두개의 값은 유니크하고, 서로 같지 않아요, `Symbol('foo') === Symbol('foo')`는 `false`를 반환해요.",
    id: 68,
  },
  {
    grade: Grades.Junior,
    theme: Themes.BASICS,
    question: "무엇이 출력 될까요?",
    code: "const name = 'Lydia Hallie';\nconsole.log(name.padStart(13));\nconsole.log(name.padStart(2));",
    correctAnswer: 3,
    variants: [
      '`"Lydia Hallie"`, `"Lydia Hallie"`',
      '`" Lydia Hallie"`, `" Lydia Hallie"` (`"[13x whitespace]Lydia Hallie"`, `"[2x whitespace]Lydia Hallie"`)',
      '`" Lydia Hallie"`, `"Lydia Hallie"` (`"[1x whitespace]Lydia Hallie"`, `"Lydia Hallie"`)',
      '`"Lydia Hallie"`, `"Lyd"`,',
    ],
    explanation:
      '`padStart` 메소드를 사용해, 문자열의 시작 부분에 패딩을 추가해 줄 수 있어요. 이 메소드에 전달된 값은 패딩을 포함한 문자열의 _전체_ 길이예요. 문자열 `"Lydia Hallie"`의 길이는 `12`예요. `name.padStart(13)`은 문자열의 시작점에 1 스페이스를 삽입해요, 따라서 12 + 1 은 13이죠.\n\n`padStart` 메소드에 전달된 인수가 배열의 길이보다 작다면, 패딩은 추가되지 않을 거예요.',
    id: 69,
  },
  {
    grade: Grades.Junior,
    theme: Themes.DATA_TYPES,
    question: "무엇이 출력 될까요?",
    code: "console.log('🥑' + '💻');",
    correctAnswer: 1,
    variants: [
      '`"🥑💻"`',
      "`257548`",
      "해당 코드 주소를 포함하는 문자열",
      "오류",
    ],
    explanation:
      '`+` 연산자를 사용해, 문자열을 연결 시킬 수 있어요. 이 경우에는, 문자열 `"🥑"`과 문자열 `"💻"`을 연결해, 결과 `"🥑💻"`를 얻었어요.',
    id: 70,
  },
  {
    grade: Grades.Middle,
    theme: Themes.ASYNC,
    question: "console.log 표현식 뒤에 언급된 값을 어떻게 출력할 수 있을까요?",
    code: "function* startGame() {\n  const answer = yield 'Do you love JavaScript?';\n  if (answer !== 'Yes') {\n    return \"Oh wow... Guess we're gone here\";\n  }\n  return 'JavaScript loves you back ❤️';\n}\n\nconst game = startGame();\nconsole.log(/* 1 */); // Do you love JavaScript?\nconsole.log(/* 2 */); // JavaScript loves you back ❤️",
    correctAnswer: 3,
    variants: [
      '`game.next("Yes").value` 그리고 `game.next().value`',
      '`game.next.value("Yes")` 그리고 `game.next.value()`',
      '`game.next().value` 그리고 `game.next("Yes").value`',
      '`game.next.value()` 그리고 `game.next.value("Yes")`',
    ],
    explanation:
      '제너레이터 함수는 `yield` 키워드를 보면 실행을 "멈춰"요. 첫 번째로, `game.next().value`를 불러, 함수가 "Do you love JavaScript?" 문자열을 넘겨주도록 할 수 있어요.\n\n`yield` 키워드를 처음으로 찾기 전까지, 모든 줄이 실행되요. 함수 안 첫 번째 줄에 `yield` 키워드가 있어요: 첫 번째 yield으로 실행을 멈춰요! _이것은 `answer` 변수가 아직 정의되지 않았는 뜻이에요!_\n\n`game.next("Yes").value`을 부를 때, 이전 `yield`는 `next()` 함수가 전달한 파라미터의 값으로 대체 되는데, 이 경우에는 `"Yes"`로 대체 돼요. `answer` 변수의 값은 이제 `"Yes"`예요. if문의 조건은 `false`를 반환해, `JavaScript loves you back ❤️`이 출력돼요.',
    id: 71,
  },
  {
    grade: Grades.Middle,
    theme: Themes.BASICS,
    question: "무엇이 출력 될까요?",
    code: "console.log(String.raw`Hello\\nworld`);",
    correctAnswer: 3,
    variants: [
      "`Hello world!`",
      "`Hello` <br />&nbsp; &nbsp; &nbsp;`world`",
      "`Hello\\nworld`",
      "`Hello\\n` <br /> &nbsp; &nbsp; &nbsp;`world`",
    ],
    explanation:
      '`String.raw`는 escapes(`\\n`, `\\v`, `\\t` 등.)가 무시되는 문자열을 반환해요! 백슬래시는 다음과 같이 끝나면 문제가 될 수 있어요:\n\n`` const path = `C:\\Documents\\Projects\\table.html` ``\n\n이렇게 될 거예요:\n\n`"C:DocumentsProjects able.html"`\n\n`String.raw`을 사용하면, 간단하게 escape를 무시하고 출력해요:\n\n`C:\\Documents\\Projects\\table.html`\n\n이 경우, 문자열 `Hello\\nworld`이 출력되요.',
    id: 72,
  },
  {
    grade: Grades.Junior,
    theme: Themes.ASYNC,
    question: "무엇이 출력 될까요?",
    code: "async function getData() {\n  return await Promise.resolve('I made it!');\n}\n\nconst data = getData();\nconsole.log(data);",
    correctAnswer: 3,
    variants: [
      '`"I made it!"`',
      '`Promise {<resolved>: "I made it!"}`',
      "`Promise {<pending>}`",
      "`undefined`",
    ],
    explanation:
      'async 함수는 항상 promise를 반환해요. `await`는 promise가 resolve 할 때까지 기다려야 해요: pending promise는 `data`를 설정하기 위해 부른 `getData()`가 반환한 것을 가져요.\n\nresolve된 값 `"I made it"`에 접근하고 싶다면, `data`에 `.then()` 메소드를 사용해야해요.\n\n`data.then(res => console.log(res))`\n\n이건 `"I made it!"`을 출력할 거예요.',
    id: 73,
  },
  {
    grade: Grades.Middle,
    theme: Themes.DATA_TYPES,
    question: "무엇이 출력 될까요?",
    code: "function addToList(item, list) {\n  return list.push(item);\n}\n\nconst result = addToList('apple', ['banana']);\nconsole.log(result);",
    correctAnswer: 2,
    variants: ["`['banana', 'apple']`", "`2`", "`true`", "`undefined`"],
    explanation:
      '`.push()`메소드는 새로운 배열의 _길이_ 를 반환해요! 이전에, 배열은 한 개의 요소(문자열 `"banana"`)를 포함하고 길이는 `1`예요. 배열에 문자열 `"apple"`을 추가한 후, 배열은 두 개 요소를 포함하고, 길이 `2`를 가져요. `addToList` 함수로부터 반환 받은거예요.\n\n`push` 메소드는 원본 배열을 수정해요. 만약 함수로부터 _배열의 길이_ 대신에 _배열_ 을 반환하고 싶다면, `item`을 푸시한 후 `list`를 반환해야해요.',
    id: 74,
  },
  {
    grade: Grades.Middle,
    theme: Themes.OBJECTS,
    question: "무엇이 출력 될까요?",
    code: "const box = { x: 10, y: 20 };\n\nObject.freeze(box);\n\nconst shape = box;\nshape.x = 100;\n\nconsole.log(shape);",
    correctAnswer: 2,
    variants: [
      "`{ x: 100, y: 20 }`",
      "`{ x: 10, y: 20 }`",
      "`{ x: 100 }`",
      "`ReferenceError`",
    ],
    explanation:
      "`Object.freeze`는 객체의 속성을 추가, 삭제 혹은 수정하지 못하게 만들어요(다른 객체 속성의 값이 아닌 한).\n\n변수 `shape`을 생성할 때, 동결 객체 `box`와 동일하게 설정했고, `shape` 역시 동결 객체를 참조해요. `Object.isFrozen`을 사용해 객체의 동결 여부를 확인할 수 있어요. 이 경우, `Object.isFrozen(shape)`은 true를 반환하고, 따라서 변수 `shape`는 동결 객체 참조를 가져요.\n\n`shape`가 동결 상태이므로, `x`의 값은 객체가 아니며, `x`의 속성을 수정할 수 없어요. `x`는 여전히 `10`이고, `{ x: 10, y: 20 }`가 출력돼요.",
    id: 75,
  },
  {
    grade: Grades.Junior,
    theme: Themes.DATA_TYPES,
    question: "무엇이 출력 될까요?",
    code: "const { name: myName } = { name: 'Lydia' };\n\nconsole.log(name);",
    correctAnswer: 4,
    variants: ['`"Lydia"`', '`"myName"`', "`undefined`", "`ReferenceError`"],
    explanation:
      '오른쪽에 있는 객체로부터 속성 `name`을 분해할 때, `myName`라는 이름을 가진 변수에 값 `"Lydia"`을 할당해요.\n\n`{ name: myName }`은, JavaScript에게 오른쪽에 있는 `name`속성의 값을 가진 `myName`이라고 불리는 새로운 변수를 만든다고 말하는 거예요.\n\n`name`을 출력하려고 하면, 변수는 정의되지 않아 ReferenceError를 던질거예요.',
    id: 76,
  },
  {
    grade: Grades.Middle,
    theme: Themes.BASICS,
    question: "이것은 순수 함수일까요?",
    code: "function sum(a, b) {\n  return a + b;\n}",
    correctAnswer: 1,
    variants: ["Yes", "No"],
    explanation:
      "순수 함수는 _항상_ 같은 결과를 반환하는 함수예요, 만약 같은 인수가 전달 된다면 말이죠.\n\n`sum` 함수는 항상 같은 결과를 반환해요. 만약 `1`과 `2`를 전달하면, 부작용 없이 _항상_ `3`을 반환할 거예요. `5`와 `10`을 전달하면, _항상_ `15`를 반환할 거예요. 이게 순수 함수의 정의예요.",
    id: 77,
  },
  {
    grade: Grades.Middle,
    theme: Themes.FUNCTIONS,
    question: "무엇이 출력 될까요?",
    code: "const add = () => {\n  const cache = {};\n  return (num) => {\n    if (num in cache) {\n      return `From cache! ${cache[num]}`;\n    } else {\n      const result = num + 10;\n      cache[num] = result;\n      return `Calculated! ${result}`;\n    }\n  };\n};\n\nconst addFunction = add();\nconsole.log(addFunction(10));\nconsole.log(addFunction(10));\nconsole.log(addFunction(5 * 2));",
    correctAnswer: 3,
    variants: [
      "`Calculated! 20` `Calculated! 20` `Calculated! 20`",
      "`Calculated! 20` `From cache! 20` `Calculated! 20`",
      "`Calculated! 20` `From cache! 20` `From cache! 20`",
      "`Calculated! 20` `From cache! 20` `Error`",
    ],
    explanation:
      "`add`함수는 _memoized_ 함수예요. memoization 사용하면, 함수 실행 속도를 높이기 위해 함수의 결과를 캐시할 수 있어요. 이 경우, 이전에 반환된 값을 저장한 `cache` 객체를 만들어요.\n\n같은 인수로 `addFunction` 함수를 다시 부르면, 우선 cache 안에 값을 갖고 있는지 확인해요. 만약 그렇다면, 캐시값이 반환되어 실행시간이 절약돼요. 캐시되지 않았다면, 값을 계산하고 나중에 저장해요.\n\n같은 값으로 `addFunction`함수를 세 번 불러요: 첫 번째 호출 때에는, `num`가 `10`일 때 함수의 값은 아직 저장되지 않았어요. if문의 조건 `num in cache` 은 `false`을 반환하고, else 블록이 실행돼요: `Calculated! 20`을 출력하고, 결과 값은 cache 객체에 추가돼요. `cache`는 이제 `{ 10: 20 }` 처럼 보여요.\n\n두 번째엔, `cache`객체는 `10`을 위해 반환될 값을 포함하고 있어요. if문의 조건 `num in cache`은 `true`를 반환하고, `'From cache! 20'`이 출력돼요.\n\n세 번째에는, `5 * 2`을 `10`으로 평가해 함수에 전달해요. `cache` 객체는 `10`을 위해 반환될 값을 포함하고 있어요. if문의 조건 `num in cache`은 `true`를 반환하고, `'From cache! 20'`이 출력돼요.",
    id: 78,
  },
  {
    grade: Grades.Junior,
    theme: Themes.DATA_TYPES,
    question: "무엇이 출력 될까요?",
    code: "const myLifeSummedUp = ['☕', '💻', '🍷', '🍫'];\n\nfor (let item in myLifeSummedUp) {\n  console.log(item);\n}\n\nfor (let item of myLifeSummedUp) {\n  console.log(item);\n}",
    correctAnswer: 1,
    variants: [
      '`0` `1` `2` `3` 그리고 `"☕"` ` "💻"` `"🍷"` `"🍫"`',
      '`"☕"` ` "💻"` `"🍷"` `"🍫"` 그리고 `"☕"` ` "💻"` `"🍷"` `"🍫"`',
      '`"☕"` ` "💻"` `"🍷"` `"🍫"` 그리고 `0` `1` `2` `3`',
      '`0` `1` `2` `3` 그리고 `{0: "☕", 1: "💻", 2: "🍷", 3: "🍫"}`',
    ],
    explanation:
      '_for-in_ 루프에서는, **열거 가능한** 속성에 대해 반복 할 수 있어요. 배열에서, 열거 가능한 속성은 배열 요소의 "키"이고, 사실 그들의 인덱스예요. 배열은 다음과 같이 볼 수 있어요:\n\n`{0: "☕", 1: "💻", 2: "🍷", 3: "🍫"}`\n\n여기서 키는 열거 가능한 속성이에요. `0` `1` `2` `3`이 출력되요.\n\n_for-of_ 루프에서는, **반복 가능한** 속성을 가진 요소에 대해 반복 할 수 있어요. 배열은 반복 가능해요. 배열을 반복할 때, "item" 변수는 현재 반복중인 요소와 같고, `"☕"` ` "💻"` `"🍷"` `"🍫"`이 출력돼요.',
    id: 79,
  },
  {
    grade: Grades.Junior,
    theme: Themes.DATA_TYPES,
    question: "무엇이 출력 될까요?",
    code: "const list = [1 + 2, 1 * 2, 1 / 2];\nconsole.log(list);",
    correctAnswer: 3,
    variants: [
      '`["1 + 2", "1 * 2", "1 / 2"]`',
      '`["12", 2, 0.5]`',
      "`[3, 2, 0.5]`",
      "`[1, 1, 1]`",
    ],
    explanation:
      "배열 요소은 모든 값을 가질 수 있어요. 숫자, 문자, 객체, 다른 배열, null, 불리언 값, undefined, 그리고 날짜, 함수, 연산자와 같은 표현식\n\n요소는 반환된 값과 같아질 거예요. `1 + 2`는 `3`을 반환하고, `1 * 2`는 `2`를 반환하고, `1 / 2` 는 `0.5`을 반환해요.",
    id: 80,
  },
  {
    grade: Grades.Junior,
    theme: Themes.FUNCTIONS,
    question: "무엇이 출력 될까요?",
    code: "function sayHi(name) {\n  return `Hi there, ${name}`;\n}\n\nconsole.log(sayHi());",
    correctAnswer: 2,
    variants: [
      "`Hi there,`",
      "`Hi there, undefined`",
      "`Hi there, null`",
      "`ReferenceError`",
    ],
    explanation:
      '기본적으로, 인수는 함수에 값이 전달되지 않으면 `undefined` 값을 가져요. 이 경우, `name` 인수를 위한 값을 전달하지 않았어요. `name`은 `undefined`로 출력돼요.\n\nES6에서, 기본값 `undefined` 값을 기본값 매개변수로 덮어쓸 수 있어요. 예를 들면:\n\n`function sayHi(name = "Lydia") { ... }`\n\n이 경우, 값을 전달하지 않거나 `undefined`를 전달하면, `name`은 항상 문자열 `Lydia`가 될 거예요.',
    id: 81,
  },
  {
    grade: Grades.Middle,
    theme: Themes.FUNCTIONS,
    question: "무엇이 출력 될까요?",
    code: "var status = '😎';\n\nsetTimeout(() => {\n  const status = '😍';\n\n  const data = {\n    status: '🥑',\n    getStatus() {\n      return this.status;\n    },\n  };\n\n  console.log(data.getStatus());\n  console.log(data.getStatus.call(this));\n}, 0);",
    correctAnswer: 2,
    variants: [
      '`"🥑"` 그리고 `"😍"`',
      '`"🥑"` 그리고 `"😎"`',
      '`"😍"` 그리고 `"😎"`',
      '`"😎"` 그리고 `"😎"`',
    ],
    explanation:
      '`this`키워드의 값은 사용하는 곳에 따라 달라요. `getStatus`메소드 같은 **메소드**에서 `this`키워드는 _메소드가 속한 객체_ 를 참조해요. 이 메소드는 `data` 객체에 속해 있어, `this`는 `data`객체를 참조해요. `this.status`를 출력할 때, `data`객체의 `status` 속성 `"🥑"`이 출력돼요.\n\n`call` 메소드를 사용해, `this` 키워드가 참조하는 객체를 바꿀 수 있어요. **함수**에서, `this` 키워드는 _함수가 속한 객체_ 를 참조해요. `setTimeout` 함수를 _전역 객체_ 에 선언했어요, 따라서 `setTimeout` 함수 안에서 `this`키워드는 _전역 객체_ 를 참조해요. 전역 객체에는 `"😎"`값을 가진 _status_ 라는 변수가 있어요. `this.status`를 출력하면, `"😎"`이 출력돼요.',
    id: 82,
  },
  {
    grade: Grades.Middle,
    theme: Themes.OBJECTS,
    question: "무엇이 출력 될까요?",
    code: "const person = {\n  name: 'Lydia',\n  age: 21,\n};\n\nlet city = person.city;\ncity = 'Amsterdam';\n\nconsole.log(person);",
    correctAnswer: 1,
    variants: [
      '`{ name: "Lydia", age: 21 }`',
      '`{ name: "Lydia", age: 21, city: "Amsterdam" }`',
      '`{ name: "Lydia", age: 21, city: undefined }`',
      '`"Amsterdam"`',
    ],
    explanation:
      '`city` 변수를 `person` 객체의 `city`라고 불리는 속성 값으로 설정 했어요. 이 객체에서는 `city`라고 불리는 속성이 없기 때문에, 변수 `city`는 값 `undefined`를 가져요.\n\n`person`객체 자체를 참조 _하지않는다_ 는 걸 참고해요! 변수 `city`는 `person` 객체의 `city` 속성의 현재 값으로 설정 했을 뿐이에요.\n\n그 뒤, 우리는 `city`를 문자열 `"Amsterdam"`로 설정 했어요. 이건 person 객체를 바꾸지 않아요: 여기서 객체를 참조하는 건 없어요.\n\n`person`객체를 출력할 때, 수정되지 않은 객체를 반환 받아요.',
    id: 83,
  },
  {
    grade: Grades.Middle,
    theme: Themes.FUNCTIONS,
    question: "무엇이 출력 될까요?",
    code: 'function checkAge(age) {\n  if (age < 18) {\n    const message = "Sorry, you\'re too young.";\n  } else {\n    const message = "Yay! You\'re old enough!";\n  }\n\n  return message;\n}\n\nconsole.log(checkAge(21));',
    correctAnswer: 3,
    variants: [
      '`"Sorry, you\'re too young."`',
      '`"Yay! You\'re old enough!"`',
      "`ReferenceError`",
      "`undefined`",
    ],
    explanation:
      "`const`와 `let` 키워드를 사용한 변수는 _블록-스코프_ 예요. 블록은 중괄호 (`{ }`) 사이에 있는 모든 것이에요. 이 경우, if/else 표현식의 중괄호를 의미해요. 변수가 선언된 블록 외부에서 참조할 수 없어요, ReferenceError를 던져요.",
    id: 84,
  },
  {
    grade: Grades.Junior,
    theme: Themes.ASYNC,
    question: "어떤 종류의 정보가 출력될까요?",
    code: "fetch('https://www.website.com/api/user/1')\n  .then((res) => res.json())\n  .then((res) => console.log(res));",
    correctAnswer: 3,
    variants: [
      "`fetch` 메소드의 결과",
      "`fetch` 메소드의 두번째 호출 결과",
      "이전 `.then()`에서 callback된 결과",
      "항상 undefined",
    ],
    explanation:
      "두번째 `.then`에서의 `res`의 값은 이전`.then`에서 반환된 값이에요. 이것 처럼 `.then`을 계속해서 연결할 수 있고, 값은 계속해서 다음 핸들러로 전달 돼요.",
    id: 85,
  },
  {
    grade: Grades.Junior,
    theme: Themes.BASICS,
    question:
      "`true`를 인수로 전달 할 수 없도록 주어졌을 때, `hasName`을 `true`로 설정할 수 있는 방법은 어느 것일까요?",
    code: "function getName(name) {\n  const hasName = //\n}",
    correctAnswer: 1,
    variants: ["`!!name`", "`name`", "`new Boolean(name)`", "`name.length`"],
    explanation:
      "`!!name`에서, 우리는 `name`의 값이 참 같은지 거짓 같은지 여부를 결정해요. 만약 시험 하려는 name이 참 같다면, `!name`은 `false`를 반환해요. `!false`(실제로는 `!!name`)는 `true`를 반환해요.\n\n`hasName`을 `name`으로 설정하면, `hasName`은 불린 값 `true`가 아니라, `getName` 함수에 전달된 값으로 설정해요.\n\n`new Boolean(true)`은 불린 값 자체가 아닌, 감싼 객체를 반환해요.\n\n`name.length`은 그것의 `true`의 여부가 아닌, 전달된 인수의 길이를 반환해요.",
    id: 86,
  },
  {
    grade: Grades.Junior,
    theme: Themes.DATA_TYPES,
    question: "무엇이 출력 될까요?",
    code: "console.log('I want pizza'[0]);",
    correctAnswer: 2,
    variants: ['`"""`', '`"I"`', "`SyntaxError`", "`undefined`"],
    explanation:
      "문자열의 특정 인덱스의 문자를 얻으려면, 대괄호 표기법을 사용하면 돼요. 문자열의 첫 번째 문자는 인덱스 0과 기타등등을 가지고 있어요. 이 경우엔 인덱스가 0이고 문자 `\"I'`가 출력되는 요소를 갖길 원해요.\n\n이 방법은 IE7 이하에서는 지원되지 않는다는 것을 유의하세요. 이 경우, `.charAt()`를 사용하세요.",
    id: 87,
  },
  {
    grade: Grades.Junior,
    theme: Themes.FUNCTIONS,
    question: "무엇이 출력 될까요?",
    code: "function sum(num1, num2 = num1) {\n  console.log(num1 + num2);\n}\n\nsum(10);",
    correctAnswer: 2,
    variants: ["`NaN`", "`20`", "`ReferenceError`", "`undefined`"],
    explanation:
      "기본값 매개변수를 이전에 정의한 함수의 다른 매개변수로 설정 할 수 있어요. 우리는 `sum` 함수에 값 `10`을 전달했어요. 만약 `sum` 함수에 인수의 값을 하나만 받았다면, `num2`의 값은 전달되지 않았고, `num1`은 전달된 값 `10`과 같다는 의미에요. `num2`의 기본값은 `num1`의 값인 `10`과 같아요. `num1 + num2`는 `20`을 반환해요.\n\n만약 기본갑 매개변수가 정의된 _후_ (오른쪽에) 기본 파라미터의 값을 설정하려고 시도한다면, 파라미터의 값은 아직 초기화되지 않아, 오류를 던질 거에요.",
    id: 88,
  },
  {
    grade: Grades.Middle,
    theme: Themes.MODULES,
    question: "무엇이 출력 될까요?",
    code: "// module.js\nexport default () => 'Hello world';\nexport const name = 'Lydia';\n\n// index.js\nimport * as data from './module';\n\nconsole.log(data);",
    correctAnswer: 1,
    variants: [
      '`{ default: [Function (anonymous)], name: "Lydia" }`',
      "`{ default: [Function (anonymous)] }`",
      '`{ default: "Hello world", name: "Lydia" }`',
      "Global object of `module.js`",
    ],
    explanation:
      '`import * as name` 신택스를 사용해, `module.js` 파일에 있는 _모든 exports_ 를 `index.js` 파일 안에 `data`라고 불리는 새로운 객체로 생성해요. `module.js` 파일에는, 2개의 export가 있어요: default export 와 named export. default export는 문자열 `"Hello World"`을 반환하는 함수이고, named export는 문자열 `"Lydia"`의 값을 가진 `name`이라고 불리는 변수예요.\n\n`data` 객체는 default export를 위한 `default` 속성을 가지고, 다른 속성은 named exports의 이름과 그에 해당하는 값을 가져요.',
    id: 89,
  },
  {
    grade: Grades.Junior,
    theme: Themes.CLASSES,
    question: "무엇이 출력 될까요?",
    code: "class Person {\n  constructor(name) {\n    this.name = name;\n  }\n}\n\nconst member = new Person('John');\nconsole.log(typeof member);",
    correctAnswer: 3,
    variants: ['`"class"`', '`"function"`', '`"object"`', '`"string"`'],
    explanation:
      'Class는 함수 생성자를 위한 문법적 설탕이에요. 함수 생성자로서 `Person` 클래스와 동등한 것은 다음과 같아요:\n\n``` js\nfunction Person() {\n  this.name = name;\n}\n```\n\n`new`와 함께 불려진 함수 생성자는 `Person`의 인스턴스를 생성하고, `typeof` 키워드는 인스턴스의 `"object"`를 반환해요. `typeof member`는 `"object"`을 반환해요.',
    id: 90,
  },
  {
    grade: Grades.Middle,
    theme: Themes.DATA_TYPES,
    question: "무엇이 출력 될까요?",
    code: "let newList = [1, 2, 3].push(4);\n\nconsole.log(newList.push(5));",
    correctAnswer: 4,
    variants: [
      "`[1, 2, 3, 4, 5]`",
      "`[1, 2, 3, 5]`",
      "`[1, 2, 3, 4]`",
      "`Error`",
    ],
    explanation:
      "`.push` 메소드는 배열 자체가 아니라, 배열의 _새로운 길이_ 를 반환해요! `newList`를 `[1, 2, 3].push(4)`과 동일하게 설정함으로써, `newList`를 배열의 새로운 길이와 동일하게 설정했어요: `4`.\n\n그리고서, `.push` 메소드를 `newList`에 사용하려고 했어요. `newList`는 숫자 값 `4` 이기 때문에, `.push` 메소드를 사용할 수 없어요: TypeError가 던져져요.",
    id: 91,
  },
  {
    grade: Grades.Middle,
    theme: Themes.FUNCTIONS,
    question: "무엇이 출력 될까요?",
    code: "function giveLydiaPizza() {\n  return 'Here is pizza!';\n}\n\nconst giveLydiaChocolate = () =>\n  \"Here's chocolate... now go hit the gym already.\";\n\nconsole.log(giveLydiaPizza.prototype);\nconsole.log(giveLydiaChocolate.prototype);",
    correctAnswer: 4,
    variants: [
      "`{ constructor: ...}` `{ constructor: ...}`",
      "`{}` `{ constructor: ...}`",
      "`{ constructor: ...}` `{}`",
      "`{ constructor: ...}` `undefined`",
    ],
    explanation:
      "`giveLydiaPizza`와 같은 일반 함수는, `생성자` 속성을 가진 객체(프로토타입 객체)이고, `프로토타입` 속성을 갖고 있어요. 그러나 `giveLydiaChocolate` 함수와 같은 화살표 함수에서는, `prototype` 속성을 가지고 있지 않아요. `giveLydiaChocolate.prototype`을 사용해 `prototype` 속성에 접근하려고 할 때, `undefined`이 반환될 거에요.",
    id: 92,
  },
  {
    grade: Grades.Junior,
    theme: Themes.DATA_TYPES,
    question: "무엇이 출력 될까요?",
    code: "const person = {\n  name: 'Lydia',\n  age: 21,\n};\n\nfor (const [x, y] of Object.entries(person)) {\n  console.log(x, y);\n}",
    correctAnswer: 1,
    variants: [
      "`name` `Lydia` 그리고 `age` `21`",
      '`["name", "Lydia"]` 그리고 `["age", 21]`',
      '`["name", "age"]` 그리고 `undefined`',
      "`Error`",
    ],
    explanation:
      '`Object.entries(person)`은 키와 객체를 포함한 중첩 배열의 배열을 반환해요:\n\n`[ [ \'name\', \'Lydia\' ], [ \'age\', 21 ] ]`\n\n`for-of` 루프를 사용해서, 배열 안에 각 요소를 반복할 수 있는데, 이 경우엔 하위 배열이에요. 하위 배열을 `const [x, y]`을 사용해, for-of 루프에서 즉시 분해할 수 있어요. `x`는 하위 배열의 첫 번째 요소와 같고, `y`는 하위 배열의 두 번째 요소와 같아요.\n\n첫번째 하위요소는 `[ "name", "Lydia" ]`로, `x`는 `"name"`, `y`는 `"Lydia"`을 출력해요.\n두번째 하위요소는 `[ "age", 21 ]`로, `x`는 `"age"`, `y`는 `21`을 출력해요.',
    id: 93,
  },
  {
    grade: Grades.Middle,
    theme: Themes.DATA_TYPES,
    question: "무엇이 출력 될까요?",
    code: 'function getItems(fruitList, ...args, favoriteFruit) {\n  return [...fruitList, ...args, favoriteFruit]\n}\n\ngetItems(["banana", "apple"], "pear", "orange")',
    correctAnswer: 4,
    variants: [
      '`["banana", "apple", "pear", "orange"]`',
      '`[["banana", "apple"], "pear", "orange"]`',
      '`["banana", "apple", ["pear"], "orange"]`',
      "`SyntaxError`",
    ],
    explanation:
      "`...args`은 rest 파라미터예요. rest 파라미터의 값은 모든 나머지 인수을 포함한 배열이며, **마지막 파라미터만 될 수 있어요**! 지금 예시에서는, rest 파라미터는 두번째 파라미터예요. 이것은 불가능하고, syntax error를 던지게 될거에요.\n\n``` js\nfunction getItems(fruitList, favoriteFruit, ...args) {\n  return [...fruitList, ...args, favoriteFruit];\n}\n\ngetItems(['banana', 'apple'], 'pear', 'orange');\n```\n\n위의 예시는 동작해요. 배열 `[ 'banana', 'apple', 'orange', 'pear' ]`을 반환해요.",
    id: 94,
  },
  {
    grade: Grades.Middle,
    theme: Themes.TRICKS,
    question: "무엇이 출력 될까요?",
    code: "function nums(a, b) {\n  if (a > b) console.log('a is bigger');\n  else console.log('b is bigger');\n  return;\n  a + b;\n}\n\nconsole.log(nums(4, 2));\nconsole.log(nums(1, 2));",
    correctAnswer: 2,
    variants: [
      "`a is bigger`, `6` 그리고 `b is bigger`, `3`",
      "`a is bigger`, `undefined` 그리고 `b is bigger`, `undefined`",
      "`undefined` 그리고 `undefined`",
      "`SyntaxError`",
    ],
    explanation:
      "JavaScript에서, 세미콜론을 (`;`)을 명시적으로 _포함하여_ 쓰지 않더라도, JavaScript 엔진은 여전히 문 뒤에 그들을 추가해요. 이것은 **자동 세미콜론 삽입**이라고 불려요. 예를 들어 문은 변수, 또는 `throw`, `return`, `break` 등과 같은 키워드가 될 수도 있어요.\n\n여기, `return`문을 썼고, 다른 값 `a + b`은 _새로운 줄_ 에 쓰였어요. 그러나, 새로운 줄이기 때문에, 엔진은 실제로 그 값이 반환되길 바라는지 알 수 없어요. 대신에, 자동적으로 `return` 뒤에 세미콜론을 더해요. 이것을 볼 수 있을거에요:\n\n``` js\nreturn;\na + b;\n```\n\n`return` 키워드 뒤에 함수가 실행되는 것이 중단되기 때문에, `a + b`의 의미는 도달되지 않아요. 여기서처럼, 만약 아무 값도 반환되지 않는다면 함수는 `undefined`를 반환해요. `if/else`문 뒤에는 아무것도 자동으로 삽입되지 않는다는 걸 유의해요!",
    id: 95,
  },
  {
    grade: Grades.Middle,
    theme: Themes.CLASSES,
    question: "무엇이 출력 될까요?",
    code: "class Person {\n  constructor() {\n    this.name = 'Lydia';\n  }\n}\n\nPerson = class AnotherPerson {\n  constructor() {\n    this.name = 'Sarah';\n  }\n};\n\nconst member = new Person();\nconsole.log(member.name);",
    correctAnswer: 2,
    variants: [
      '`"Lydia"`',
      '`"Sarah"`',
      "`Error: cannot redeclare Person`",
      "`SyntaxError`",
    ],
    explanation:
      '클래스를 다른 클래스/함수 생성자로 설정할 수 있어요. 이 경우, `Person`을 `AnotherPerson`로 설정했어요. 이 생성자의 name은 `Sarah`예요, 따라서 새로운 `Person`의 인스턴스 `member`의 name 속성은 `"Sarah"`예요.',
    id: 96,
  },
  {
    grade: Grades.Middle,
    theme: Themes.OBJECTS,
    question: "무엇이 출력 될까요?",
    code: "const info = {\n  [Symbol('a')]: 'b',\n};\n\nconsole.log(info);\nconsole.log(Object.keys(info));",
    correctAnswer: 4,
    variants: [
      "`{Symbol('a'): 'b'}` 그리고 `[\"{Symbol('a')\"]`",
      "`{}` 그리고 `[]`",
      '`{ a: "b" }` 그리고 `["a"]`',
      "`{Symbol('a'): 'b'}` 그리고 `[]`",
    ],
    explanation:
      '심볼은 _열거 불가능_ 해요. Object.keys 메소드는 객체의 모든 _열거 가능_ 한 키 속성을 반환해요. 심볼은 보이지 않고, 빈 객체가 반환돼요. 객체 전체를 출력하면, 심지어 열거 불가능한 것이라도 모든 속성을 볼 수 있어요.\n\n이것은 심볼의 많은 특성 중 하나에요: 완전히 고유한 값(예를 들어 작업중인 2개의 라이브러리를 같은 객체의 속성으로 추가하고 싶을 때, 객체의 우연한 이름 충돌을 방지해요)을 나타내는 것 외에, 이 방법으로 객체의 속성을 "숨길" 수 있어요(비록 완전히는 아닐지라도. 여전히 `Object.getOwnPropertySymbols()` 메소드를 사용해 심볼에 접근 할 수 있어요).',
    id: 97,
  },
  {
    grade: Grades.Middle,
    theme: Themes.DATA_TYPES,
    question: "무엇이 출력 될까요?",
    code: 'const getList = ([x, ...y]) => [x, y]\nconst getUser = user => { name: user.name, age: user.age }\n\nconst list = [1, 2, 3, 4]\nconst user = { name: "Lydia", age: 21 }\n\nconsole.log(getList(list))\nconsole.log(getUser(user))',
    correctAnswer: 1,
    variants: [
      "`[1, [2, 3, 4]]` 그리고 `undefined`",
      '`[1, [2, 3, 4]]` 그리고 `{ name: "Lydia", age: 21 }`',
      '`[1, 2, 3, 4]` 그리고 `{ name: "Lydia", age: 21 }`',
      '`Error` 그리고 `{ name: "Lydia", age: 21 }`',
    ],
    explanation:
      '`getList`함수는 배열을 인수로 받았어요. `getList` 함수의 괄호 사이에 있는 배열을 즉시 분해 했어요:\n\n`[x, ...y] = [1, 2, 3, 4]`\n\nrest 파라미터를 사용해 `...y`에 모든 "남은" 인수을 배열에 넣었어요. 이 경우에서 남아있는 인수는 `2`, `3` 그리고 `4`예요. `y`의 값은 배열이고, 모든 rest 파라미터를 포함하고 있어요. 이 경우 `x`의 값은 `1`이기 때문에, `[x, y]`는 `[1, [2, 3, 4]]`로 출력돼요.\n\n`getUser` 함수는 객체를 받았어요. 화살표 함수에서, 우리가 한개의 값을 반환한다면 중괄호를 사용할 _필요_ 가 없어요. 그러나, 만약 화살표 함수에서 _객체_ 를 반환하고 싶다면, 괄호 사이에 반환할 값을 써야해요, 그렇지 않다면 아무 값도 반환받을 수 없어요! 다음 함수에서는 객체가 반환 될 거에요:\n\n`const getUser = user => ({ name: user.name, age: user.age })`\n\n이 경우 값이 반환되는 값이 없으므로, 함수는 `undefined`을 반환해요.',
    id: 98,
  },
  {
    grade: Grades.Middle,
    theme: Themes.FUNCTIONS,
    question: "무엇이 출력 될까요?",
    code: "const name = 'Lydia';\n\nconsole.log(name());",
    correctAnswer: 3,
    variants: [
      "`SyntaxError`",
      "`ReferenceError`",
      "`TypeError`",
      "`undefined`",
    ],
    explanation:
      "변수 `name`은 문자열을 값으로 가지고 있고, 함수가 아니에요, 따라서 호출할 수 없어요.\n\nTypeErrors는 값이 예상된 유형이 아닐 경우 던져져요. JavaScript는 `name`을 호출하려고 했기 때문에 함수일거라 예상했어요. 그러나 문자열이였기 때문에, TypeError가 던져져요: name은 함수가 아니에요!\n\nSyntaxErrors는 어떤 것을 썼을때 JavaScript에서 유효하지 않을 때 던져져요, 예를들어 `return`을 `retrun`로 썼을때 말이죠.\nReferenceErrors는 JavaScript가 접근하려고 하는 값의 참조를 찾을 수 없을 때 던져져요.",
    id: 99,
  },
  {
    grade: Grades.Middle,
    theme: Themes.DATA_TYPES,
    question: "output의 값은 무엇일까요?",
    code: "// 🎉✨ 이번이 내 100번째 질문이에요! ✨🎉\n\nconst output = `${[] && 'Im'}possible!\nYou should${'' && `n't`} see a therapist after so much JavaScript lol`;",
    correctAnswer: 2,
    variants: [
      "`possible! You should see a therapist after so much JavaScript lol`",
      "`Impossible! You should see a therapist after so much JavaScript lol`",
      "`possible! You shouldn't see a therapist after so much JavaScript lol`",
      "`Impossible! You shouldn't see a therapist after so much JavaScript lol`",
    ],
    explanation:
      "`[]`은 참 같은 값이에요. `&&` 연산자를 사용할 때, 왼쪽에 있는 값이 참 같은 값이라면 오른쪽 값은 반환될 거에요. 이 경우, 왼쪽의 값 `[]`은 참 같은 값이에요, 따라서 `'Im'`은 반환될 거예요.\n\n`\"\"`은 거짓 같은 값이에요. 만약 왼쪽 값이 거짓 같은 값이라면, 반환되는 것은 없어요. `n't`은 반환되지 않아요.",
    id: 100,
  },
  {
    grade: Grades.Middle,
    theme: Themes.BASICS,
    question: "무엇이 출력 될까요?",
    code: "const one = false || {} || null;\nconst two = null || false || '';\nconst three = [] || 0 || true;\n\nconsole.log(one, two, three);",
    correctAnswer: 3,
    variants: [
      "`false` `null` `[]`",
      '`null` `""` `true`',
      '`{}` `""` `[]`',
      "`null` `null` `true`",
    ],
    explanation:
      '`||` 연산자를 사용하면, 첫번째로 참 같은 피연산자를 반환해요. 만약 모든 값이 거짓 같다면, 마지막 피연산자를 반환해요.\n\n`(false || {} || null)`: 빈 객체 `{}`는 진짜 같은 값이에요. 이것은 최초로(그리고 유일하게) 진짜 같은 값이라 반환돼요. `one`은 `{}`이에요.\n\n`(null || false || "")`: 모든 피연산자는 가짜 같은 값이에요. 이것은 마지막 피연산자 `""`가 반환된다는 것을 의미해요. `two`는 `""`이에요.\n\n`([] || 0 || "")`: 빈 배열 `[]`은 진짜 같은 값이에요. 이것은 첫번째로 진짜 같은 값이라 반환돼요. `three`은 `[]`이에요.',
    id: 101,
  },
  {
    grade: Grades.Middle,
    theme: Themes.ASYNC,
    question: "무엇이 출력 될까요?",
    code: "const myPromise = () => Promise.resolve('I have resolved!');\n\nfunction firstFunction() {\n  myPromise().then((res) => console.log(res));\n  console.log('second');\n}\n\nasync function secondFunction() {\n  console.log(await myPromise());\n  console.log('second');\n}\n\nfirstFunction();\nsecondFunction();",
    correctAnswer: 4,
    variants: [
      "`I have resolved!`, `second` 그리고 `I have resolved!`, `second`",
      "`second`, `I have resolved!` 그리고 `second`, `I have resolved!`",
      "`I have resolved!`, `second` 그리고 `second`, `I have resolved!`",
      "`second`, `I have resolved!` 그리고 `I have resolved!`, `second`",
    ],
    explanation:
      "promise를 사용하면, 기본적으로 _이 함수를 실행하고 싶지만, 시간이 좀 걸릴 수 있어 실행 중에 잠시 미뤄둘거에요. 확실한 값이 resoloved(혹은 rejected) 되었을 때와 콜 스택이 비었을 때, 이 값을 사용하고 싶어요_ 라고 말해요.\n\n`async` 함수 안에서 `.then`과 `await` 두 개의 키워드로 값을 얻을 수 있어요. 비록 `.then`과 `await` 모두 프라미스의 값을 얻을 수 있지만, 그들은 약간 다르게 작동해요.\n\n`firstFunction`에서, (뭐랄까) myPromise 함수가 실행되는 것을 미뤘지만, 다른 코드, 이 경우엔 `console.log('second')`를 계속해서 실행해요. 그리고서, 함수는 콜스택이 비워져 있는 걸 본 다음 출력된 문자열 `I have resolved`를 resolved 해요.\n\n`secondFunction`에서 await 키워드를 사용하면, 말 그대로 다음 라인으로 옮기기 전에 값이 resoloved 될 때 까지 async 함수의 실행을 중단해요.\n\n이것은 `myPromise`이 값 `I have resolved`을 resolve 할 때 까지 기다린다는 뜻이고, 단 한 번만 발생한 뒤, 다음라인으로 이동해요: `second`이 출력돼요.",
    id: 102,
  },
  {
    grade: Grades.Junior,
    theme: Themes.DATA_TYPES,
    question: "무엇이 출력 될까요?",
    code: "const set = new Set();\n\nset.add(1);\nset.add('Lydia');\nset.add({ name: 'Lydia' });\n\nfor (let item of set) {\n  console.log(item + 2);\n}",
    correctAnswer: 3,
    variants: [
      "`3`, `NaN`, `NaN`",
      "`3`, `7`, `NaN`",
      "`3`, `Lydia2`, `[object Object]2`",
      '`"12"`, `Lydia2`, `[object Object]2`',
    ],
    explanation:
      '`+` 연산자는 숫자로 나타난 값을 더하는데 사용될 뿐만 아니라, 문자열을 연결하는데 사용해요. JavaScript 엔진은 하나 이상의 값이 숫자가 아닌 것을 발견 했을 때, 숫자를 문자열로 강제로 변환해요.\n\n첫번째 `1`은, 숫자로된 값이에요. `1 + 2`는 숫자 3을 반환해요.\n\n그러나, 두번째는 문자열 `"Lydia"`이에요. `"Lydia"`은 문자열이고, `2`는 숫자에요: `2`는 문자열로 강제 변환되어요. `"Lydia"`그리고 `"2"`이 연결되어, 문자열 `"Lydia2"`이 반환되요.\n\n`{ name: "Lydia" }`은 객체에요. 객체가 아닌 숫자나 객체는 문자열이 아니므로, 둘다 문자화되어요. 일반 객체를 문자화 할때, `"[object Object]"`가 돼요. `"[object Object]"`는 `"2"`와 연결되어 `"[object Object]2"`가 돼요.',
    id: 103,
  },
  {
    grade: Grades.Junior,
    theme: Themes.ASYNC,
    question: "값은 무엇일까요?",
    code: "Promise.resolve(5);",
    correctAnswer: 3,
    variants: [
      "`5`",
      "`Promise {<pending>: 5}`",
      "`Promise {<fulfilled>: 5}`",
      "`Error`",
    ],
    explanation:
      "promise 또는 non-promise가 아니더라도, 어떤 유형의 값이라도 `Promise.resolve`으로 전달 할 수 있어요. 메소드 그 자체는 resolved 값을 가진 promise를 반환해요 (`<fulfilled>`). 일반 함수를 전달한다면, 일반 값을 가진 resolved promise를 얻게 될거에요. 만약 promise를 전달한다면, 전달된 promise의 resolved 값과 resolved promise를 얻게 될거에요.\n\n이 경우, 숫자 값 `5`를 전달했어요. 이것은 값 `5`를 가진 resolved promise를 반환해요.",
    id: 104,
  },
  {
    grade: Grades.Middle,
    theme: Themes.OBJECTS,
    question: "값은 무엇일까요?",
    code: "function compareMembers(person1, person2 = person) {\n  if (person1 !== person2) {\n    console.log('Not the same!');\n  } else {\n    console.log('They are the same!');\n  }\n}\n\nconst person = { name: 'Lydia' };\n\ncompareMembers(person);",
    correctAnswer: 2,
    variants: [
      "`Not the same!`",
      "`They are the same!`",
      "`ReferenceError`",
      "`SyntaxError`",
    ],
    explanation:
      "객체는 참조로 전달되었어요. 엄격한 동등 비교 (`===`)로 객체를 검사한다면, 그들의 참조를 비교할거에요.\n\n`person2`의 기본 값을 `person` 객체로 설정 하고, `person` 객체를 `person1`의 값으로 전달 했어요.\n\n이것은 두개의 값은 메모리의 같은 장소의 참조를 가지고 있다는 걸 의미해요, 그렇기 때문에 그들은 같아요.\n\n`else`구문 안에 코드블럭이 실행되면, `They are the same!`을 출력해요.",
    id: 105,
  },
  {
    grade: Grades.Junior,
    theme: Themes.OBJECTS,
    question: "값은 무엇일까요?",
    code: "const colorConfig = {\n  red: true,\n  blue: false,\n  green: true,\n  black: true,\n  yellow: false,\n};\n\nconst colors = ['pink', 'red', 'blue'];\n\nconsole.log(colorConfig.colors[1]);",
    correctAnswer: 4,
    variants: ["`true`", "`false`", "`undefined`", "`TypeError`"],
    explanation:
      "JavaScript에서, 객체의 속성에 접근하는 2가지 방법을 가지고 있어요: 괄호 표기법, 또는 점 표기법. 이 예제에서는, 괄호 표기법 (`colorConfig[\"colors\"]`) 대신 점 표기법 (`colorConfig.colors`)을 사용 했어요.\n\n점 표기법에서, JavaScript는 정확히 일치하는 이름을 가진 객체의 속성을 찾으려 해요. 이 예제에서 JavaScript는 `colorConfig` 객체의 `colors`라고 불리는 속성을 찾으려고 했어요. 그곳에는 `colors`라고 불리는 속성이 없어요, 그래서 `undefined`을 반환해요. 그리고 나서, `[1]`을 사용해서 첫번째 요소의 값에 접근하려고 했어요. `undefined`의 값에는 이것을 할 수 없어요, 그래서 `TypeError`를 던져요: `Cannot read property '1' of undefined`.\n\nJavaScript 문장을 해석(또는 참조형 변수를 원시 데이터 타입으로 만들어 주도록) 해요. 괄호 표기법을 사용할때, 첫번째로 열린 괄호 `[`을 보고 닫힌 괄호 `]`를 찾을 때 까지 계속 진행되는 것으로 보여요. 그러고 나서야, 문장을 평가할거에요. 만약 `colorConfig[colors[1]]`을 사용했다면, `colorConfig` 객체의 속성 `red` 의 값이 반환될 거에요.",
    id: 106,
  },
  {
    grade: Grades.Junior,
    theme: Themes.DATA_TYPES,
    question: "값은 무엇일까요?",
    code: "console.log('❤️' === '❤️');",
    correctAnswer: 1,
    variants: ["`true`", "`false`"],
    explanation:
      '엔진에서, 이모티콘은 유니코드에요. 하트 이모티콘의 유니코드는 `"U+2764 U+FE0F"`에요. 같은 이모티콘의 유니코드는 항상 같아요, 따라서 각각 다른 두개의 같은 문자열을 비교하는 것이므로 true를 반환해요.',
    id: 107,
  },
  {
    grade: Grades.Junior,
    theme: Themes.DATA_TYPES,
    question: "다음 중 원본 배열을 수정하는 method는 무엇일까요?",
    code: "const emojis = ['✨', '🥑', '😍'];\n\nemojis.map((x) => x + '✨');\nemojis.filter((x) => x !== '🥑');\nemojis.find((x) => x !== '🥑');\nemojis.reduce((acc, cur) => acc + '✨');\nemojis.slice(1, 2, '✨');\nemojis.splice(1, 2, '✨');",
    correctAnswer: 4,
    variants: [
      "`All of them`",
      "`map` `reduce` `slice` `splice`",
      "`map` `slice` `splice`",
      "`splice`",
    ],
    explanation:
      "`splice` method를 사용하면, 요소를 삭제, 대체하거나 추가함으로써 원본 배열을 수정해요. 이 경우에서, 인덱스 1에서 부터 2개의 아이템을 제거했어요. (`'🥑'` 와 `'😍'`를 삭제했어요) 그리고 ✨ 이모티콘을 대신 추가했어요.\n\n`map`, `filter` 그리고 `slice` 는 새로운 배열을 반환하고, `find` 는 요소를 반환하며, `reduce` 는 감소된 값을 반환해요.",
    id: 108,
  },
  {
    grade: Grades.Junior,
    theme: Themes.OBJECTS,
    question: "무엇이 출력 될까요?",
    code: "const food = ['🍕', '🍫', '🥑', '🍔'];\nconst info = { favoriteFood: food[0] };\n\ninfo.favoriteFood = '🍝';\n\nconsole.log(food);",
    correctAnswer: 1,
    variants: [
      "`['🍕', '🍫', '🥑', '🍔']`",
      "`['🍝', '🍫', '🥑', '🍔']`",
      "`['🍝', '🍕', '🍫', '🥑', '🍔']`",
      "`ReferenceError`",
    ],
    explanation:
      "`info` 객체의 `favoriteFood` 속성 값을 피자 이모지 `'🍕'`으로 설정했어요. 문자는 원시 데이터 형이에요. JavaScript에서 원시 데이터 형은 참조로 상호 작용 하지 않아요.\n\nJavaScript에서, 원시 데이터 형은 (객체가 아닌 모든 것) _값_ 으로 상호 작용해요. 이 경우, `info` 객체의 `favoriteFood` 속성 값을 `food` 배열 안의 첫 번째 요소로 설정했어요. 이 경우 (`'🍕'`) 피자 이모지는 문자열이에요. 문자열은 원시 데이터 형이므로 값으로 상호 작용해요. (좀 더 알고싶다면 내 [블로그 포스트](https://www.theavocoder.com/complete-javascript/2018/12/21/by-value-vs-by-reference)를 참고하세요.)\n\n그리고나서, `info` 객체의 `favoriteFood` 속성 값을 바꿨어요. `favoriteFood`의 값은 단지 배열의 첫 번째 요소의 값을 _복사_ 했기 때문에 `food` 배열은 바뀌지 않고, `food[0]` 요소의 메모리 공간과 같은 참조를 갖지 않아요. food를 출력하면, 여전히 원본 배열 `['🍕', '🍫', '🥑', '🍔']` 이에요.",
    id: 109,
  },
  {
    grade: Grades.Junior,
    theme: Themes.DATA_TYPES,
    question: "이 메소드는 무엇을 할까요?",
    code: "JSON.parse();",
    correctAnswer: 1,
    variants: [
      "JSON을 JavaScript 값으로 Parses",
      "JavaScript 객체를 JSON으로 Parses",
      "모든 JavaScript 값을 JSON으로 Parses",
      "JSON을 JavaScript 객체로만 Parses",
    ],
    explanation:
      "`JSON.parse()`메소드를 사용하면, JSON 문자열의 구문을 분석해 JavaScript 값으로 생성해요.\n\n``` js\n// 숫자를 유효한 JSON 문자열로 변환해요, 그리고 나서 JSON 문자열의 구문을 분석해 JavaScript 값으로 생성해요.\nconst jsonNumber = JSON.stringify(4); // '4'\nJSON.parse(jsonNumber); // 4\n\n// 배열 값을 유효한 JSON 문자열로 변환해요, 그리고 나서 JSON 문자열의 구문을 분석해 JavaScript 값으로 생성해요.\nconst jsonArray = JSON.stringify([1, 2, 3]); // '[1, 2, 3]'\nJSON.parse(jsonArray); // [1, 2, 3]\n\n// 객체를 유효한 JSON 문자열로 변환해요, 그리고 나서 JSON 문자열의 구문을 분석해 JavaScript 값으로 생성해요.\nconst jsonArray = JSON.stringify({ name: 'Lydia' }); // '{\"name\":\"Lydia\"}'\nJSON.parse(jsonArray); // { name: 'Lydia' }\n```",
    id: 110,
  },
  {
    grade: Grades.Junior,
    theme: Themes.BASICS,
    question: "무엇이 출력 될까요?",
    code: "let name = 'Lydia';\n\nfunction getName() {\n  console.log(name);\n  let name = 'Sarah';\n}\n\ngetName();",
    correctAnswer: 4,
    variants: ["Lydia", "Sarah", "`undefined`", "`ReferenceError`"],
    explanation:
      "각 함수는 각자의 _실행 컨텍스트_ (또는 _스코프_)가 있어요. `getName`함수는 먼저 접근하려고 하는 변수 `name`가 자신의 컨텍스트(스코프) 내 포함하고 있는지 살펴봐요. 이 경우에, `getName`함수는 자체 `name` 변수를 포함해요.: `let` 키워드로 값이 `'Sarah'`인 변수 `name`을 선언해요.\n\n`let` 키워드 (그리고 `const`)를 사용한 변수는 호이스팅 되지만, `var`와는 다르게 _초기화_ 되지 않아요. 그들을 선언(초기화)한 줄 전에서는 접근 할 수 없어요. 이것은 \"일시적 사각지대\"라고 불려요. 변수를 선언하기 전에 접근하려고 한다면, JavaScript는 `ReferenceError`를 던져요.\n\n`getName` 함수 안에 `name` 변수를 선언하지 않았다면, javaScript 엔진은 _스코프 체인_ 을 살펴봤을 거예요. 외부 범위에는 값이 `Lydia`인 `name`이라는 변수가 있어요. 이 경우 `Lydia`를 출력할 거예요.\n\n``` js\nlet name = 'Lydia';\n\nfunction getName() {\n  console.log(name);\n}\n\ngetName(); // Lydia\n```",
    id: 111,
  },
  {
    grade: Grades.Middle,
    theme: Themes.ASYNC,
    question: "무엇이 출력 될까요?",
    code: "function* generatorOne() {\n  yield ['a', 'b', 'c'];\n}\n\nfunction* generatorTwo() {\n  yield* ['a', 'b', 'c'];\n}\n\nconst one = generatorOne();\nconst two = generatorTwo();\n\nconsole.log(one.next().value);\nconsole.log(two.next().value);",
    correctAnswer: 3,
    variants: [
      "`a` 그리고 `a`",
      "`a` 그리고 `undefined`",
      "`['a', 'b', 'c']` 그리고 `a`",
      "`a` 그리고 `['a', 'b', 'c']`",
    ],
    explanation:
      "`yield` 키워드를 사용해, 제너레이터 함수 안의 값을 `yield` 해요. `yield*` 키워드를 사용하면, 다른 제너레이터 함수 또는 반복 가능한 객체(예를 들면 배열)의 값을 yield 할 수 있어요.\n\n`generatorOne`에서, 전체 배열 `['a', 'b', 'c']`을 `yield` 키워드를 사용해 넘겨줬어요. `one` (`one.next().value`)의 `next` 메소드가 반환한 객체의 `value`속성 값은 전체 배열 `['a', 'b', 'c']`과 같아요.\n\n``` js\nconsole.log(one.next().value); // ['a', 'b', 'c']\nconsole.log(one.next().value); // undefined\n```\n\n`generatorTwo`에서, `yield*` 키워드를 사용했어요. `two`의 첫 번째로 넘겨진 값이 이터레이터의 첫 번째 넘겨진 값과 같다는 의미에요. 이터레이터는 배열 `['a', 'b', 'c']` 이에요. 처음으로 넘겨진 값은 `a`이고, 따라서 첫 번째 순서에서 `two.next().value`를 부르면 `a`를 반환해요.\n\n``` js\nconsole.log(two.next().value); // 'a'\nconsole.log(two.next().value); // 'b'\nconsole.log(two.next().value); // 'c'\nconsole.log(two.next().value); // undefined\n```",
    id: 112,
  },
  {
    grade: Grades.Junior,
    theme: Themes.BASICS,
    question: "무엇이 출력 될까요?",
    code: "console.log(`${((x) => x)('I love')} to program`);",
    correctAnswer: 1,
    variants: [
      "`I love to program`",
      "`undefined to program`",
      "`${(x => x)('I love') to program`",
      "`TypeError`",
    ],
    explanation:
      "템플릿 리터러를 사용한 표현식은 첫번째로 평가돼요. 문자열은 표현식의 반환된 값을 포함하게 된다는 것을 의미하고, 이 경우 함수 `(x => x)('I love')`는 즉시 호출 돼요. 화살표 함수 `x => x`의 인수 값으로 `I love`를 전달 했어요. `x`는 `'I love'`이고 반환 될 거에요. 이 결과는 `I love to program` 이에요.",
    id: 113,
  },
  {
    grade: Grades.Middle,
    theme: Themes.FUNCTIONS,
    question: "무슨일이 발생할까요?",
    code: "let config = {\n  alert: setInterval(() => {\n    console.log('Alert!');\n  }, 1000),\n};\n\nconfig = null;",
    correctAnswer: 3,
    variants: [
      "`setInterval` 콜백은 호출되지 않을거에요",
      "`setInterval` 콜백은 한 번만 호출돼요",
      "`setInterval` 콜백은 여전히 매 초마다 호출돼요",
      "결코 `config.alert()`를 호출 하지 않고, config 는 `null`이에요",
    ],
    explanation:
      "일반적으로 객체를 `null`로 설정했을 때, 객체는 더 이상 참조할 객체가 없어 _쓰레기 수집_ 되어요. 그러나, `setInterval`을 가진 콜백 함수는 화살표 함수 (`config` 객체로 감싸진) 이기 때문에, 콜백 함수는 여전히 `config` 객체를 참조 하고 있어요\n참조가 존재하는 한, 객체는 쓰레기 수집 되지 않아요.\n이것은 interval이므로, `config`를 `null` 또는 `delete`-ing `config.alert`로 설정하면 interval이 쓰레기 수집되지 않아, interval은 계속 호출됩니다\n메모리에서 제거하기 위해서 `clearInterval(config.alert)`로 지워야 합니다.\n지워지지 않았기 때문에, `setInterval` 콜백 함수는 매 1000ms (1s)마다 계속 호출 될 거에요.",
    id: 114,
  },
  {
    grade: Grades.Junior,
    theme: Themes.DATA_TYPES,
    question: "어느 method가 값 `'Hello world!'`를 반환 할까요?",
    code: "const myMap = new Map();\nconst myFunc = () => 'greeting';\n\nmyMap.set(myFunc, 'Hello world!');\n\n//1\nmyMap.get('greeting');\n//2\nmyMap.get(myFunc);\n//3\nmyMap.get(() => 'greeting');",
    correctAnswer: 2,
    variants: ["1", "2", "2 그리고 3", "모두"],
    explanation:
      "키/값을 쌍으로 추가할 때 `set` 메소드를 사용하면, 키는 `set` 함수로 전달 된 첫 번째 인수의 값이 되고, 값은 `set` 함수로 전달된 두 번째 인수의 값이 될 거에요. 이 경우에 키는 _함수_ `() => 'greeting'`이고, 값은 `'Hello world'`예요. `myMap`은 이제 `{ () => 'greeting' => 'Hello world!' }` 예요.\n\n1은 틀렸어요, 키는 `'greeting'`가 아니라 `() => 'greeting'`이기 때문이에요.\n3은 틀렸어요, `get`메소드에 새로 생성한 함수를 파라미터로 전달 했기 때문이에요. 객체는 _참조_ 로 상호작용해요. 함수는 객체이기 때문에, 두 함수가 같다고 하더라도 절대로 동일하지 않아요: 메모리 안에 다른 장소의 참조를 가지고 있어요.",
    id: 115,
  },
  {
    grade: Grades.Middle,
    theme: Themes.FUNCTIONS,
    question: "무엇이 출력 될까요?",
    code: "const person = {\n  name: 'Lydia',\n  age: 21,\n};\n\nconst changeAge = (x = { ...person }) => (x.age += 1);\nconst changeAgeAndName = (x = { ...person }) => {\n  x.age += 1;\n  x.name = 'Sarah';\n};\n\nchangeAge(person);\nchangeAgeAndName();\n\nconsole.log(person);",
    correctAnswer: 3,
    variants: [
      '`{name: "Sarah", age: 22}`',
      '`{name: "Sarah", age: 23}`',
      '`{name: "Lydia", age: 22}`',
      '`{name: "Lydia", age: 23}`',
    ],
    explanation:
      '`changeAge`와 `changeAgeAndName`함수 모두 _새롭게_ 만들어진 객체 `{ ...person }`를 기본값 매개변수로 가지고 있어요. 이 객체는 `person` 객체의 모든 키/값의 복사본을 가지고 있어요.\n\n첫번째로, `changeAge`함수를 호출 했고, 그것의 인수로 `person` 객체를 전달 했어요. 이 함수는 `age`속성의 값을 1 증가 시켜요. `person`은 이제 `{ name: "Lydia", age: 22 }`예요.\n\n그리고서, `changeAgeAndName` 함수를 호출 했지만, 파라미터를 전달하지 않았어요. 대신에, `x`의 값은 _새로운_ 객체와 같아요: `{ ...person }`. 새로운 객체이기 때문에, `person`객체의 속성의 값에 영향을 주지 않아요. `person`은 여전히 `{ name: "Lydia", age: 22 }`와 같아요.',
    id: 116,
  },
  {
    grade: Grades.Junior,
    theme: Themes.FUNCTIONS,
    question: "다음 선택지 중 어느 것이 `6`을 반환 할까요?",
    code: "function sumValues(x, y, z) {\n  return x + y + z;\n}",
    correctAnswer: 3,
    variants: [
      "`sumValues([...1, 2, 3])`",
      "`sumValues([...[1, 2, 3]])`",
      "`sumValues(...[1, 2, 3])`",
      "`sumValues([1, 2, 3])`",
    ],
    explanation:
      "연산자 `...`를 사용하면, 반복 가능한 객체를 개별요소로 _spread_ 펼칠 수 있어요. `sumValues` 함수는 인수 3개를 받았어요: `x`, `y` 그리고 `z`. `...[1, 2, 3]`를 `sumValues` 함수에 전달하면 `1, 2, 3` 가 될 거예요.",
    id: 117,
  },
  {
    grade: Grades.Junior,
    theme: Themes.BASICS,
    question: "무엇이 출력 될까요?",
    code: "let num = 1;\nconst list = ['🥳', '🤠', '🥰', '🤪'];\n\nconsole.log(list[(num += 1)]);",
    correctAnswer: 2,
    variants: ["`🤠`", "`🥰`", "`SyntaxError`", "`ReferenceError`"],
    explanation:
      "`+=` 연산자를 사용하면, `num`의 값을 `1` 씩 증가시켜요. `num`은 초기값 `1`을 가지고 있어요, 그래서 `1 + 1` 은 `2`예요.`list` 배열의 2번째 인덱스 아이템은 🥰 예요, `console.log(list[2])` 는 🥰 을 출력해요.",
    id: 118,
  },
  {
    grade: Grades.Junior,
    theme: Themes.ECMASCRIPT,
    question: "무엇이 출력 될까요?",
    code: "const person = {\n  firstName: 'Lydia',\n  lastName: 'Hallie',\n  pet: {\n    name: 'Mara',\n    breed: 'Dutch Tulip Hound',\n  },\n  getFullName() {\n    return `${this.firstName} ${this.lastName}`;\n  },\n};\n\nconsole.log(person.pet?.name);\nconsole.log(person.pet?.family?.name);\nconsole.log(person.getFullName?.());\nconsole.log(member.getLastName?.());",
    correctAnswer: 2,
    variants: [
      "`undefined` `undefined` `undefined` `undefined`",
      "`Mara` `undefined` `Lydia Hallie` `ReferenceError`",
      "`Mara` `null` `Lydia Hallie` `null`",
      "`null` `ReferenceError` `null` `ReferenceError`",
    ],
    explanation:
      "optional chaining 연산자 `?.`를 사용하면, 더 깊이 중첩된 값이 유효한지 여부를 더는 분명하게 확인하지 않아도 돼요.`undefined` 또는 `null` 값 (_nullish_) 속성에 접근 하려고 할 때, 표현식을 평가하지 않고 `undefined`을 반환해요.\n\n`person.pet?.name`: `person`은 속성이름 `pet`을 가지고 있어요: `person.pet`은 nullish(null 또는 undefined)가 아니에요. `name`이라는 속성 이름을 가지고 있어, `Mara`를 반환해요.\n`person.pet?.family?.name`: `person`은 속성이름 `pet`을 가지고 있어요: `person.pet`은 nullish가 아니에요. `pet`은 _not_ have a property called `family`라는 속성이 _없어요_, `person.pet.family`은 nullish예요. 표현식은 `undefined`을 반환해요.\n`person.getFullName?.()`: `person`은 속성이름`getFullName`을 가지고 있어요: `person.getFullName()` 은 nullish기 아니고 호출 할 수 있어요, 따라서 `Lydia Hallie`을 반환해요.\n`member.getLastName?.()`: `member`은 정의되지 않았어요: `member.getLastName()`은 nullish예요. 표현식은 `undefined`을 반환해요.",
    id: 119,
  },
  {
    grade: Grades.Junior,
    theme: Themes.BASICS,
    question: "무엇이 출력 될까요?",
    code: "const groceries = ['banana', 'apple', 'peanuts'];\n\nif (groceries.indexOf('banana')) {\n  console.log('We have to buy bananas!');\n} else {\n  console.log(`We don't have to buy bananas!`);\n}",
    correctAnswer: 2,
    variants: [
      "We have to buy bananas!",
      "We don't have to buy bananas",
      "`undefined`",
      "`1`",
    ],
    explanation:
      'if문에 조건 `groceries.indexOf("banana")`을 전달했어요. `groceries.indexOf("banana")`은 `0`을 반환하고, 이건 거짓 같은 값이에요. if문의 조건이 거짓 같은 값이기 때문에, 코드는 `else` 블록을 실행하고, `We don\'t have to buy bananas!`이 출력돼요.',
    id: 120,
  },
  {
    grade: Grades.Junior,
    theme: Themes.OBJECTS,
    question: "무엇이 출력 될까요?",
    code: "const config = {\n  languages: [],\n  set language(lang) {\n    return this.languages.push(lang);\n  },\n};\n\nconsole.log(config.language);",
    correctAnswer: 4,
    variants: [
      "`function language(lang) { this.languages.push(lang }`",
      "`0`",
      "`[]`",
      "`undefined`",
    ],
    explanation:
      "`language` 메소드는 `setter`예요. Setters는 실제 값을 유지하지 않아요, 그들의 목적은 속성을 _수정_ 하는 거예요. `setter` 메소드를 부르면, `undefined`가 반환돼요.",
    id: 121,
  },
  {
    grade: Grades.Middle,
    theme: Themes.DATA_TYPES,
    question: "무엇이 출력 될까요?",
    code: "const name = 'Lydia Hallie';\n\nconsole.log(!typeof name === 'object');\nconsole.log(!typeof name === 'string');",
    correctAnswer: 3,
    variants: [
      "`false` `true`",
      "`true` `false`",
      "`false` `false`",
      "`true` `true`",
    ],
    explanation:
      '`typeof name`은 `"string"`을 반환해요. 문자열 `"string"`은 진짜 같은 값이고, `!typeof name`은 불리언 값 `false`을 반환해요. `false === "object"` 그리고 `false === "string"` 둘다 `false`을 반환해요.\n\n(특정한 형과 같은지(다른지) 알고 싶다면, `!typeof` 대신 `!==`을 사용 해야 해요.)',
    id: 122,
  },
  {
    grade: Grades.Middle,
    theme: Themes.FUNCTIONS,
    question: "무엇이 출력 될까요?",
    code: "const add = (x) => (y) => (z) => {\n  console.log(x, y, z);\n  return x + y + z;\n};\n\nadd(4)(5)(6);",
    correctAnswer: 1,
    variants: [
      "`4` `5` `6`",
      "`6` `5` `4`",
      "`4` `function` `function`",
      "`undefined` `undefined` `6`",
    ],
    explanation:
      "`add`함수는 화살표 함수를 반환하는 함수를 반환하고, 반환한 함수는 화살표 함수를 반환하고, 반환한 함수는 화살표 함수를 반환해요(아직 나와 함께인가요?). 첫 번째 함수는 값이 `4`인 인수 `x`를 받아요. 값이 `5`인 인수 `y`를 받은 두 번째 함수를 호출해요. 그리고 우리는 값이 `6`인 인수 `z`를 받은 세 번째 함수를 호출해요. 값 `x`, `y` 그리고 `z`를 가진 마지막 화살표 함수에 접근하려고 할 때, JS 엔진은 그에 따른 값 `x` 그리고 `y`를 찾기 위해 스코프 체인을 올라가요. 이건 `4` `5` `6`을 반환해요.",
    id: 123,
  },
  {
    grade: Grades.Middle,
    theme: Themes.ASYNC,
    question: "무엇이 출력 될까요?",
    code: "async function* range(start, end) {\n  for (let i = start; i <= end; i++) {\n    yield Promise.resolve(i);\n  }\n}\n\n(async () => {\n  const gen = range(1, 3);\n  for await (const item of gen) {\n    console.log(item);\n  }\n})();",
    correctAnswer: 3,
    variants: [
      "`Promise {1}` `Promise {2}` `Promise {3}`",
      "`Promise {<pending>}` `Promise {<pending>}` `Promise {<pending>}`",
      "`1` `2` `3`",
      "`undefined` `undefined` `undefined`",
    ],
    explanation:
      "제너레이터 함수 `range`은 range에 전달한 각각의 아이템에 promise를 가진 async 객체를 반환해요: `Promise{1}`, `Promise{2}`, `Promise{3}`. 변수 `gen`을 async 객체로 만들고, 그후에 `for await ... of` 루프를 사용해서 순환해요. 변수 `item`은 반환된 Promise 값 만들어요: 첫번째는 `Promise{1}`, 그다음은 `Promise{2}`, 그다음은 `Promise{3}`. `item`의 값인 프로미스를 resolved 하기 위해 _기다리고_, resolved 된 프로미스의 _값_ 은 반환돼요: `1`, `2`, 그리고 `3`.",
    id: 124,
  },
  {
    grade: Grades.Junior,
    theme: Themes.DATA_TYPES,
    question: "무엇이 출력 될까요?",
    code: "const myFunc = ({ x, y, z }) => {\n  console.log(x, y, z);\n};\n\nmyFunc(1, 2, 3);",
    correctAnswer: 4,
    variants: [
      "`1` `2` `3`",
      "`{1: 1}` `{2: 2}` `{3: 3}`",
      "`{ 1: undefined }` `undefined` `undefined`",
      "`undefined` `undefined` `undefined`",
    ],
    explanation:
      "`myFunc`는 속성 `x`, `y` 그리고 `z`를 속성으로 가진 객체가 인수라고 예상해요. `x`, `y` 그리고 `z`의 속성을 가진 하나의 객체({x: 1, y: 2, z: 3}) 대신, 분리된 숫자 값 (1, 2, 3)을 전달했기 때문에 `x`, `y` 그리고 `z`는 기본값 `undefined`을 가져요.",
    id: 125,
  },
  {
    grade: Grades.Junior,
    theme: Themes.MISC,
    question: "무엇이 출력 될까요?",
    code: "function getFine(speed, amount) {\n  const formattedSpeed = new Intl.NumberFormat('en-US', {\n    style: 'unit',\n    unit: 'mile-per-hour',\n  }).format(speed);\n\n  const formattedAmount = new Intl.NumberFormat('en-US', {\n    style: 'currency',\n    currency: 'USD',\n  }).format(amount);\n\n  return `The driver drove ${formattedSpeed} and has to pay ${formattedAmount}`;\n}\n\nconsole.log(getFine(130, 300));",
    correctAnswer: 2,
    variants: [
      "The driver drove 130 and has to pay 300",
      "The driver drove 130 mph and has to pay \\$300.00",
      "The driver drove undefined and has to pay undefined",
      "The driver drove 130.00 and has to pay 300.00",
    ],
    explanation:
      "`Intl.NumberFormat` 메소드를 사용하면, 숫자 값을 원하는 로케일로 만들 수 있어요. 숫자 값 `130`을 `unit`이 `mile-per-hour`인 로케일 `en-US`로 만들면, `130 mph`가 돼요. 숫자 값 `300`을 `currency`가 `USD`인 로케일 `en-US`로 만들면 `$300.00`가 돼요.",
    id: 126,
  },
  {
    grade: Grades.Junior,
    theme: Themes.DATA_TYPES,
    question: "무엇이 출력 될까요?",
    code: "const spookyItems = ['👻', '🎃', '🕸'];\n({ item: spookyItems[3] } = { item: '💀' });\n\nconsole.log(spookyItems);",
    correctAnswer: 2,
    variants: [
      '`["👻", "🎃", "🕸"]`',
      '`["👻", "🎃", "🕸", "💀"]`',
      '`["👻", "🎃", "🕸", { item: "💀" }]`',
      '`["👻", "🎃", "🕸", "[object Object]"]`',
    ],
    explanation:
      '객체를 분해함으로써, 오른쪽 객체의 값을 꺼내고, 꺼낸 값은 왼쪽 객체에 같은 속성 이름의 값으로 할당 할 수 있어요. 이 경우, 값 "💀"을 `spookyItems[3]`에 할당했어요. 이건 `spookyItems`을 수정, 즉 배열에 "💀"을 추가한다는 의미예요. `spookyItems`을 출력하면, `["👻", "🎃", "🕸", "💀"]`이 출력ㅗ대요.',
    id: 127,
  },
  {
    grade: Grades.Junior,
    theme: Themes.DATA_TYPES,
    question: "무엇이 출력 될까요?",
    code: "const name = 'Lydia Hallie';\nconst age = 21;\n\nconsole.log(Number.isNaN(name));\nconsole.log(Number.isNaN(age));\n\nconsole.log(isNaN(name));\nconsole.log(isNaN(age));",
    correctAnswer: 3,
    variants: [
      "`true` `false` `true` `false`",
      "`true` `false` `false` `false`",
      "`false` `false` `true` `false`",
      "`false` `true` `false` `true`",
    ],
    explanation:
      "`Number.isNaN` 메소드를 사용하면, 전달한 값이 _숫자 값_ 그리고 `NaN`인지 확인 할 수 있어요. `name`은 숫자 값이 아니에요, 따라서 `Number.isNaN(name)` 은 `false`을 반환해요. `age`는 숫자 값이지만, `NaN`은 아니에요, 따라서 `Number.isNaN(age)`은 `false`을 반환해요.\n\n`isNaN` 메소드를 사용하면, 전달한 값이 숫자가 아닌지 확인할 수 있어요. `name`은 숫자가 아니에요, 따라서 `isNaN(name)`은 true를 반환해요. `age`은 숫자이고, 따라서 `isNaN(age)`은 `false`을 반환해요.",
    id: 128,
  },
  {
    grade: Grades.Junior,
    theme: Themes.BASICS,
    question: "무엇이 출력 될까요?",
    code: "const randomValue = 21;\n\nfunction getInfo() {\n  console.log(typeof randomValue);\n  const randomValue = 'Lydia Hallie';\n}\n\ngetInfo();",
    correctAnswer: 4,
    variants: ['`"number"`', '`"string"`', "`undefined`", "`ReferenceError`"],
    explanation:
      "`const` 키워드를 사용해 선언된 변수는 초기화 되기 전에 참조 할 수 없어요: 이건 _일시적 사각지대_ 라고 불려요. `getInfo`힘수에서, 변수 `randomValue`는 함수 `getInfo`의 스코프 안에 있어요. `typeof randomValue`의 값을 출력하고 싶은 줄에서, 변수 `randomValue`는 아직 초기화 되지 않았어요: `ReferenceError`가 던져져요! 변수 `randomValue`를 함수 `getInfo`안에 선언했기 때문에 엔진은 스코프 체인 아래로 내려가지 않아요.",
    id: 129,
  },
  {
    grade: Grades.Middle,
    theme: Themes.ERRORS,
    question: "무엇이 출력 될까요?",
    code: "const myPromise = Promise.resolve('Woah some cool data');\n\n(async () => {\n  try {\n    console.log(await myPromise);\n  } catch {\n    throw new Error(`Oops didn't work`);\n  } finally {\n    console.log('Oh finally!');\n  }\n})();",
    correctAnswer: 3,
    variants: [
      "`Woah some cool data`",
      "`Oh finally!`",
      "`Woah some cool data` `Oh finally!`",
      "`Oops didn't work` `Oh finally!`",
    ],
    explanation:
      '`try` 블록에서, `myPromise`의 awaited 값을 출력하고 있어요: `"Woah some cool data"`. `try` 블록에서 오류가 없기 때문에, `catch` 블록 안의 코드는 실행되지 않아요. `finally` 블록 안의 코드는 _항상_ 실행되고, `"Oh finally!"`가 출력돼요.',
    id: 130,
  },
  {
    grade: Grades.Junior,
    theme: Themes.ECMASCRIPT,
    question: "무엇이 출력 될까요?",
    code: "const emojis = ['🥑', ['✨', '✨', ['🍕', '🍕']]];\n\nconsole.log(emojis.flat(1));",
    correctAnswer: 2,
    variants: [
      "`['🥑', ['✨', '✨', ['🍕', '🍕']]]`",
      "`['🥑', '✨', '✨', ['🍕', '🍕']]`",
      "`['🥑', ['✨', '✨', '🍕', '🍕']]`",
      "`['🥑', '✨', '✨', '🍕', '🍕']`",
    ],
    explanation:
      "`flat`를 사용하면, 새로운 평평한 배열을 만들어요. 평평한 배열의 깊이는 전달한 값에 달려있어요. 이 경우, 값 `1`(기본 값)을 전달했고,, 1번째 깊이에 있는 배열만 연결된다는 뜻이에요. 이 경우에선 `['🥑']` 그리고 `['✨', '✨', ['🍕', '🍕']]`. 두 배열을 연결하면 `['🥑', '✨', '✨', ['🍕', '🍕']]`가 돼요.",
    id: 131,
  },
  {
    grade: Grades.Middle,
    theme: Themes.CLASSES,
    question: "무엇이 출력 될까요?",
    code: "class Counter {\n  constructor() {\n    this.count = 0;\n  }\n\n  increment() {\n    this.count++;\n  }\n}\n\nconst counterOne = new Counter();\ncounterOne.increment();\ncounterOne.increment();\n\nconst counterTwo = counterOne;\ncounterTwo.increment();\n\nconsole.log(counterOne.count);",
    correctAnswer: 4,
    variants: ["`0`", "`1`", "`2`", "`3`"],
    explanation:
      "`counterOne`는 클래스 `Counter`의 인스턴스예요. counter 클래스는 생성자 안에 속성 `count`와 `increment` 메소드를 포함해요. 우선, `counterOne.increment()`를 사용해 `increment` 메소드를 두 번 호출해요. 현재, `counterOne.count`는 `2`예요.\n\n![Image](https://i.imgur.com/KxLlTm9.png)\n\n그리고서, 새로운 변수 `counterTwo`를 만들고, `counterOne`과 동일하게 설정해요. 객체는 참조로 상호작용 하므로, `counterOne`을 가리키는 같은 메모리 영역에 새로운 참조를 만들었어요. 메모리의 같은 장소에 존재 하므로, 참조를 가진 `counterTwo` 객체의 모든 변화는, `counterOne` 객체에도 적용돼요. 지금, `counterTwo.count`은 `2`예요.\n\n`count`를 `3`으로 만드는 `counterTwo.increment()`를 호출해요. 그리고서, `counterOne`의 count를 출력하고, `3`이 출력돼요.\n\n![Image](https://i.imgur.com/BNBHXmc.png)",
    id: 132,
  },
  {
    grade: Grades.Middle,
    theme: Themes.ASYNC,
    question: "무엇이 출력 될까요?",
    code: "const myPromise = Promise.resolve(Promise.resolve('Promise!'));\n\nfunction funcOne() {\n  myPromise.then((res) => res).then((res) => console.log(res));\n  setTimeout(() => console.log('Timeout!'), 0);\n  console.log('Last line!');\n}\n\nasync function funcTwo() {\n  const res = await myPromise;\n  console.log(await res);\n  setTimeout(() => console.log('Timeout!'), 0);\n  console.log('Last line!');\n}\n\nfuncOne();\nfuncTwo();",
    correctAnswer: 4,
    variants: [
      "`Promise! Last line! Promise! Last line! Last line! Promise!`",
      "`Last line! Timeout! Promise! Last line! Timeout! Promise!`",
      "`Promise! Last line! Last line! Promise! Timeout! Timeout!`",
      "`Last line! Promise! Promise! Last line! Timeout! Timeout!`",
    ],
    explanation:
      '우선, `funcOne`를 호출했어요. `funcOne`의 첫 번째 줄에서, _비동기_ 작업 `myPromise` 프로미스를 불러요. 엔진이 프로미스를 처리하느라고 바쁜 와중에도, 계속해서 `funcOne` 함수를 실행해요. 다음 줄은 _비동기_ `setTimeout` 함수이고, 콜백을 Web API로 보내요. (내가 작성한 이벤트 루프에 대한 글 보기 <a href="https://dev.to/lydiahallie/javascript-visualized-event-loop-3dif">여기</a>.)\n\n프라미스와 타임아웃 모두 비동기 작업이고, 함수는 프라미스 함수와 `setTimeout` 콜백을 처리하느라고 바쁜 와중에도 계속해서 실행해요. 이건 비동기 작업이 아닌 `Last line!`가 첫 번째로 출력된다는 걸 의미해요. 이건 `funcOne` 함수의 마지막 줄에 있고, 프라미스가 resolved 되어, `Promise!`가 출력돼요. 그러나, `funcTwo()`를 호출 했기 때문에, 콜 스택은 비어있지 않고, `setTimeout` 콜백 함수는 아직 콜 스택에 추가할 수 없어요.\n\n`funcTwo`에서, 우선 myPromise 프라미스를 _기다려요_. `await`키워드를 사용해서, 프라미스가 resolved (or rejected) 될 때까지 함수의 실행을 멈췄어요. 그리고서, `res`의 값을 기다렸다가 출력해요. (프라미스 자체가 프라미스를 반환하기 때문에). 이건 `Promise!`을 출력해요.\n\n다음 줄은 _비동기_ `setTimeout` 함수로, 콜백을 Web API로 보내요.\n\n`funcTwo`의 마지막 줄에서, `Last line!`가 콘솔에 출력돼요. 지금, `funcTwo`가 콜 스택에서 제거되었기 때문에, 콜 스택은 비어있어요. 대기열에서 대기 중인 콜백은(`funcOne`에서의 (`() => console.log("Timeout!")`, 그리고 `funcTwo`에서의 `() => console.log("Timeout!")`) 호출 스택에 하나씩 추가되어요. 첫 번째 콜백은 `Timeout!`을 출력하고, 스택에서 제거돼요. 그리고서, 두 번째 콜백은 `Timeout!`을 출력하고, 스택에서 제거돼요. 이건 `Last line! Promise! Promise! Last line! Timeout! Timeout!`을 출력해요.',
    id: 133,
  },
  {
    grade: Grades.Middle,
    theme: Themes.MODULES,
    question:
      "`index.js`에서 `sum.js` 안에 있는 `sum`을 호출 하려면 어떻게 해야하나요?",
    code: "// sum.js\nexport default function sum(x) {\n  return x + x;\n}\n\n// index.js\nimport * as sum from './sum';",
    correctAnswer: 3,
    variants: [
      "`sum(4)`",
      "`sum.sum(4)`",
      "`sum.default(4)`",
      "Default aren't imported with `*`, only named exports",
    ],
    explanation:
      "별표 `*`를 사용하면, 파일에서 내보낸 모든 값(기본값과 명명된 것 모두)을 가져와요. 만약 다음 파일을 가지고 있다면:\n\n``` js\n// info.js\nexport const name = 'Lydia';\nexport const age = 21;\nexport default 'I love JavaScript';\n\n// index.js\nimport * as info from './info';\nconsole.log(info);\n```\n\n아래와 같이 출력될 거예요:\n\n``` js\n{\n  default: \"I love JavaScript\",\n  name: \"Lydia\",\n  age: 21\n}\n```\n\n`sum`을 예로 들자면, 가져온 `sum`의 값은 다음처럼 보인다는 의미에요:\n\n``` js\n{ default: function sum(x) { return x + x } }\n```\n\n`sum.default`을 불러 함수를 호출 할 수 있어요.",
    id: 134,
  },
  {
    grade: Grades.Junior,
    theme: Themes.MISC,
    question: "무엇이 출력 될까요?",
    code: "const handler = {\n  set: () => console.log('Added a new property!'),\n  get: () => console.log('Accessed a property!'),\n};\n\nconst person = new Proxy({}, handler);\n\nperson.name = 'Lydia';\nperson.name;",
    correctAnswer: 3,
    variants: [
      "`Added a new property!`",
      "`Accessed a property!`",
      "`Added a new property!` `Accessed a property!`",
      "Nothing gets logged",
    ],
    explanation:
      'Proxy 객체를 사용하면, 두번째 인수로 전달 한 객체에 사용자 지정 동작을 추가 할 수 있어요. 이 경우엔, 두 개의 속성을 가진 `handler` 객체를 전달 했어요: `set` 과 `get` 속성 값을 _설정_ 할 때마다 `set`은 호출되고, `get`은 속성 값을 _얻을_ (접근)때 마다 호출되어요.\n\n첫 번째 인수는 빈 객체 `{}`고, `person`의 값이에요. 이 객체에 객체 `handler`의 사용자 지정 동작을 추가했어요. `person` 객체에 속성을 추가하면, `set` 이 호출 돼요. `person` 객체의 속성에 접근하면, `get` 이 호출 돼요.\n\n우선, 프록시 객체에 새로운 속성 `name`을 추가했어요(`person.name = "Lydia"`). `set`이 호출되고, `"Added a new property!"`을 출력 해요.\n\n그리고서, 프록시 객체의 속성 값에 접근하고, handler 객체의 속성 `get` 이 호출 돼요. `"Accessed a property!"`을 출력 해요.',
    id: 135,
  },
  {
    grade: Grades.Junior,
    theme: Themes.OBJECTS,
    question: "다음 중 어느 것이 `person` 객체를 수정 할 수 있을까요?",
    code: "const person = { name: 'Lydia Hallie' };\n\nObject.seal(person);",
    correctAnswer: 1,
    variants: [
      '`person.name = "Evan Bacon"`',
      "`person.age = 21`",
      "`delete person.name`",
      "`Object.assign(person, { age: 21 })`",
    ],
    explanation:
      "`Object.seal`을 사용하면, 새로운 속성이 _추가_ 되거나, 혹은 존재하는 속성이 _제거_ 되는 것을 막을 수 있어요.\n\n그러나, 여전히 존재하는 속성의 값을 수정 할 수 있어요.",
    id: 136,
  },
  {
    grade: Grades.Junior,
    theme: Themes.OBJECTS,
    question: "다음 중 어느 것이 `person` 객체를 수정 할 수 있을까요?",
    code: "const person = {\n  name: 'Lydia Hallie',\n  address: {\n    street: '100 Main St',\n  },\n};\n\nObject.freeze(person);",
    correctAnswer: 3,
    variants: [
      '`person.name = "Evan Bacon"`',
      "`delete person.address`",
      '`person.address.street = "101 Main St"`',
      '`person.pet = { name: "Mara" }`',
    ],
    explanation:
      "`Object.freeze` 메소드는 객체를 _얼려요_ . 속성을 추가, 수정, 제거 할 수 없어요.\n\n하지만, 객체를 _얕은_ 수준으로만 얼리고, 이건 객체의 _직접적인_ 속성만 얼려진다는 의미예요. 속성이 `address` 와 같은 객체인 경우, 객체의 속성은 얼려지지 않고, 수정될 수 있어요.",
    id: 137,
  },
  {
    grade: Grades.Middle,
    theme: Themes.FUNCTIONS,
    question: "무엇이 출력 될까요?",
    code: "const add = (x) => x + x;\n\nfunction myFunc(num = 2, value = add(num)) {\n  console.log(num, value);\n}\n\nmyFunc();\nmyFunc(3);",
    correctAnswer: 1,
    variants: [
      "`2` `4` and `3` `6`",
      "`2` `NaN` and `3` `NaN`",
      "`2` `Error` and `3` `6`",
      "`2` `4` and `3` `Error`",
    ],
    explanation:
      "우선, `myFunc()` 를 어떤 인수도 전달하지 않고 호출했어요. 인수를 전달하지 않았기 때문에, `num` 와 `value` 는 그들의 기본값을 가져요: num 는 `2`, `value` 함수 `add`에서 반환된 값. `add` 함수에서, 값이 `2`인 `num`를 인수로 전달했어요. `add`는 `value`의 값인 `4`를 반환해요.\n\n그리고서, `myFunc(3)`를 호출하고 인수 `num`의 값으로 값 `3`을 전달했어요. `value` 값은 전달하지 않았어요. 인수 `value`에 값을 전달하지 않았기 때문에, 기본값을 가져요: 함수 `add`에서 반환된 값. `add`에서, 값 `3`을 가진 `num`을 전달해요. `add`는 `value`의 값으로 `6`을 반환해요.",
    id: 138,
  },
  {
    grade: Grades.Junior,
    theme: Themes.ECMASCRIPT,
    question: "무엇이 출력 될까요?",
    code: "class Counter {\n  #number = 10;\n\n  increment() {\n    this.#number++;\n  }\n\n  getNum() {\n    return this.#number;\n  }\n}\n\nconst counter = new Counter();\ncounter.increment();\n\nconsole.log(counter.#number);",
    correctAnswer: 4,
    variants: ["`10`", "`11`", "`undefined`", "`SyntaxError`"],
    explanation:
      "ES2020에서, `#`을 사용한 private 변수를 추가 할 수 있어요. 클래스 외부에서 private 변수에 접근 할 수 없어요. `counter.#number`을 출력하려고 할 때, SyntaxError가 던져져요: `Counter` 클래스 외부에서 private 변수에 접근 할 수 없어요!",
    id: 139,
  },
  {
    grade: Grades.Junior,
    theme: Themes.ASYNC,
    question: "무엇이 빠졌을까요?",
    code: "const teams = [\n  { name: 'Team 1', members: ['Paul', 'Lisa'] },\n  { name: 'Team 2', members: ['Laura', 'Tim'] },\n];\n\nfunction* getMembers(members) {\n  for (let i = 0; i < members.length; i++) {\n    yield members[i];\n  }\n}\n\nfunction* getTeams(teams) {\n  for (let i = 0; i < teams.length; i++) {\n    // ✨ SOMETHING IS MISSING HERE ✨\n  }\n}\n\nconst obj = getTeams(teams);\nobj.next(); // { value: \"Paul\", done: false }\nobj.next(); // { value: \"Lisa\", done: false }",
    correctAnswer: 2,
    variants: [
      "`yield getMembers(teams[i].members)`",
      "`yield* getMembers(teams[i].members)`",
      "`return getMembers(teams[i].members)`",
      "`return yield getMembers(teams[i].members)`",
    ],
    explanation:
      "`teams` 배열의 `members`의 각 요소를 계속해서 반복하기 위해선, `teams[i].members`를 제너레이터 함수 `getMembers`에 전달해야해요. 제너레이터 함수는 제너리에터 객체를 리턴해요. 제너레이터 객체의 각 요소를 계속해서 반복 하기 위해선, `yield*`를 사용해야 해요.\n\n`yield`, `return yield` 또는 `return`를 쓰면, 모든 제너레이터 함수는 첫번째로 호출한 `next` 메소드가 반환한 값을 가져요.",
    id: 140,
  },
  {
    grade: Grades.Junior,
    theme: Themes.DATA_TYPES,
    question: "무엇이 출력 될까요?",
    code: "const person = {\n  name: 'Lydia Hallie',\n  hobbies: ['coding'],\n};\n\nfunction addHobby(hobby, hobbies = person.hobbies) {\n  hobbies.push(hobby);\n  return hobbies;\n}\n\naddHobby('running', []);\naddHobby('dancing');\naddHobby('baking', person.hobbies);\n\nconsole.log(person.hobbies);",
    correctAnswer: 3,
    variants: [
      '`["coding"]`',
      '`["coding", "dancing"]`',
      '`["coding", "dancing", "baking"]`',
      '`["coding", "running", "dancing", "baking"]`',
    ],
    explanation:
      '`addHobby` 함수는 인수 두 개 `hobby` 와 `person` 객체의 배열 `hobbies`의 값을 기본값으로 가진 `hobbies`를 받아요.\n\n우선, `addHobby` 함수를 호출하고, `hobby`의 값으로 `"running"`을 그리고 `hobbies`의 값으로 빈 배열을 전달해요. `hobbies`의 값으로 빈 배열을 전달했기 때문에, `"running"`은 빈 배열에 추가돼요.\n\n그리고서, `addHobby` 함수를 호출하고, `hobby`의 값으로 `"dancing"`를 전달해요. `hobbies`에 값을 전달하지 않았고, `person` 객체의 속성 `hobbies`을 기본값으로 가져요. 배열 `person.hobbies`에 `dancing`를 추가해요.\n\n마지막으로, `addHobby` 함수를 호출해, `hobby`의 값으로 `"baking"`를 전달하고, `hobbies`의 값으로 배열 `person.hobbies`을 전달해요. 배열 `person.hobbies`에 `baking`을 추가해요.\n\n`dancing` 과 `baking`을 추가한 후, `person.hobbies`의 값은 `["coding", "dancing", "baking"]`예요.',
    id: 141,
  },
  {
    grade: Grades.Junior,
    theme: Themes.CLASSES,
    question: "무엇이 출력 될까요?",
    code: 'class Bird {\n  constructor() {\n    console.log("I\'m a bird. 🦢");\n  }\n}\n\nclass Flamingo extends Bird {\n  constructor() {\n    console.log("I\'m pink. 🌸");\n    super();\n  }\n}\n\nconst pet = new Flamingo();',
    correctAnswer: 2,
    variants: [
      "`I'm pink. 🌸`",
      "`I'm pink. 🌸` `I'm a bird. 🦢`",
      "`I'm a bird. 🦢` `I'm pink. 🌸`",
      "Nothing, we didn't call any method",
    ],
    explanation:
      '`Flamingo` 클래스의 인스턴스인 변수 `pet` 생성했어요. 인스턴스를 인스턴스화 할 때, `Flamingo`의 `constructor`를 불러요. 우선, `"I\'m pink. 🌸"`가 출력되고, 그 후에 `super()`를 불러요. `super()`는 부모 클래스 `Bird`의 constructor를 불러요. `Bird`의 constructor 를 불러, `"I\'m a bird. 🦢"`가 출력돼요.',
    id: 142,
  },
  {
    grade: Grades.Junior,
    theme: Themes.DATA_TYPES,
    question: "다음 중 어느 것의 결과가 오류일까요?",
    code: "const emojis = ['🎄', '🎅🏼', '🎁', '⭐'];\n\n/* 1 */ emojis.push('🦌');\n/* 2 */ emojis.splice(0, 2);\n/* 3 */ emojis = [...emojis, '🥂'];\n/* 4 */ emojis.length = 0;",
    correctAnswer: 4,
    variants: ["1", "1 and 2", "3 and 4", "3"],
    explanation:
      "`const` 키워드는 단순히 변수의 값을 _재선언_ 할 수 없고, _읽기만_ 가능하다는 의미예요. 하지만, 값 자체가 불변하는 건 아니에요. 배열 `emojis`의 속성을 수정할 수 있는데, 예를 들자면 새로운 값을 추가하거나, 원본 배열 자체를 수정(splice)하거나, 배열의 길이를 0으로 설정 할 수 있어요.",
    id: 143,
  },
  {
    grade: Grades.Middle,
    theme: Themes.DATA_TYPES,
    question:
      '`person`에 무엇을 추가해야 `[...person]`의 결과로 `["Lydia Hallie", 21]`를 얻을 수 있을까요?',
    code: 'const person = {\n  name: "Lydia Hallie",\n  age: 21\n}\n\n[...person] // ["Lydia Hallie", 21]',
    correctAnswer: 3,
    variants: [
      "객체는 기본적으로 반복 가능 하므로, 아무것도 하지 않아요.",
      "`*[Symbol.iterator]() { for (let x in this) yield* this[x] }`",
      "`*[Symbol.iterator]() { yield* Object.values(this) }`",
      "`*[Symbol.iterator]() { for (let x in this) yield this }`",
    ],
    explanation:
      '객체는 기본적으로 반복 불가능해요. 반복 가능한 객체는 iterator protocol이 제공되면 반복 가능해요. 제너레이터 함수 `*[Symbol.iterator]() {}`을 만드는 제너레이터 객체를 반환하는 iterator symbol `[Symbol.iterator]`을 수동으로 추가 할 수 있어요. 배열 `["Lydia Hallie", 21]`을 반환 하려면 제너레이터 함수는 `person` 객체의 `Object.values`를 yield 해야해요: `yield* Object.values(this)`.',
    id: 144,
  },
  {
    grade: Grades.Junior,
    theme: Themes.BASICS,
    question: "무엇이 출력 될까요?",
    code: "let count = 0;\nconst nums = [0, 1, 2, 3];\n\nnums.forEach((num) => {\n  if (num) count += 1;\n});\n\nconsole.log(count);",
    correctAnswer: 3,
    variants: ["1", "2", "3", "4"],
    explanation:
      "`forEach` 순환에 포함 된 `if` 조건문은 `num`의 값이 진짜 같은 값인지 또는 가짜 같은 값인지 확인해요. `nums`배열의 첫 번째 값은 거짓 같은 값 `0`이고, `if` 조건문의 코드 블럭은 실행되지 않아요. `count` 는 오직 `nums` 배열의 다른 숫자 3개에 대해서만 증가해요. `1`, `2` 그리고 `3`. `count`는 3번 동안 `1` 씩 증가하고, `count`의 값은 `3`이에요.",
    id: 145,
  },
  {
    grade: Grades.Middle,
    theme: Themes.ECMASCRIPT,
    question: "무엇이 출력 될까요?",
    code: "function getFruit(fruits) {\n  console.log(fruits?.[1]?.[1]);\n}\n\ngetFruit([['🍊', '🍌'], ['🍍']]);\ngetFruit();\ngetFruit([['🍍'], ['🍊', '🍌']]);",
    correctAnswer: 4,
    variants: [
      "`null`, `undefined`, 🍌",
      "`[]`, `null`, 🍌",
      "`[]`, `[]`, 🍌",
      "`undefined`, `undefined`, 🍌",
    ],
    explanation:
      "`?`는 객체 내에서 더 깊이 중첩된 속성에 접근하는 것을 선택적으로 허용해요. `fruits`배열의 인덱스 `1`에 있는 하위 배열의 인덱스 `1`의 아이템을 출력하려해요. `fruits`배열의 인덱스 `1`에 하위 배열이 존재하지 않는다면, 간단히 `undefined`를 반환할 거예요. `fruits` 배열의 인덱스 `1`에 하위배열이 있지만, 하위 배열에 인덱스 `1` 의 아이템이 없다면, 그것 역시 `undefined`를 반환해요.\n\n우선, `[['🍊', '🍌'], ['🍍']]`의 하위 배열의 두 번째 아이템 `['🍍']`을 출력해요 . 하위 배열은 아이템 하나만 가지고 있고, 이건 인덱스 `1`에 대한 아이템을 갖고 있지 않다는 의미로 `undefined`를 반환해요.\n\n그리고서, 인수에 어떤 값도 전달하지 않은 `getFruits` 함수를 호출 하고, `fruits`은 기본값으로 값 `undefined`을 가져요. `fruits`의 인덱스 `1`의 아이템을 선택적으로 연결(conditionally chaining)하기 때문에, 인덱스 `1`에 아이템이 존재하지 않아 `undefined`를 반환해요.\n\n마지막으로, `['🍍'], ['🍊', '🍌']`의 하위 배열 `['🍊', '🍌']`의 두번째 아이템을 출력하려고 해요. 하위 배열의 인덱스 `1`의 아이템인 `🍌`이 출력돼요.",
    id: 146,
  },
  {
    grade: Grades.Middle,
    theme: Themes.CLASSES,
    question: "무엇이 출력 될까요?",
    code: "class Calc {\n\tconstructor() {\n\t\tthis.count = 0 \n\t}\n\n\tincrease() {\n\t\tthis.count ++\n\t}\n}\n\nconst calc = new Calc()\nnew Calc().increase()\n\nconsole.log(calc.count)",
    correctAnswer: 1,
    variants: ["`0`", "`1`", "`undefined`", "`ReferenceError`"],
    explanation:
      "변수 `calc`를 `Calc` 클래스의 새로운 인스턴스로 설정 했어요. 그리고서, 새로운 인스턴스 `Calc`를 인스턴스화 하고, 이 인스턴스의 `increase` 메소드를 호출 했어요. 속성 count은 `Calc` 클래스의 생성자 안에 있기 때문에 , 속성 count은 `Calc`의 프로토타입에 공유될 수 없어요. 인스턴스 calc이 가리키는 count의 값은 업데이트 되지 않고, count는 여전히 `0`예요.",
    id: 147,
  },
  {
    grade: Grades.Middle,
    theme: Themes.OBJECTS,
    question: "무엇이 출력 될까요?",
    code: 'const user = {\n\temail: "e@mail.com",\n\tpassword: "12345"\n}\n\nconst updateUser = ({ email, password }) => {\n\tif (email) {\n\t\tObject.assign(user, { email })\n\t}\n\n\tif (password) {\n\t\tuser.password = password\n\t}\n\n\treturn user\n}\n\nconst updatedUser = updateUser({ email: "new@email.com" })\n\nconsole.log(updatedUser === user)',
    correctAnswer: 2,
    variants: ["`false`", "`true`", "`TypeError`", "`ReferenceError`"],
    explanation:
      "`updateUser` 함수는 값이 전달 되면 user의 속성 `email` 과 `password`의 값을 업데이트 하고, `user`객체를 반환해요. `updateUser` 함수의 반환된 값은 객체 `user` 이고, updateUser의 값은 `user`가 가리키는 `user` 객체의 참조와 같다는 의미예요. `updatedUser === user`는 `true`예요.",
    id: 148,
  },
  {
    grade: Grades.Junior,
    theme: Themes.DATA_TYPES,
    question: "무엇이 출력 될까요?",
    code: "const fruit = ['🍌', '🍊', '🍎']\n\nfruit.slice(0, 1)\nfruit.splice(0, 1)\nfruit.unshift('🍇')\n\nconsole.log(fruit)",
    correctAnswer: 3,
    variants: [
      "`['🍌', '🍊', '🍎']`",
      "`['🍊', '🍎']`",
      "`['🍇', '🍊', '🍎']`",
      "`['🍇', '🍌', '🍊', '🍎']`",
    ],
    explanation:
      "우선, fruit 배열에 `slice` 메소드를 호출해요. slice 메소드는 원본 배열을 수정하지 않지만, 배열에서 잘라낸(slice) 값을 반환해요: 바나나 이모지.\n그리고서, fruit 배열에 `splice` 메소드를 호출해요. splice 메소드는 원본 배열을 수정하고, 이제 fruit 배열은 `['🍊', '🍎']`로 구성돼요.\n마지막엔, `fruit` 배열에 `unshift` 메소드를 호출하고, 이 경우엔 제공된 값 ‘🍇’을 배열의 첫 번째 요소로 추가해 원본 배열을 수정해요. 이제 fruit 배열은 `['🍇', '🍊', '🍎']`로 구성돼요.",
    id: 149,
  },
  {
    grade: Grades.Junior,
    theme: Themes.DATA_TYPES,
    question: "무엇이 출력 될까요?",
    code: "const animals = {};\nlet dog = { emoji: '🐶' }\nlet cat = { emoji: '🐈' }\n\nanimals[dog] = { ...dog, name: \"Mara\" }\nanimals[cat] = { ...cat, name: \"Sara\" }\n\nconsole.log(animals[dog])",
    correctAnswer: 2,
    variants: [
      '`{ emoji: "🐶", name: "Mara" }`',
      '`{ emoji: "🐈", name: "Sara" }`',
      "`undefined`",
      "`ReferenceError`",
    ],
    explanation:
      '객체의 키는 문자열로 변환돼요.\n\n`dog`의 값은 객체 이므로, 사실 `animals[dog]`는 새로운 객체에 `"object Object"`라고 불리는 새로운 속성을 만든 걸 의미해요. 이제 `animals["object Object"]`는 `{ emoji: "🐶", name: "Mara"}`예요.\n\n`cat`도 물론 객체고, 사실 `animals[cat]`은 `animals[``"``object Object``"``]`을 새로운 속성 cat으로 덮어쓰고 있다는 것을 의미해요.\n\n`animals[dog]` 또는 `animals["object Object"]`(`dog` 객체를 문자열로 변환한 결과는 `"object Object"`)를 출력하면, `{ emoji: "🐈", name: "Sara" }`를 반환해요.',
    id: 150,
  },
  {
    grade: Grades.Junior,
    theme: Themes.OBJECTS,
    question: "무엇이 출력 될까요?",
    code: 'const user = {\n\temail: "my@email.com",\n\tupdateEmail: email => {\n\t\tthis.email = email\n\t}\n}\n\nuser.updateEmail("new@email.com")\nconsole.log(user.email)',
    correctAnswer: 1,
    variants: [
      "`my@email.com`",
      "`new@email.com`",
      "`undefined`",
      "`ReferenceError`",
    ],
    explanation:
      "`updateEmail`함수는 화살표 함수로, `user`객체에 바인딩 되지 않았어요. `this`키워드는 `user`객체를 참조하지 않지만, 이 경우엔 전역 범위를 참조하고 있다는 의미예요. `user` 객체의 `email` 는 업데이트 되지 않아요. `user.email`을 출력할 때, `my@email.com`의 원래의 값이 반환되어요.",
    id: 151,
  },
  {
    grade: Grades.Junior,
    theme: Themes.ASYNC,
    question: "무엇이 출력 될까요?",
    code: "const promise1 = Promise.resolve('First')\nconst promise2 = Promise.resolve('Second')\nconst promise3 = Promise.reject('Third')\nconst promise4 = Promise.resolve('Fourth')\n\nconst runPromises = async () => {\n\tconst res1 = await Promise.all([promise1, promise2])\n\tconst res2  = await Promise.all([promise3, promise4])\n\treturn [res1, res2]\n}\n\nrunPromises()\n\t.then(res => console.log(res))\n\t.catch(err => console.log(err))",
    correctAnswer: 4,
    variants: [
      "`[['First', 'Second'], ['Fourth']]`",
      "`[['First', 'Second'], ['Third', 'Fourth']]`",
      "`[['First', 'Second']]`",
      "`'Third'`",
    ],
    explanation:
      '`Promise.all` 메소드는 프로미스를 병렬로 실행해요. 만약 하나의 프로미스가 실패하면, `Promise.all` 메소드는 rejected 프로미스의 값을 가지고 _rejects_ 되어요. 이 경우, `promise3`는 값 `"Third"`과 함께 rejected 되었어요. `runPromises` 호출에 연결되어 있고 `runPromises` 함수 안에서 모든 에러를 잡은 `catch` 메소드에서 rejected 값을 잡아요. `promise3`가 이 값과 함께 rejected 되어 `"Third"`만 출력돼요.',
    id: 152,
  },
  {
    grade: Grades.Junior,
    theme: Themes.OBJECTS,
    question:
      '무엇이 `method`의 값이어야 `{ name: "Lydia", age: 22 }`를 출력할까요?',
    code: 'const keys = ["name", "age"]\nconst values = ["Lydia", 22]\n\nconst method = /* ?? */\nObject[method](keys.map((_, i) => {\n\treturn [keys[i], values[i]]\n})) // { name: "Lydia", age: 22 }',
    correctAnswer: 3,
    variants: ["`entries`", "`values`", "`fromEntries`", "`forEach`"],
    explanation:
      '`fromEntries` 메소드는 2차원 배열을 객체로 변환해요. 각 하위 배열의 첫번 째 요소는 키가 될거고, 각 하위 배열의 요소의 두번째 요소는 값이 될거에요. 이 경우엔, keys배열에서 현재 인덱스의 아이템을 첫 번재 요소로, values의 배열에서 현재 인덱스의 아이템을 두번째 요소로 반환하는 `keys` 배열을 매핑해요.\n\n키와 값의 집합을 포함하고 있는 하위 배열을 만들었고, `{ name: "Lydia", age: 22 }`가 되어.',
    id: 153,
  },
  {
    grade: Grades.Junior,
    theme: Themes.MISC,
    question: "무엇이 출력 될까요?",
    code: 'const createMember = ({ email, address = {}}) => {\n\tconst validEmail = /.+\\@.+\\..+/.test(email)\n\tif (!validEmail) throw new Error("Valid email pls")\n\n\treturn {\n\t\temail,\n\t\taddress: address ? address : null\n\t}\n}\n\nconst member = createMember({ email: "my@email.com" })\nconsole.log(member)',
    correctAnswer: 3,
    variants: [
      '`{ email: "my@email.com", address: null }`',
      '`{ email: "my@email.com" }`',
      '`{ email: "my@email.com", address: {} }`',
      '`{ email: "my@email.com", address: undefined }`',
    ],
    explanation:
      "`address`의 기본 값은 빈 객체 `{}`예요. 변수 `member`의 값을 `createMember` 함수에서 반환한 값으로 설정하고, address의 값을 전달하지 않았어요, address의 값은 빈 객체 `{}`가 기본 값이예요. 빈객체는 진짜 같은 값으로, 조건 `address ? address : null`에서 `true`를 반환한다는 의미예요. address의 값은 빈 객체 `{}`예요.",
    id: 154,
  },
  {
    grade: Grades.Junior,
    theme: Themes.DATA_TYPES,
    question: "무엇이 출력 될까요?",
    code: 'let randomValue = { name: "Lydia" }\nrandomValue = 23\n\nif (!typeof randomValue === "string") {\n\tconsole.log("It\'s not a string!")\n} else {\n\tconsole.log("Yay it\'s a string!")\n}',
    correctAnswer: 2,
    variants: [
      "`It's not a string!`",
      "`Yay it's a string!`",
      "`TypeError`",
      "`undefined`",
    ],
    explanation:
      '`if`문 안에 조건은 `!typeof randomValue`값이 `"string"`와 같은지 여부를 확인해요. `!` 연산자는 값을 불리언 값으로 변환해요. 값이 진짜 같은 값이라면 반환될 값은 `false`가 될 거고, 만약 값이 가짜 같은 값이라면 반환될 값은 `true`가 될 거예요. 이 경우에서, `typeof randomValue`의 반환된 값은 진짜 같은 값인 `"number"`이고, `!typeof randomValue`의 값은 불리언 값 `false`라는 의미예요.\n\n`!typeof randomValue === "string"`은 실제로 `false === "string"`을 확인하기 때문에 항상 false를 반환해요. 조건은 `false`을 반환 하므로, `else`문의 코드 블록이 실행되어 `Yay it\'s a string!`가 출력돼요.',
    id: 155,
  },
];
export default questions;
